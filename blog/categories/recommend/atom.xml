<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Recommend | Winse Blog]]></title>
  <link href="http://winse.github.io/blog/categories/recommend/atom.xml" rel="self"/>
  <link href="http://winse.github.io/"/>
  <updated>2022-03-20T19:31:22+08:00</updated>
  <id>http://winse.github.io/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Try K8s]]></title>
    <link href="http://winse.github.io/blog/2019/04/10/try-k8s/"/>
    <updated>2019-04-10T15:26:32+08:00</updated>
    <id>http://winse.github.io/blog/2019/04/10/try-k8s</id>
    <content type="html"><![CDATA[<h2>1. 登录配置主机信息:</h2>

<pre><code>$ hostnamectl --static set-hostname master-1

$ cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.251.51 master-1
192.168.251.50 node-1
</code></pre>

<h2>2. 安装docker</h2>

<pre><code>cat | bash &lt;&lt;EOF
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
yum clean all
yum makecache

## docker version:(Version:           18.09.3)
# https://kubernetes.io/docs/setup/release/notes/#external-dependencies
# https://docs.docker.com/install/linux/docker-ce/centos/

yum remove docker \
  docker-client \
  docker-client-latest \
  docker-common \
  docker-latest \
  docker-latest-logrotate \
  docker-logrotate \
  docker-engine

yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2

yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
yum install -y docker-ce docker-ce-cli containerd.io

yum list docker-ce --showduplicates | sort -r

systemctl enable docker
systemctl start docker

systemctl disable firewalld
service firewalld stop

sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config 
setenforce 0
EOF
</code></pre>

<h2>3. 翻墙</h2>

<ul>
<li><a href="http://www.winseliu.com/blog/2017/07/30/kubeadm-install-kubenetes-on-centos7/">http://www.winseliu.com/blog/2017/07/30/kubeadm-install-kubenetes-on-centos7/</a></li>
<li><a href="https://serverfault.com/questions/739504/how-can-i-make-docker-compose-pull-images-using-a-socks5-proxy">https://serverfault.com/questions/739504/how-can-i-make-docker-compose-pull-images-using-a-socks5-proxy</a></li>
<li><a href="https://github.com/moby/moby/issues/23931#issuecomment-233035772">https://github.com/moby/moby/issues/23931#issuecomment-233035772</a> 2016后的版本可以用socks5了</li>
</ul>


<p>需要有在国外的主机！</p>

<ul>
<li><a href="https://tangx.in/2018/11/09/k8s-pull-image-from-gcr.io/#sniproxy">https://tangx.in/2018/11/09/k8s-pull-image-from-gcr.io/#sniproxy</a></li>
<li><a href="https://www.logcg.com/archives/984.html">https://www.logcg.com/archives/984.html</a></li>
</ul>


<p></p>

<pre><code>ssh -NC -D 1080 9.9.9.9 -p 88888

curl --socks5-hostname 127.0.0.1:1080 www.google.com

mkdir /etc/systemd/system/docker.service.d
cat &gt; /etc/systemd/system/docker.service.d/socks5-proxy.conf &lt;&lt;EOF
[Service]
Environment="ALL_PROXY=socks5://127.0.0.1:1080" "NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,192.168.0.0/16"
EOF

systemctl daemon-reload
systemctl restart docker

# cache rpm
sed -i 's/keepcache=0/keepcache=1/' /etc/yum.conf 
</code></pre>

<h2>4. 安装K8S</h2>

<p><a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/">https://kubernetes.io/docs/setup/independent/install-kubeadm/</a></p>

<p>添加repo并增加代理配置</p>

<pre><code>cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
exclude=kube*
proxy=socks5://127.0.0.1:1080
EOF


    ## yum.conf allows you to have per-repository settings as well as global ([main]) settings, 也可以定义在单个repo的配置里面！
    ##sed '$a\\nproxy=socks5://127.0.0.1:1080' /etc/yum.conf 
    ## proxy=_none_


# Set SELinux in permissive mode (effectively disabling it)
setenforce 0
sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes

systemctl enable --now kubelet
</code></pre>

<h2>5. 配置K8S</h2>

<ul>
<li><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/">https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/</a></li>
<li><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network">https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network</a></li>
</ul>


<p>5.1 先加载镜像</p>

<pre><code>$ kubeadm config images pull
I0409 00:04:13.693615   18479 version.go:96] could not fetch a Kubernetes version from the internet: unable to get URL "https://dl.k8s.io/release/stable-1.txt": Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
I0409 00:04:13.694196   18479 version.go:97] falling back to the local client version: v1.14.0
[config/images] Pulled k8s.gcr.io/kube-apiserver:v1.14.0
[config/images] Pulled k8s.gcr.io/kube-controller-manager:v1.14.0
[config/images] Pulled k8s.gcr.io/kube-scheduler:v1.14.0
[config/images] Pulled k8s.gcr.io/kube-proxy:v1.14.0
[config/images] Pulled k8s.gcr.io/pause:3.1
[config/images] Pulled k8s.gcr.io/etcd:3.3.10
[config/images] Pulled k8s.gcr.io/coredns:1.3.1
</code></pre>

<p>5.2 初始化</p>

<pre><code>$ kubeadm init --pod-network-cidr=10.244.0.0/16
</code></pre>

<p>会遇到的问题1： <a href="https://github.com/kubernetes/kubeadm/issues/610">https://github.com/kubernetes/kubeadm/issues/610</a></p>

<pre><code>$ journalctl -xeu kubelet
....
Apr 09 00:35:33 docker81 kubelet[24062]: I0409 00:35:33.996517   24062 server.go:625] --cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /
Apr 09 00:35:33 docker81 kubelet[24062]: F0409 00:35:33.996923   24062 server.go:265] failed to run Kubelet: Running with swap on is not supported, please disable swap! or set --fail-swap
Apr 09 00:35:33 docker81 systemd[1]: kubelet.service: main process exited, code=exited, status=255/n/a
Apr 09 00:35:34 docker81 systemd[1]: Unit kubelet.service entered failed state.
Apr 09 00:35:34 docker81 systemd[1]: kubelet.service failed.
</code></pre>

<p>处理：</p>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/31398416">https://zhuanlan.zhihu.com/p/31398416</a> (关闭swap)使用kubeadm创建一个K8s 1.10的Cluster</li>
</ul>


<pre><code>$ swapoff -a
$ sed -i '/swap/s/^/#/' /etc/fstab


    # 禁用命令
    sudo swapoff -a
    # 启用命令
    sudo swapon -a
    # 把根目录文件系统设为可读写
    sudo mount -n -o remount,rw /
</code></pre>

<p>5.3 再次初始化</p>

<p>先清理</p>

<pre><code>$ 
kubeadm reset
iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X

$ kubeadm init --pod-network-cidr=10.244.0.0/16

I0409 05:19:35.856967    3656 version.go:96] could not fetch a Kubernetes version from the internet: unable to get URL "https://dl.k8s.io/release/stable-1.txt": Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
I0409 05:19:35.857127    3656 version.go:97] falling back to the local client version: v1.14.1
[init] Using Kubernetes version: v1.14.1
[preflight] Running pre-flight checks
        [WARNING Firewalld]: firewalld is active, please ensure ports [6443 10250] are open or your cluster may not function correctly
        [WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/
        [WARNING Hostname]: hostname "master-1" could not be reached
        [WARNING Hostname]: hostname "master-1": lookup master-1 on 192.168.253.254:53: no such host
[preflight] Pulling images required for setting up a Kubernetes cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Activating the kubelet service
[certs] Using certificateDir folder "/etc/kubernetes/pki"
[certs] Generating "ca" certificate and key
[certs] Generating "apiserver" certificate and key
[certs] apiserver serving cert is signed for DNS names [master-1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.251.51]
[certs] Generating "apiserver-kubelet-client" certificate and key
[certs] Generating "front-proxy-ca" certificate and key
[certs] Generating "front-proxy-client" certificate and key
[certs] Generating "etcd/ca" certificate and key
[certs] Generating "etcd/peer" certificate and key
[certs] etcd/peer serving cert is signed for DNS names [master-1 localhost] and IPs [192.168.251.51 127.0.0.1 ::1]
[certs] Generating "etcd/healthcheck-client" certificate and key
[certs] Generating "apiserver-etcd-client" certificate and key
[certs] Generating "etcd/server" certificate and key
[certs] etcd/server serving cert is signed for DNS names [master-1 localhost] and IPs [192.168.251.51 127.0.0.1 ::1]
[certs] Generating "sa" key and public key
[kubeconfig] Using kubeconfig folder "/etc/kubernetes"
[kubeconfig] Writing "admin.conf" kubeconfig file
[kubeconfig] Writing "kubelet.conf" kubeconfig file
[kubeconfig] Writing "controller-manager.conf" kubeconfig file
[kubeconfig] Writing "scheduler.conf" kubeconfig file
[control-plane] Using manifest folder "/etc/kubernetes/manifests"
[control-plane] Creating static Pod manifest for "kube-apiserver"
[control-plane] Creating static Pod manifest for "kube-controller-manager"
[control-plane] Creating static Pod manifest for "kube-scheduler"
[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s
[apiclient] All control plane components are healthy after 13.506192 seconds
[upload-config] storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace
[kubelet] Creating a ConfigMap "kubelet-config-1.14" in namespace kube-system with the configuration for the kubelets in the cluster
[upload-certs] Skipping phase. Please see --experimental-upload-certs
[mark-control-plane] Marking the node master-1 as control-plane by adding the label "node-role.kubernetes.io/master=''"
[mark-control-plane] Marking the node master-1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: zpf7je.xarawormfaeapib3
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstrap-token] creating the "cluster-info" ConfigMap in the "kube-public" namespace
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.251.51:6443 --token zpf7je.xarawormfaeapib3 \
    --discovery-token-ca-cert-hash sha256:d7ff941542a03645209ad4149e1baa1c40ddad7e9c8296f82fe3bd2a91191f66 
</code></pre>

<p>执行添加kubeconfig配置</p>

<pre><code>$ 
  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>

<p>5.4 查看状态</p>

<pre><code>$ kubectl cluster-info 

Kubernetes master is running at https://192.168.251.51:6443
KubeDNS is running at https://192.168.251.51:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.


$ kubectl get pods -n kube-system 
$ kubectl get pods --all-namespaces

NAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE
kube-system   coredns-fb8b8dccf-hcrgw            0/1     Pending   0          100s
kube-system   coredns-fb8b8dccf-zct25            0/1     Pending   0          100s
kube-system   etcd-master-1                      1/1     Running   0          57s
kube-system   kube-apiserver-master-1            1/1     Running   0          47s
kube-system   kube-controller-manager-master-1   1/1     Running   0          62s
kube-system   kube-proxy-p962p                   1/1     Running   3          100s
kube-system   kube-scheduler-master-1            1/1     Running   0          45s
</code></pre>

<p>5.5 添加网卡，dns的pod启动需要网络组建的支撑</p>

<pre><code>$ cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
$ sysctl --system


$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml

clusterrole.rbac.authorization.k8s.io/flannel created
clusterrolebinding.rbac.authorization.k8s.io/flannel created
serviceaccount/flannel created
configmap/kube-flannel-cfg created
daemonset.extensions/kube-flannel-ds-amd64 created
daemonset.extensions/kube-flannel-ds-arm64 created
daemonset.extensions/kube-flannel-ds-arm created
daemonset.extensions/kube-flannel-ds-ppc64le created
daemonset.extensions/kube-flannel-ds-s390x created
</code></pre>

<p>查看状态，现在coredns也已经启动了</p>

<pre><code>$ kubectl get pods --all-namespaces

NAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE
kube-system   coredns-fb8b8dccf-hcrgw            1/1     Running   0          8m7s
kube-system   coredns-fb8b8dccf-zct25            1/1     Running   0          8m7s
kube-system   etcd-master-1                      1/1     Running   0          7m24s
kube-system   kube-apiserver-master-1            1/1     Running   0          7m14s
kube-system   kube-controller-manager-master-1   1/1     Running   0          7m29s
kube-system   kube-flannel-ds-amd64-947zx        1/1     Running   0          2m32s
kube-system   kube-proxy-p962p                   1/1     Running   3          8m7s
kube-system   kube-scheduler-master-1            1/1     Running   0          7m12s
</code></pre>

<h2>6. 安装Dashboard</h2>

<ul>
<li><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#control-plane-node-isolation">https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#control-plane-node-isolation</a></li>
<li><a href="https://github.com/kubernetes/dashboard#kubernetes-dashboard">https://github.com/kubernetes/dashboard#kubernetes-dashboard</a></li>
<li><a href="https://github.com/kubernetes/dashboard/wiki/Installation#update">https://github.com/kubernetes/dashboard/wiki/Installation#update</a></li>
</ul>


<p>先解除master不能部署pod的限制，然后部署dashboard：</p>

<pre><code>$ kubectl taint nodes --all node-role.kubernetes.io/master-

node/master-1 untainted

$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml

secret/kubernetes-dashboard-certs created
serviceaccount/kubernetes-dashboard created
role.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created
rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created
deployment.apps/kubernetes-dashboard created
service/kubernetes-dashboard created
</code></pre>

<p>查看日志，故障定位</p>

<pre><code>kubectl describe pod kubernetes-dashboard-5f7b999d65-lt2df -n kube-system
</code></pre>

<p>查看状态</p>

<pre><code>$ kubectl get pods --all-namespaces

NAMESPACE     NAME                                    READY   STATUS    RESTARTS   AGE
kube-system   coredns-fb8b8dccf-hcrgw                 1/1     Running   0          15m
kube-system   coredns-fb8b8dccf-zct25                 1/1     Running   0          15m
kube-system   etcd-master-1                           1/1     Running   0          14m
kube-system   kube-apiserver-master-1                 1/1     Running   0          14m
kube-system   kube-controller-manager-master-1        1/1     Running   0          15m
kube-system   kube-flannel-ds-amd64-947zx             1/1     Running   0          10m
kube-system   kube-proxy-p962p                        1/1     Running   3          15m
kube-system   kube-scheduler-master-1                 1/1     Running   0          14m
kube-system   kubernetes-dashboard-5f7b999d65-lt2df   1/1     Running   0          6m6s
</code></pre>

<h2>7. 访问Dashboard</h2>

<ul>
<li><a href="https://github.com/kubernetes/dashboard/wiki/Accessing-Dashboard---1.7.X-and-above">https://github.com/kubernetes/dashboard/wiki/Accessing-Dashboard---1.7.X-and-above</a></li>
</ul>


<p>7.1 本地查看</p>

<pre><code>$ kubectl proxy
Starting to serve on 127.0.0.1:8001

http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy
</code></pre>

<p>7.2 用户浏览器查看</p>

<p>1* 失败的方法：</p>

<p>disable-filter=true表示禁用请求过滤功能，否则我们的请求会被拒绝，并提示 <code>Forbidden (403) Unauthorized</code> 。</p>

<pre><code>$ kubectl proxy --address=0.0.0.0 --disable-filter=true
</code></pre>

<p>可以成功访问到登录界面，但是却无法登录，这是因为Dashboard使用HTTP连接只允许localhost和127.0.0.1进行访问（限制为必须在kubectl执行的机器上访问），而其它地址只允许使用HTTPS。</p>

<p>2* 应该可行方法：（没有试）</p>

<p>Kubernetes API Server新增了 <code>-–anonymous-auth</code> 选项设置为 false，允许匿名请求访问secure port；再使用 <code>--basic-auth-file</code> 配置使用用户名登录。</p>

<p><a href="https://www.okay686.cn/984.html">https://www.okay686.cn/984.html</a></p>

<p>3* 证书+Token的方法：</p>

<ul>
<li><ul>
<li><a href="https://www.cnblogs.com/RainingNight/p/deploying-k8s-dashboard-ui.html">https://www.cnblogs.com/RainingNight/p/deploying-k8s-dashboard-ui.html</a> kubernetes-dashboard(1.8.3)部署与踩坑</li>
</ul>
</li>
<li><a href="https://stackoverflow.com/questions/45094665/user-systemanonymous-cannot-get-path">https://stackoverflow.com/questions/45094665/user-systemanonymous-cannot-get-path</a></li>
<li><a href="https://stackoverflow.com/questions/46664104/how-to-sign-in-kubernetes-dashboard">https://stackoverflow.com/questions/46664104/how-to-sign-in-kubernetes-dashboard</a> How to sign in kubernetes dashboard?</li>
<li><a href="https://www.jianshu.com/p/6f42ac331d8a">https://www.jianshu.com/p/6f42ac331d8a</a> (了解Dashboard RABC ) 从零开始搭建Kubernetes集群（四、搭建K8S Dashboard）</li>
<li><a href="https://stackoverflow.com/a/49992698">https://stackoverflow.com/a/49992698</a> (命令行创建一个dashboard token)</li>
<li><a href="https://andrewpqc.github.io/2018/04/25/k8s-dashboard-auth/">https://andrewpqc.github.io/2018/04/25/k8s-dashboard-auth/</a>  Kubernetes-dashboard的身份认证</li>
</ul>


<p></p>

<ul>
<li><a href="https://unofficialism.info/posts/accessing-rbac-enabled-kubernetes-dashboard/">https://unofficialism.info/posts/accessing-rbac-enabled-kubernetes-dashboard/</a></li>
</ul>


<p>3-1 证书</p>

<ul>
<li><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/implementation-details/#generate-the-necessary-certificates">https://kubernetes.io/docs/reference/setup-tools/kubeadm/implementation-details/#generate-the-necessary-certificates</a></li>
<li><a href="https://stackoverflow.com/questions/45094665/user-systemanonymous-cannot-get-path">https://stackoverflow.com/questions/45094665/user-systemanonymous-cannot-get-path</a> (Token)User “system:anonymous” cannot get path “/”</li>
<li><a href="https://jimmysong.io/kubernetes-handbook/guide/kubectl-user-authentication-authorization.html">https://jimmysong.io/kubernetes-handbook/guide/kubectl-user-authentication-authorization.html</a>(kubeconfig) 创建用户认证授权的kubeconfig文件</li>
</ul>


<p>官方文档介绍：</p>

<ul>
<li><a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/">https://kubernetes.io/docs/concepts/cluster-administration/certificates/</a></li>
<li><a href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/">https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/</a></li>
<li><a href="https://github.com/kubernetes/dashboard/wiki/Certificate-management">https://github.com/kubernetes/dashboard/wiki/Certificate-management</a></li>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/#kubelet-authentication">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/#kubelet-authentication</a></li>
</ul>


<p><strong>方法0：</strong></p>

<p>申请证书</p>

<p><strong>方法1：</strong></p>

<p>对于API Server来说，它是使用证书进行认证的，我们需要先创建一个证书。首先找到kubectl命令的配置文件，默认情况下为 <code>/etc/kubernetes/admin.conf</code> 已经复制到了 <code>~/.kube/config</code> 中。然后我们使用client-certificate-data和client-key-data生成一个p12文件，可使用下列命令：</p>

<pre><code>grep 'client-certificate-data' ~/.kube/config | head -n 1 | awk '{print $2}' | base64 -d &gt;&gt; kubecfg.crt
grep 'client-key-data' ~/.kube/config | head -n 1 | awk '{print $2}' | base64 -d &gt;&gt; kubecfg.key
openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name "kubernetes-client"
</code></pre>

<p>最后导入上面生成的p12文件，重新打开浏览器。</p>

<p><strong>方法偷懒2：</strong></p>

<p>What&rsquo;s causing: forbidden: User &ldquo;system:anonymous&rdquo; in some Cloud Providers
<a href="https://github.com/kubernetes-incubator/apiserver-builder-alpha/issues/225">https://github.com/kubernetes-incubator/apiserver-builder-alpha/issues/225</a></p>

<p>After reading this: <a href="https://kubernetes.io/docs/admin/authentication/#anonymous-requests">https://kubernetes.io/docs/admin/authentication/#anonymous-requests</a> then I tried this:</p>

<pre><code>kubectl create clusterrolebinding cluster-system-anonymous --clusterrole=cluster-admin --user=system:anonymous
</code></pre>

<p>and it solved the problem.</p>

<p>3-2 权限</p>

<ul>
<li><a href="https://github.com/kubernetes/dashboard/wiki/Access-control#admin-privileges">https://github.com/kubernetes/dashboard/wiki/Access-control#admin-privileges</a></li>
<li><a href="https://github.com/kubernetes/dashboard/wiki/Access-control#authentication">https://github.com/kubernetes/dashboard/wiki/Access-control#authentication</a></li>
<li><a href="https://github.com/kubernetes/dashboard/wiki/Access-control#getting-token-with-kubectl">https://github.com/kubernetes/dashboard/wiki/Access-control#getting-token-with-kubectl</a></li>
</ul>


<p>方法1：创建新的用户</p>

<p></p>

<pre><code>[root@docker81 ~]# vi dashboard-admin-user.yml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system

---
# ------------ role binding ---------------- #
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system

[root@docker81 ~]# kubectl create -f dashboard-admin-user.yml
serviceaccount/admin-user created
clusterrolebinding.rbac.authorization.k8s.io/admin-user created

[root@docker81 ~]# kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
Name:         admin-user-token-28dwk
Namespace:    kube-system
Labels:       &lt;none&gt;
Annotations:  kubernetes.io/service-account.name: admin-user
              kubernetes.io/service-account.uid: c23340a7-5a70-11e9-b2ca-005056887940

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  11 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLTI4ZHdrIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJjMjMzNDBhNy01YTcwLTExZTktYjJjYS0wMDUwNTY4ODc5NDAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06YWRtaW4tdXNlciJ9.uaG_faYzLhiadXfz4XuQ_-X9tdl5exKQjbCK7OJqBFMCYve532O-8jH_zg5E2rgFUQycQUhH_siS_GCi0MoE8mqc-WJwIfaGB6QnLYOFRjvWWNhO_16FH56YaEZxGY2p62OPt4d1O9NK4KZLEcoZNbYYuol_9kBfAj9Imf3ii58TNGZ0WiRigXjLOsJK5P2IPyE4c_rqunsrb_sO1z56jgRTL9qnu2zsby8obJxNZefBnsTgakXnu-P8PwXg0PekLBWQNNr-G7TeiKCpfCGCjHM6gmEKdTjiernFbD1GxOG588pmZfWsFtjNNWuNAlfMe1bXpy2m981taQUTQa3kWQ
</code></pre>

<p>访问HTTPS地址：</p>

<p><a href="https://192.168.251.51:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login">https://192.168.251.51:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login</a></p>

<p>方法2：源头下手</p>

<p></p>

<p>kubernetes-dashboard.yaml的介绍，现在就理解了为什么其角色的名称为kubernetes-dashboard-minimal。一句话，这个Role的权限不够！
因此，我们可以更改RoleBinding修改为ClusterRoleBinding，并且修改roleRef中的kind和name，使用cluster-admin这个非常牛逼的CusterRole（超级用户权限，其拥有访问kube-apiserver的所有权限）。如下：</p>

<pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kubernetes-dashboard-minimal
  namespace: kube-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: kubernetes-dashboard
  namespace: kube-system
</code></pre>

<p>修改后，重新创建kubernetes-dashboard.yaml，Dashboard就可以拥有访问整个K8S 集群API的权限。</p>

<p>3-3 忽略登录</p>

<pre><code>kubectl edit deployment/kubernetes-dashboard --namespace=kube-system

      - args:
        - --auto-generate-certificates
        - --enable-skip-login
</code></pre>

<h2>8. 部署应用</h2>

<ul>
<li><a href="https://blog.51cto.com/12462495/2356619?source=dra">https://blog.51cto.com/12462495/2356619?source=dra</a></li>
<li><a href="https://kubernetes.io/docs/tasks/run-application/">https://kubernetes.io/docs/tasks/run-application/</a></li>
<li><a href="https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/">https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/</a></li>
</ul>


<pre><code>[root@s1 ~]# kubectl create -f https://k8s.io/docs/tasks/run-application/deployment.yaml
deployment.apps/nginx-deployment created

kubectl describe deployment nginx-deployment
kubectl get pods -l app=nginx

[root@s1 ~]# kubectl describe pod nginx-deployment-76bf4969df-bmslp 

kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml
kubectl apply -f https://k8s.io/docs/tutorials/stateless-application/deployment-update.yaml
kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml

kubectl describe deployment nginx-deployment
kubectl get pods -l app=nginx
kubectl describe pod &lt;pod-name&gt;

[root@s1 ~]# curl 172.17.0.4

kubectl delete deployment nginx-deployment
</code></pre>

<p><a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/">https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/</a></p>

<pre><code>[root@docker81 ~]# curl localhost:8001/api
{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "192.168.193.81:6443"
    }
  ]
}

[root@docker81 ~]# curl localhost:8001/api/v1/namespaces/default/pods
{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "selfLink": "/api/v1/namespaces/default/pods",
    "resourceVersion": "25607"
  },
  "items": []
}
</code></pre>

<h2>9. 一些命令：</h2>

<pre><code>kubectl cluster-info

kubectl get nodes --all-namespaces -o wide

kubectl get pods –namespace=kube-system
kubectl get pod --all-namespaces=true

kubectl describe pods
kubectl describe pod coredns-7748f7f6df-7p58x --namespace=kube-system

kubectl get services kube-dns --namespace=kube-system

kubectl logs -n cattle-system cattle-node-agent-w5rj4

kubectl -n kube-system get secret
kubectl -n kube-system describe secret kubernetes-dashboard-token-zlfj7
kubectl -n kube-system get secret kubernetes-dashboard-token-zlfj7 -o yaml

kubectl -n kube-system describe $(kubectl -n kube-system get secret -n kube-system -o name | grep namespace) | grep token

kubectl -n kube-system get service kubernetes-dashboard
kubectl -n kube-system get svc kubernetes-dashboard
kubectl -n kube-system get secret admin-token-nwphb -o jsonpath={.data.token}|base64 -d
kubectl get secret $(kubectl get serviceaccount my-admin-user -n kube-system -o jsonpath="{.secrets[0].name}") -o jsonpath="{.data.token}" -n kube-system | base64 --decode

kubectl delete -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/alternative/kubernetes-dashboard.yaml 

kubectl -n kube-system edit service kubernetes-dashboard

kubectl -n kube-system delete $(kubectl -n kube-system get pod -o name | grep dashboard)

kubectl delete pod NAME --grace-period=0 --force
</code></pre>

<ul>
<li>DNS解析：进入容器执行命令</li>
</ul>


<pre><code>[root@k8s-master app]# kubectl exec -it coredns-78fcdf6894-244mp /bin/sh  -n kube-system                         
/ # nslookup kubernetes.default 127.0.0.1
</code></pre>

<ul>
<li>K8S二进制部署node节点 <a href="https://blog.51cto.com/ylw6006/2104692">https://blog.51cto.com/ylw6006/2104692</a></li>
</ul>


<p></p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[视频自动翻译]]></title>
    <link href="http://winse.github.io/blog/2018/08/25/video-auto-translate/"/>
    <updated>2018-08-25T21:27:54+08:00</updated>
    <id>http://winse.github.io/blog/2018/08/25/video-auto-translate</id>
    <content type="html"><![CDATA[<p>现在语音翻译应用越来越广泛了。其实视频内的音频应该也可以通过语音的处理方式，来达到添加字幕以及翻译的效果。</p>

<p>google翻译页面已有语音输入的按钮，只是需要我们把电脑视频的声音转换作为 <strong>电脑输入</strong> 就行了。</p>

<h2>语音识别翻译链接</h2>

<p><a href="https://speechlogger.appspot.com/zh/">https://speechlogger.appspot.com/zh/</a></p>

<p>翻译</p>

<ul>
<li><a href="https://translate.google.cn">https://translate.google.cn</a></li>
<li><a href="https://www.google.com/intl/en/chrome/demos/speech.html">https://www.google.com/intl/en/chrome/demos/speech.html</a></li>
</ul>


<h2>实现/处理方法</h2>

<h4>转换工具</h4>

<p>第一种（推荐）: 使用 <a href="https://www.vb-audio.com/Voicemeeter/index.htm">VoiceMeeter</a></p>

<ul>
<li><a href="https://www.youtube.com/watch?v=91acHQfYj48">Speechlogger可以边看国外视频边翻译，如果无法识别音频怎么办？</a></li>
</ul>


<p>第二种：使用 <a href="https://software.muzychenko.net/eng/vac.htm#download">virtual audio cable sofeware</a></p>

<ul>
<li><a href="https://www.youtube.com/watch?v=CleLvQWy8-c">How to convert audio to text (mp3 to text)</a></li>
</ul>


<h4>详细步骤：</h4>

<ol>
<li>安装（以上任意一种）转换工具</li>
<li>设置系统声音的 <strong>播放设备</strong></li>
<li>在浏览器中点击 录音按钮 后，点击 浏览器地址栏 的右侧麦克风按钮，<strong>麦克风</strong> 下拉菜单中设置使用的设备（如：VoiceMeeter Output）</li>
<li>（可选）如果想翻译同时自己也听到，打开 Voicemeeter 软件就行了，程序会自动输出选择一个输出。</li>
</ol>


<p>记住，<strong>不能静音</strong>，同时要打开 <strong>系统的麦克风</strong> ！！</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[科学上网（续）]]></title>
    <link href="http://winse.github.io/blog/2018/06/09/reasonable-way-to-access-the-internet/"/>
    <updated>2018-06-09T14:03:11+08:00</updated>
    <id>http://winse.github.io/blog/2018/06/09/reasonable-way-to-access-the-internet</id>
    <content type="html"><![CDATA[<p>到新的环境就会遇到新的问题，需要不断的学习更新来适应新的环境。上网也是一样，工作地点和家里存在了一道鸿沟。过去断断续续的有一些解决的方式，但是总是有点间接。</p>

<ul>
<li><a href="http://www.winseliu.com/blog/2017/11/04/teamviewer-vpn-on-windows/">使用TeamviewerVPN访问公司内网</a></li>
<li><a href="http://www.winseliu.com/blog/2017/02/04/privoxy-http-proxy-for-shadowsocks/">使用Privoxy把shadowsocks转换为Http代理</a></li>
<li><a href="http://www.winseliu.com/blog/2016/03/11/install-and-config-openvpn/">安装配置OpenVPN</a></li>
<li><a href="http://www.winseliu.com/blog/2015/11/22/gfw-ladder/">搭梯笔记</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">SSH原理与运用（二）：远程操作与端口转发</a></li>
<li><a href="http://www.winseliu.com/blog/2015/09/06/squid-http-proxy-server-install/">安装http代理服务器squid</a></li>
<li><a href="http://www.winseliu.com/blog/2017/10/30/windows-run-ubuntu/">Windows Run Ubuntu</a></li>
</ul>


<p>上周和同事讨论到在家访问公司服务器的方式时，可以通过花生壳的DDNS来实现域名动态绑定，相当于了把家里的宽带看做一个公网IP，花生壳实时的把域名解析更新为最新的IP。</p>

<p>其实有了公网IP绑定域名后，就可以在公司访问自己的域名（绑定到了家里的IP），公司连自己域名做一个 <em>反向代理</em> ，然后就可以在家直接访问公司的环境了。</p>

<p>但是查了下对于花生壳的口碑都不咋的，其实只要能自动的更新绑定域名和宽带的IP（电信宽带给的是动态IP，使用动态域名绑定），和花生壳的效果是一样。然后在 github 查到了 <code>aliyun-ddns</code> 可以同时定时检测来更新阿里云上的域名解析。</p>

<p>首先通过域名映射到家里电信宽带的公网IP，ddns用来适配电信IP的动态分配； <br/>
然后在家里局域网的一台机器开个SSH的服务；  <br/>
再在家里路由上做端口转发到ssh主机。这样就可以在公司通过 <code>ssh -p port my-domain</code> 连回家了。</p>

<h2>DDNS配置：映射域名到自己的公网IP</h2>

<p><a href="https://github.com/yyqian/aliyun-ddns">aliyun-ddns</a> 老版本有些复杂，我在此基础上一个<a href="https://github.com/winse/aliyun-ddns">本地命令行的版本</a> ，直接运行一个脚本就可以更新域名解析了：</p>

<pre><code>./client.sh myhome.winseliu.com
</code></pre>

<p><img src="/images/blogs/aliyun-dns.png" alt="" /></p>

<p>注：默认电信宽带给你分配的内网IP的，你可以打10000号要他们给你分配改成公网IP。</p>

<h2>本地环境配置</h2>

<ul>
<li>本地SSHD配置</li>
</ul>


<pre><code>winse@DESKTOP-ADH7K1Q:~$ sudo dpkg-reconfigure openssh-server
winse@DESKTOP-ADH7K1Q:~$ sudo service ssh start
</code></pre>

<ul>
<li>无秘密登录配置</li>
</ul>


<p>为了安全，通过公网的SSH访问最好通过秘钥登录，把SSH密码登录的方式给关掉。</p>

<pre><code>winse@DESKTOP-ADH7K1Q:~/.ssh$ cat /business/server/id_rsa.pub &gt;&gt;authorized_keys
</code></pre>

<p></p>

<ul>
<li>本机防火墙开放22端口</li>
</ul>


<p>参考 <a href="https://blog.csdn.net/zzq900503/article/details/11936379">开放windows服务器端口&mdash;&ndash;以打开端口8080为例</a></p>

<p><img src="/images/blogs/ddns-local-firewall.png" alt="" /></p>

<ul>
<li>路由器端口映射配置</li>
</ul>


<p><img src="/images/blogs/ddns-route-portforwarding.png" alt="" /></p>

<h2>穿透：配置反向代理</h2>

<p>在公司(机器)访问自己的域名，使用ssh的 <code>-R</code> 反向代理参数连接在家里电脑，在家里电脑新建一个5432的端口绑定(数据转发)到服务器的5432端口。这样当你在家电脑连本地的 <code>127.0.0.1:5432</code> 就相当于连接了服务器的 5432 端口。</p>

<pre><code>/usr/bin/autossh -M 0 -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -o StrictHostKeyChecking=no \
-N -R 5432:localhost:5432 -i ~/.ssh/id_rsa autossh@myhome.winseliu.com 
</code></pre>

<p></p>

<p>当autossh连接太慢、并且SSH提示信息一直不出来，你完全有理由怀疑本地端口被占用了！！查看本地端口状态：</p>

<pre><code>C:\Users\winse&gt;netstat /?

C:\Users\winse&gt;netstat -ano |findstr 5432
</code></pre>

<p>如果端口被占用了，需要去任务管理器中关掉对应PID的程序。</p>

<p></p>

<h2>小结</h2>

<p>速度比 teamviewer vpn 的方式快狠多狠多！！这个10000号值得打，这个ddns值得一试。</p>

<h2>后记</h2>

<h3>说说 VS Code调试</h3>

<p>在写脚本bat/sh的过程中，需要用到nodejs的调试。</p>

<p>使用Windows Ubuntu中安装的Node：</p>

<ul>
<li><a href="https://blogs.msdn.microsoft.com/commandline/2017/10/27/running-node-js-on-wsl-from-visual-studio-code/">Running Node.js on WSL from Visual Studio Code</a></li>
<li><a href="https://stackoverflow.com/a/47495710/5697508">Using Visual Studio Code on Windows with Ubuntu-Bash and NodeJS</a></li>
</ul>


<pre><code>"useWSL": true
</code></pre>

<p><a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging">https://code.visualstudio.com/docs/nodejs/nodejs-debugging</a></p>

<p>注意：这种外部启动的方式，会通过bash.sh运行node，所以就算停止调试后，Node进程还是一直存在的！！！需要通过任务管理器关闭。</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitalk on Octopress]]></title>
    <link href="http://winse.github.io/blog/2018/01/20/gitalk-on-octopress/"/>
    <updated>2018-01-20T15:41:00+08:00</updated>
    <id>http://winse.github.io/blog/2018/01/20/gitalk-on-octopress</id>
    <content type="html"><![CDATA[<p>以前有添加过 多说 ，步骤都类似的。其实就是调用一个第三方的服务，把评论的数据存储在第三方。</p>

<p>可以先看看 <a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">gitalk 的文档</a> ，分四步：</p>

<ul>
<li>注册一个github 的 <a href="https://github.com/settings/developers">OAuth Apps</a></li>
<li>添加div容器</li>
<li>加入css，js依赖</li>
<li>调用javascript显示</li>
</ul>


<h2>配置</h2>

<h4>注册一个github应用</h4>

<ul>
<li><a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></li>
</ul>


<h4>在 <code>_layouts/post.html</code> 的 Comments 下添加一个 gitalk-container 的节点：</h4>

<p>（粘贴后把大括号和百分号之间的空格去掉）</p>

<p>```
{ % if site.disqus_short_name and page.comments == true % }
  <section>
    <h1>Comments</h1></p>

<!-- gitalk评论 start -->


<pre><code>&lt;div id="gitalk-container"&gt;&lt;/div&gt; 
</code></pre>

<!-- gitalk评论 end -->


<p>  </section>
{ % endif % }
```</p>

<h4>在 <code>_includes</code> 目录下增加一个 gitalk.html 的页面，添加依赖并添加初始化代码：</h4>

<p>这里clientID，clientSecret对应第一步注册应用的id和secret。</p>

<p>在官网文档给的例子上调整了一下: id， body, createIssueManually。代码里面是通过 <code>labels + id</code> 来查询对应的issue：<a href="https://github.com/gitalk/gitalk/blob/9a2c6e94281a628a8e0f1ccbdceebd5d17bc1756/src/gitalk.jsx#L174">查询Issue源码</a></p>

<p>（粘贴后把大括号和百分号之间的空格去掉）</p>

<p>```
{ % if site.disqus_short_name and page.comments != false % }</p>

<p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"></p>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>




<script>

var gitalk = new Gitalk({
  clientID: 'c14f68eac6330d15d984',
  clientSecret: '73b7c1fffa98e299ff0cdd332821201933858e6e',
  repo: 'winse.github.com',
  owner: 'winse',
  admin: ['winse'],
  id: location.pathname,
  labels: ['Gitalk'],
  body: "http://winse.github.io" + location.pathname,
  createIssueManually: true,
  
  // facebook-like distraction free mode
  distractionFreeMode: false
})

gitalk.render('gitalk-container')

</script>


<p>{ % endif % }
```</p>

<p>然后在同一级目录的 after_footer.html 新增一条 这个新页面一个引用（粘贴后把大括号和百分号之间的空格去掉）:</p>

<pre><code>{ % include gitalk.html % }
</code></pre>

<h2>初始化</h2>

<ul>
<li><a href="https://github.com/gitalk/gitalk/wiki/%E8%AF%84%E8%AE%BA%E5%88%9D%E5%A7%8B%E5%8C%96">https://github.com/gitalk/gitalk/wiki/%E8%AF%84%E8%AE%BA%E5%88%9D%E5%A7%8B%E5%8C%96</a></li>
<li><a href="https://draveness.me/git-comments-initialize">https://draveness.me/git-comments-initialize</a></li>
<li><a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></li>
</ul>


<p>其实就是在对应的repo下面建一个repo，注意下 <strong>labels</strong> 规则就行了：</p>

<pre><code>username = "winse" # GitHub 用户名

# https://github.com/settings/tokens
new_token = ""  # GitHub Token
repo_name = "winse.github.com" # 存放 issues

sitemap_url = "sitemap.xml" # sitemap
kind = "Gitalk"

# 可以结合git的状态，added的调用命令创建一个issue

# 除了使用Token，也可以手动输入密码
curl -H "Accept: application/json" -X POST -d '{"body": "http://winseliu.com/blog/2017/11/20/sed-debug-sedsed/", "labels": ["Gitalk", "/blog/2017/11/20/sed-debug-sedsed/"], "title": "gitalk 测试" }' -u $username https://api.github.com/repos/$username/$repo_name/issues
Enter host password for user 'winse':

OR

# https://developer.github.com/v3/auth/#basic-authentication
curl -u username:token https://api.github.com/user
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="http://qiubaiying.top/2017/12/19/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/">为博客添加 Gitalk 评论插件</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Sphinx生成/管理文档]]></title>
    <link href="http://winse.github.io/blog/2017/11/16/sphinx-generate-docs/"/>
    <updated>2017-11-16T23:23:23+08:00</updated>
    <id>http://winse.github.io/blog/2017/11/16/sphinx-generate-docs</id>
    <content type="html"><![CDATA[<p>很多开源的软件都使用Sphinx来进行文档的管理，其中Ansible就是其中一个。</p>

<p>Sphinx使用 类MarkDown的reStructuredText格式 来进行内容的编写，然后使用 sphinx-build 命令来生成html文件。</p>

<h2>安装、入门</h2>

<ul>
<li><a href="http://www.sphinx-doc.org/en/stable/tutorial.html">http://www.sphinx-doc.org/en/stable/tutorial.html</a></li>
<li><a href="http://www.sphinx-doc.org/en/stable/rest.html">reStructuredText</a></li>
<li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/rest.html">reStructuredText 简介</a></li>
<li><a href="http://www.sphinx-doc.org/en/stable/markup/index.html">Sphinx Markup Constructs</a></li>
<li><a href="http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html">ReST – reStructuredText</a> GOOD!</li>
<li><a href="http://www.bijishequ.com/detail/261642">reStructuredText(rst)快速入门语法说明</a></li>
<li><a href="http://sphinx-doc.readthedocs.io/zh_CN/latest/rest.html#id9">章节</a></li>
</ul>


<pre><code>sudo apt-get install python-pip
sudo pip install Sphinx

sphinx-quickstart
</code></pre>

<p>引用：</p>

<pre><code>
*重点(emphasis)通常显示为斜体*
`解释文字(interpreted text)通常显示为斜体`

**重点强调(strong emphasis)通常显示为粗体**

``行内文本(inline literal)通常显示为等宽文本，空格可以保留，但是换行不可以。``

章节头部由下线(也可有上线)和包含标点的标题 组合创建, 其中下线要至少等于标准文本的长度。
可以表示标题的符号有 =、-、`、:、'、"、~、^、_ 、* 、+、 #、&lt;、&gt; 。
对于相同的符号，有上标是一级标题，没有上标是二级标题。
标题最多分六级，可以自由组合使用。

# with overline, for parts
* with overline, for chapters
=, for sections
-, for subsections
^, for subsubsections
", for paragraphs
</code></pre>

<h2>主题</h2>

<ul>
<li><a href="http://www.sphinx-doc.org/en/stable/theming.html">http://www.sphinx-doc.org/en/stable/theming.html</a></li>
<li><a href="https://pypi.python.org/pypi/sphinx_rtd_theme">https://pypi.python.org/pypi/sphinx_rtd_theme</a></li>
</ul>


<pre><code>sudo pip install sphinx_rtd_theme

sed -i "/html_theme/s/.*/html_theme = 'sphinx_rtd_theme'/" conf.py
</code></pre>

<h2>管理历史文档</h2>

<ul>
<li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/intro.html#id2">不同文档系统的转换</a></li>
<li><a href="https://pypi.python.org/pypi/html2rest">https://pypi.python.org/pypi/html2rest</a></li>
</ul>


<p>先使用 html2rest 把html转成reStructuredText格式。</p>

<pre><code>sudo pip install html2rest

#JSON：原始文档层次结构
  [
  { "id": "a16", "pId": "a", "name": "Administration", "file": "output/AdministrativeDocumentation.html" }, 
  { "id": "a1617", "pId": "a16", "name": "Basic Configuration Guide" },
  { "id": "a161718", "pId": "a1617", "name": "Configuring Deployments", "file": "output/ConfiguringDeployments.html" }
  ]


name=administration
cat $name.json | jq '.[].file' | sed 's/"//g' | while read line ; do cp "$line" $name.origin/  ; done
cd $name.origin
ls | while read f ; do html2rest $f &gt;"../$name.rst/${f%%.*}.rst" ; done
</code></pre>

<p>这仅仅是把html转换成了reStructuredText格式，当然我们还可以做多一些的操作：把文件结构也创建出来。</p>

<p>docs-gen.sh脚本内容如下：</p>

<pre><code>#!/bin/bash

JSON_FILE=~/administration.json

function children(){
local id=$1

local name="$( cat "$JSON_FILE" | jq '.[] | select(.id=="'$id'")' | jq '.name' | sed 's/"//g' )"
echo "id: $id, name: $name"

local filename="$( echo $name | sed 's/[^[:alnum:]]//g' )"

if [ ! -f "$filename.rst" ] ; then
cat &gt; "$filename.rst" &lt;&lt;EOF
$name
======================================

EOF
fi

local nodes="$( cat "$JSON_FILE" | jq '.[] | select(.pId=="'$id'")' )"

if [ "x$nodes" == "x" ] ; then 
  return 1
fi

# if have children, create folder and toc
local foldername="$( echo $name | sed 's/[^[:alnum:]]//g' )"
local names="$( echo "$nodes" | jq ".name" | sed 's/[^[:alnum:]]//g' )"
local ids="$( echo "$nodes" | jq ".id" | sed 's/[^[:alnum:]]//g' )"

if ! grep '.. toctree::' "$foldername.rst" ; then
cat &gt;&gt;"$foldername.rst" &lt;&lt;EOF

Contents:

.. toctree::
   :maxdepth: 3
   :titlesonly:
   :hidden:
   :glob:

$( echo "$names" | sed "s#^#   $foldername/#" ) 

EOF
fi

mkdir -p "$foldername"
pushd "$foldername"

while read cid
do 
  children $cid
done &lt; &lt;(echo "$ids")

popd

}


children a
</code></pre>

<p>然后执行该命令，把目录、目录索引、临时文件创建好：</p>

<pre><code>cd ~/administration
./docs-gen.sh
</code></pre>

<p>然后就是把最开始转换的rst文件拷贝过来：</p>

<pre><code>cd ../administration.rst

ls | while read f ; do 
filename="$(echo $f | sed 's/.rst$//' | sed 's/[^[:alnum:]]//g' ).rst" ; 
find ../administration/ -name "$filename" -exec /bin/cp -f $f {} \;  ;  
done

#再执行一遍docs-gen.sh，把目录的索引再（确认）添加一次文件末尾
cd ../administration
./docs-gen.sh
</code></pre>

<p>完后生成 <code>make html</code> ，直接打开 <strong>_build/html/index.html</strong> 查看下内容。</p>

<p>最后就是根据具体情况，做一些细微的调整了。</p>

<ul>
<li>处理图片，修改 /usr/local/lib/python2.7/dist-packages/html2rest.py</li>
<li>处理文档内互相引用的链接</li>
<li>给标题添加TAG</li>
</ul>


<h2>生成PDF</h2>

<p>除了生成html外，还可以直接编译成PDF，方便携带和查看。（官网是推荐使用latexpdf，但这得安装latex&hellip;）</p>

<ul>
<li><a href="https://www.quora.com/How-to-create-a-PDF-out-of-Sphinx-documentation-tool">https://www.quora.com/How-to-create-a-PDF-out-of-Sphinx-documentation-tool</a></li>
<li>Config value &lsquo;math_number_all&rsquo; already present <a href="https://github.com/sphinx-doc/sphinx/issues/2499">https://github.com/sphinx-doc/sphinx/issues/2499</a></li>
</ul>


<pre><code>[root@ansible workspace]# pip install rst2pdf

[root@ansible workspace]# vi conf.py 
...
#extensions = ['sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.pngmath']
extensions = ['sphinx.ext.doctest', 'sphinx.ext.todo', 'rst2pdf.pdfbuilder']

pdf_documents = [('index', u'Workspace', u'Workspace Doc', u'winse'),]

[root@ansible workspace]# sphinx-build -b pdf . _build/pdf
</code></pre>

<p>或者用 singlehtml 临时代替下也行。</p>

<pre><code>make singlehtml
</code></pre>

<p></p>

<h2>MISC</h2>

<ul>
<li><a href="http://www.sphinx-doc.org/en/latest/markup/inline.html">Inline markup</a></li>
<li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/markup/inline.html">文档引用</a></li>
<li><a href="http://rest-sphinx-memo.readthedocs.io/en/latest/Sphinx.html#sphinx-inline-markup">Sphinx inline markup</a></li>
<li><a href="http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html#tables">表格</a> GOOD!</li>
<li><a href="http://openalea.gforge.inria.fr/doc/openalea/doc/_build/html/source/sphinx/rest_syntax.html#tables">table</a></li>
<li><a href="http://www.tablesgenerator.com/text_tables#">tablesgenerator</a> <a href="https://stackoverflow.com/questions/26609816/some-online-tool-or-automation-plugin-for-sublimetext-for-generating-sphinx-rst">&lt;-</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
</feed>
