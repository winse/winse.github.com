<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: #java | Winse Blog]]></title>
  <link href="http://winse.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://winse.github.io/"/>
  <updated>2024-01-14T00:30:01+08:00</updated>
  <id>http://winse.github.io/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用注解生成代码]]></title>
    <link href="http://winse.github.io/blog/2018/06/10/java-source-annotation-processor/"/>
    <updated>2018-06-10T12:51:39+08:00</updated>
    <id>http://winse.github.io/blog/2018/06/10/java-source-annotation-processor</id>
    <content type="html"><![CDATA[<p>Java里面随处可见annotation（注解），RetentionPolicy 指示了注解使用的情况：</p>

<ul>
<li>SOURCE，比如 @Override, @SuppressWarnings</li>
<li>RUNTIME，最熟悉的莫过于Spring Bean中使用的 @Controller, @Service 一般和反射同时使用。</li>
<li>CLASS</li>
</ul>


<p>而 CLASS 则是用于 compile 编译阶段的注解。一个注解的处理器，以Java代码（或编译过的字节码）作为输入，生成Java文件。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被javac编译。</p>

<p>可以自己实现一些类似groovy语法糖的功能（lombok框架修改bytecode为类生成新方法getter/setter、或者使用生成新的辅助类等）；减少机械的、冗余代码的管理，使得代码更简洁便于阅读。</p>

<h2>代码生成</h2>

<p>先来了解下整个过程，javac 从 ServiceLoader 获取一个 Processor 标注处理类，判断是否为符合条件的标注，再收集类的相关信息，然后使用 Filer 创建新的类。<a href="http://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a> ，<a href="https://liuzhengyang.github.io/2017/10/20/annotation-processing/">java annotation processor</a> 主要涉及到如下三部分：</p>

<ul>
<li>Annotation: @BuilderProperty</li>
<li>Processor: BuilderProcessor</li>
<li><p>Service:</p>

<p>通过google的auto-service来注册服务，最终会在 META-INF/services/ 生成名称为 javax.annotation.processing.Processor 的文件，内容为当前被标注的类名。</p></li>
</ul>


<p>项目的目录结构如下：</p>

<p><img src="/images/blogs/annotation-processor-projects.png" alt="" /></p>

<h3>具体实现：</h3>

<ul>
<li>BuilderProperty 注解</li>
</ul>


<pre><code>package com.github.winse.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface BuilderProperty {
}
</code></pre>

<ul>
<li>BuilderProcessor</li>
</ul>


<pre><code>package com.github.winse.processor;

import com.github.winse.annotation.BuilderProperty;
import com.google.auto.service.AutoService;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ExecutableType;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * @see BuilderProperty
 */
@SupportedAnnotationTypes("com.github.winse.annotation.BuilderProperty")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@AutoService(Processor.class)
public class BuilderProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {
            Set&lt;? extends Element&gt; annotationElements = roundEnv.getElementsAnnotatedWith(annotation);

            Map&lt;Boolean, List&lt;Element&gt;&gt; annotationMethods = annotationElements.stream()
                    .collect(Collectors.partitioningBy(element -&gt; ((ExecutableType) element.asType()).getParameterTypes().size() == 1 &amp;&amp; element.getSimpleName().toString().startsWith("set")));

            List&lt;Element&gt; setters = annotationMethods.get(true);
            List&lt;Element&gt; otherMethods = annotationMethods.get(false);

            otherMethods.forEach(element -&gt; processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "@BuildProperty must be applied to a setXxx method with a single argument", element));

            if (setters.isEmpty()) {
                continue;
            }

            String className = ((TypeElement) setters.get(0).getEnclosingElement()).getQualifiedName().toString();

            Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(
                    setter -&gt; setter.getSimpleName().toString(),
                    setter -&gt; ((ExecutableType) setter.asType()).getParameterTypes().get(0).toString()
            ));

            try {
                writeBuilderType(className, setterMap);
            } catch (IOException e) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
            }
        }
        return true;
    }

    private void writeBuilderType(String className, Map&lt;String, String&gt; setterMap) throws IOException {
        String packageName = null;
        int lastDot = className.lastIndexOf(".");
        if (lastDot &gt; 0) {
            packageName = className.substring(0, lastDot);
        }

        String simpleClassName = className.substring(lastDot + 1);
        String builderClassName = className + "Builder";
        String builderSimpleClassName = builderClassName.substring(lastDot + 1);

        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);
        try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {
            if (packageName != null) {
                out.printf("package %s;\n", packageName);
                out.println();
            }

            out.printf("public class %s {\n", builderSimpleClassName);
            out.println();
            out.printf("  private %s object = new %s();\n", simpleClassName, simpleClassName);
            out.println();
            out.printf("  public %s build() {\n", simpleClassName);
            out.printf("    return object;\n");
            out.printf("  }\n");
            out.println();

            setterMap.entrySet().forEach(setter -&gt; {
                String methodName = setter.getKey();
                String argumentType = setter.getValue();

                out.printf("  public %s %s(%s value){\n", builderSimpleClassName, methodName, argumentType);
                out.printf("    object.%s(value);\n", methodName);
                out.printf("    return this;\n");
                out.printf("  }\n");
                out.println();
            });

            out.printf("}\n");

        }
    }

}
</code></pre>

<h3>测试使用：</h3>

<ul>
<li>build.gradle</li>
</ul>


<p>我使用的是4.7的版本，4.7及以上版本可以直接使用 annotationProcessor 来添加标注处理器。（其他版本可以使用 apt 来处理）</p>

<pre><code>plugins {
    id "net.ltgt.apt" version "0.10"
}

sourceSets.main.java.srcDirs += ['build/generated/source/apt/main']

dependencies {
    compile rootProject
    annotationProcessor project(':compiler')
}
</code></pre>

<ul>
<li>Person</li>
</ul>


<p>这是一个POJO类，BuilderProcessor处理器会根据BuilderProperty注解来生成PersonBuilder类。</p>

<pre><code>package com.github.winse.example;

import com.github.winse.annotation.BuilderProperty;

public class Person {
    private int age;
    private String name;

    @BuilderProperty
    public void setAge(int age) {
        this.age = age;
    }

    @BuilderProperty
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }
}
</code></pre>

<h3>生成代码效果</h3>

<p>在 gradle 面板中选择子项目 <code>:example</code> ，然后选择 Tasks 下的 build 任务进行构建。构建完后在 <code>example/build/generated/source/apt</code> 目录下生成了对应的 Builder 代码。</p>

<pre><code>package com.github.winse.example;

public class PersonBuilder {

  private Person object = new Person();

  public Person build() {
    return object;
  }

  public PersonBuilder setName(java.lang.String value){
    object.setName(value);
    return this;
  }

  public PersonBuilder setAge(int value){
    object.setAge(value);
    return this;
  }

}
</code></pre>

<h2>注解处理器调试</h2>

<p>不会调试说明还没有真正的入门。并且没有调试的情况下，解决异常、错误也是一件异常痛苦的事情。注解处理器生成代码是在编译阶段来生成代码的，所以调试的选项配置添加到 javac 。而 gradle 提供了一种相对简单的方式来进行。</p>

<p>参考</p>

<ul>
<li><a href="https://stackoverflow.com/questions/8587096/how-do-you-debug-java-annotation-processors-using-intellij">how do you debug java annotation processors using intellij?
</a></li>
<li><a href="https://discuss.gradle.org/t/how-do-you-attach-a-debugger-to-gradle-so-that-i-can-debug-it-running-a-task/7526/5">How do you attach a debugger to gradle so that I can debug it running a task?</a></li>
</ul>


<p></p>

<p>具体步骤如下：</p>

<ol>
<li><p>在命令行运行构建</p>

<p>添加调试参数后，gradle 会 <strong>暂停等待远程调试</strong> ，相当于添加了 JVM 调试参数。<a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties">Gradle properties</a></p>

<pre><code>hello-annotation-processor\example&gt;gradle clean build --no-daemon -Dorg.gradle.debug=true
或者
hello-annotation-processor&gt;gradle example:clean example:compileJava --no-daemon -Dorg.gradle.debug=true
</code></pre>

<p>注： &ndash;no-daemon 不加也是可以的，但是运行该次构建后不会停止。</p>

<p><img src="/images/blogs/annotation-processor-debug-s1.png" alt="" /></p></li>
<li><p>远程调试</p>

<p><img src="/images/blogs/annotation-processor-debug-s2.png" alt="" /></p></li>
</ol>


<h3>其他调试配置方式</h3>

<ul>
<li><p>通过环境变量</p>

<pre><code>example&gt;set GRADLE_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005

example&gt;gradle clean build
Listening for transport dt_socket at address: 5005
</code></pre></li>
<li><p>修改 ~/.gradle/gradle.properties</p>

<p>这种方式不推荐，因为它是全局的。</p>

<pre><code>org.gradle.daemon=false
org.gradle.debug=true
</code></pre>

<p>或者</p>

<pre><code>org.gradle.daemon=true
org.gradle.jvmargs=-XX:MaxPermSize=4g -XX:+HeapDumpOnOutOfMemoryError -Xmx4g -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5006

$ gradle --daemon
</code></pre>

<p>Then attach your debugger client to port 5006, set your breakpoint, then run your test.</p>

<p>注：该配置放到项目目录下没用。</p></li>
</ul>


<h2>其他</h2>

<ul>
<li>Gradle参数优化 <a href="https://stackoverflow.com/questions/16775197/building-and-running-app-via-gradle-and-android-studio-is-slower-than-via-eclips/19500539#19500539">Building and running app via Gradle and Android Studio is slower than via Eclipse</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中使用代理-基于Shandowsocks]]></title>
    <link href="http://winse.github.io/blog/2018/01/26/proxy-on-java-via-shandowsocks/"/>
    <updated>2018-01-26T20:50:05+08:00</updated>
    <id>http://winse.github.io/blog/2018/01/26/proxy-on-java-via-shandowsocks</id>
    <content type="html"><![CDATA[<p>在开发过程中，时不时需要要代理一下，来访问我们需要的资源，比方说：DEBUG生产<strong>集群</strong>的应用、还有在Java中翻墙等等。解决了全局的代理能完成我们访问到资源的时刻，又有新的要求，比方说：只有特定的资源走代理等等。</p>

<p>下面把要点简单罗列下，以供参考：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/1432961/how-do-i-make-httpurlconnection-use-a-proxy">https://stackoverflow.com/questions/1432961/how-do-i-make-httpurlconnection-use-a-proxy</a></li>
<li><a href="http://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html">http://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html</a></li>
<li><a href="https://stackoverflow.com/questions/120797/how-do-i-set-the-proxy-to-be-used-by-the-jvm">https://stackoverflow.com/questions/120797/how-do-i-set-the-proxy-to-be-used-by-the-jvm</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html">https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html</a></li>
</ul>


<p>JDK官网基本内容全部都包括了，其他链接作为理解辅助，看看人家的实际需求与具体解决方法。</p>

<h2>Java全应用级代理（全局）</h2>

<ul>
<li>走HTTP</li>
</ul>


<p>Shandowsocks转HTTP，前面Docker翻墙安装Kubernate有弄过，参考：<a href="/blog/2017/02/04/privoxy-http-proxy-for-shadowsocks/">Privoxy</a> 。</p>

<p>也可以直接用Shandowsocks提供的 <code>启用系统代理 -&gt; 系统代理模式 -&gt; 全局模式</code> 来转换，启用HTTP代理功能。（开全局模式，本地会把socks代理转成为一个http的代理）</p>

<pre><code>-Dhttp.proxyHost=127.0.0.1
-Dhttp.proxyPort=7070
-Dhttps.proxyHost=127.0.0.1
-Dhttps.proxyPort=7070
-Dhttp.nonProxyHosts="localhost|127.0.0.1|192.168.*"
</code></pre>

<blockquote><ul>
<li>http.proxyHost: the host name of the proxy server</li>
<li>http.proxyPort: the port number, the default value being 80.</li>
<li>http.nonProxyHosts:a list of hosts that should be reached directly, bypassing the proxy. This is a list of patterns separated by &lsquo;|&rsquo;. The patterns may start or end with a &lsquo;*&rsquo; for wildcards. Any host matching one of these patterns will be reached through a direct connection instead of through a proxy.</li>
</ul>
</blockquote>

<p></p>

<ul>
<li>走Socks</li>
</ul>


<pre><code>-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=7070
</code></pre>

<ul>
<li>使用系统代理</li>
</ul>


<pre><code>-Djava.net.useSystemProxies=true
</code></pre>

<h2>部分/使用时设置（自动切换）</h2>

<ul>
<li>应用内通过 setProperty <strong>临时</strong> 进行设置（这种有缺陷，中间一段时间相当于全局代理了，不推荐）</li>
</ul>


<pre><code>System.setProperty("http.proxyHost", proxyHost);
System.setProperty("http.proxyPort", proxyPort);
System.setProperty("https.proxyHost", proxyHost);
System.setProperty("https.proxyPort", proxyPort);
</code></pre>

<p>用完之后，取消设置：</p>

<pre><code>System.clearProperty("http.proxyHost");
...
</code></pre>

<ul>
<li>请求时指定代理：</li>
</ul>


<pre><code>SocketAddress addr = new InetSocketAddress("webcache.example.com", 8080);
Proxy proxy = new Proxy(Proxy.Type.HTTP, addr);

URL url = new URL("http://java.example.org/");
URLConnection conn = url.openConnection(proxy);
</code></pre>

<ul>
<li>（选择性的）配置哪些访问走代理：ProxySelector</li>
</ul>


<p>任何请求访问网络之前，会被ProxySelector拦截。根据规则获取一个符合的Proxy（或者Proxy.NO_PROXY），然后通过这个代理去访问网络。</p>

<blockquote><p>As you can see, with Java SE 5.0, the developer gains quite a bit of control and flexibility when it comes to proxies. Still, there are situations where one would like to decide which proxy to use dynamically, for instance to do some load balancing between proxies, or depending on the destination, in which case the API described so far would be quite cumbersome. That&rsquo;s where the ProxySelector comes into play.</p>

<p>The best thing about the ProxySelector is that it is plugable! Which means that if you have needs that are not covered by the default one, you can write a replacement for it and plug it in!</p></blockquote>

<p>基本上看JDK官网的内容就好了，非常全。也可以参考下 <a href="http://archive.oreilly.com/pub/a/onjava/excerpt/jvntwkprg_3e/index.html?page=3#javanp3-CHP-7-SECT-4">URLs and URIs, Proxies and Passwords</a></p>

<p>注册自定义的Selector：</p>

<pre><code>public static void main(String[] args) {
    MyProxySelector ps = new MyProxySelector(ProxySelector.getDefault());
    ProxySelector.setDefault(ps);
    // rest of the application
}
</code></pre>

<p>Selector实现：</p>

<pre><code>public class MyProxySelector extends ProxySelector {
    // Keep a reference on the previous default
    ProxySelector defsel = null;

    /*
     * Inner class representing a Proxy and a few extra data
     */
    class InnerProxy {
        Proxy proxy;
        SocketAddress addr;
        // How many times did we fail to reach this proxy?
        int failedCount = 0;

        InnerProxy(InetSocketAddress a) {
            this(a, Proxy.Type.HTTP);
        }

        InnerProxy(InetSocketAddress a, Proxy.Type type) {
            addr = a;
            proxy = new Proxy(type, a);
        }

        SocketAddress address() {
            return addr;
        }

        Proxy toProxy() {
            return proxy;
        }

        int failed() {
            return ++failedCount;
        }
    }

    /*
     * A list of proxies, indexed by their address.
     */
    HashMap&lt;SocketAddress, InnerProxy&gt; proxies = new HashMap&lt;SocketAddress, InnerProxy&gt;();

    MyProxySelector(ProxySelector def) {
        // Save the previous default
        defsel = def;

        // Populate the HashMap (List of proxies)
        InnerProxy i = new InnerProxy(new InetSocketAddress("webcache1.example.com", 8080));
        proxies.put(i.address(), i);
        i = new InnerProxy(new InetSocketAddress("webcache2.example.com", 8080));
        proxies.put(i.address(), i);
        i = new InnerProxy(new InetSocketAddress("webcache3.example.com", 8080));
        proxies.put(i.address(), i);
    }

    /*
     * This is the method that the handlers will call.
     * Returns a List of proxy.
     */
    public java.util.List&lt;Proxy&gt; select(URI uri) {
        // Let's stick to the specs. 
        if (uri == null) {
            throw new IllegalArgumentException("URI can't be null.");
        }

        /* 这里可以指定你自己的规则/配置
         * If it's a http (or https) URL, then we use our own list.
         */
        String protocol = uri.getScheme();
        if ("http".equalsIgnoreCase(protocol) ||
                "https".equalsIgnoreCase(protocol)) {
            ArrayList&lt;Proxy&gt; l = new ArrayList&lt;Proxy&gt;();
            for (InnerProxy p : proxies.values()) {
                l.add(p.toProxy());
            }
            return l;
        }

        /*
         * Not HTTP or HTTPS (could be SOCKS or FTP)
         * defer to the default selector.
         */
        if (defsel != null) {
            return defsel.select(uri);
        } else {
            ArrayList&lt;Proxy&gt; l = new ArrayList&lt;Proxy&gt;();
            l.add(Proxy.NO_PROXY);
            return l;
        }
    }

    /*
     * Method called by the handlers when it failed to connect
     * to one of the proxies returned by select().
     */
    public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
        // Let's stick to the specs again.
        if (uri == null || sa == null || ioe == null) {
            throw new IllegalArgumentException("Arguments can't be null.");
        }

        /*
         * Let's lookup for the proxy 
         */
        InnerProxy p = proxies.get(sa); 
        if (p != null) {
            /*
             * It's one of ours, if it failed more than 3 times
             * let's remove it from the list.
             */
            if (p.failed() &gt;= 3)
                    proxies.remove(sa);
        } else {
            /*
             * Not one of ours, let's delegate to the default.
             */
            if (defsel != null)
              defsel.connectFailed(uri, sa, ioe);
        }
    }
}
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[命令行调用Jenkins2.63打包]]></title>
    <link href="http://winse.github.io/blog/2017/08/31/jenkins-build-via-shell/"/>
    <updated>2017-08-31T01:26:40+08:00</updated>
    <id>http://winse.github.io/blog/2017/08/31/jenkins-build-via-shell</id>
    <content type="html"><![CDATA[<p>Jenkins给集成打包带来了很多的便捷，让不懂开发的同事也能轻松的打包。但是对于开发和运维来说，可能还需要在打包之外做一些事情，以及批量的处理N个打包。</p>

<p>对于研发来说，重复是最难忍受的。Jenkins可以直接通过api来调用查看和处理各种请求。</p>

<p>网络上资料其实挺多的。也有直接一个脚本直接搞定部署的。知其然知其所以然，还是需要自己下功夫理解人家的脚本这样才能更好的用（先不说自己写了）。主要的就是三个步骤：</p>

<ol>
<li>怎么登陆: <a href="https://wiki.jenkins.io/display/JENKINS/Jenkins+Script+Console#JenkinsScriptConsole-Remoteaccess">JenkinsScriptConsole-Remoteaccess</a> .|. <a href="https://wiki.jenkins.io/display/JENKINS/Remote+access+API#RemoteaccessAPI-CSRFProtection">RemoteaccessAPI-CSRFProtection</a></li>
<li>执行build：<a href="http://www.inanzzz.com/index.php/post/jnrg/running-jenkins-build-via-command-line">Running jenkins jobs via command line</a> .|. <a href="https://www.nczonline.net/blog/2015/10/triggering-jenkins-builds-by-url/">Triggering Jenkins builds by URL</a></li>
<li>检查结果：<a href="https://gist.githubusercontent.com/julianchurchill/8780920/raw/ae3ab0c120857b0fe69fe3718d720cb4ef94c4b8/checkJenkins.sh">checkJenkins.sh</a></li>
</ol>


<h2>crumb</h2>

<p>首先来看看crumb是啥</p>

<p>```
[root@iZ9416vn227Z opt]# curl -X POST $JENKINS_PROJ_AUTH_URL/build
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Error 403 No valid crumb was included in the request</title>
</head>
<body><h2>HTTP ERROR 403</h2></p>

<p>Problem accessing /job/helloworld/build. Reason:
<pre>    No valid crumb was included in the request</pre></p>


<hr><a href="http://eclipse.org/jetty">Powered by Jetty:// 9.4.z-SNAPSHOT</a><hr/>


<p></body>
</html></p>

<pre><code>
这里[CSRF](https://wiki.jenkins.io/display/JENKINS/Jenkins+Script+Console#JenkinsScriptConsole-RemoteaccesswithCSRFprotectionenabled) 相当于jenkins做的一个权限控制，有两种方式处理：

方法一：取消控制

* [no valid crumb was included in the request解决](http://www.zhyea.com/2016/10/14/resolve-no-valid-crumb-was-included-in-the-request-error.html) 
* [No valid crumb was included in the request](https://github.com/ghale/gradle-jenkins-plugin/issues/78#issuecomment-215783175)

在菜单 系统管理 –&gt; Configure Global Security 中调整设置: 取消 防止跨站点请求伪造(Prevent Cross Site Request Forgery exploits) 的勾选。 如果还坚持要启用“防止跨站点请求伪造”，就需要先动态获取crumb。

方法二：获取token

* [How to request for Crumb issuer for jenkins](https://stackoverflow.com/questions/16738441/how-to-request-for-crumb-issuer-for-jenkins)
* [Calling a jenkins job with a bash script](http://russellsimpkins.blogspot.jp/2014/10/calling-jenkins-job-with-bash-script.html)
*  https://support.cloudbees.com/hc/en-us/articles/218889337-How-to-build-a-job-using-the-REST-API-and-cURL-

通过URL: crumbIssuer/api/json 获取token的键值，然后把它附加到build请求的HEADER。




## 命令行通过URL请求jenkins进行编译

* [使用shell脚本curl调用jenkins进行构建并判断是否构建成功 ](http://blog.csdn.net/xian312854159/article/details/41118245)
* [Remote access API](https://wiki.jenkins.io/display/JENKINS/Remote+access+API)
* https://wiki.jenkins.io/display/JENKINS/Authenticating+scripted+clients
* https://wiki.jenkins.io/display/JENKINS/Jenkins+Script+Console



</code></pre>

<p>JENKINS_ID=&ldquo;admin:PASSWORD&rdquo;
JENKINS_PROJ_AUTH_URL=<a href="http://$JENKINS_ID@localhost:18080/job/helloworld">http://$JENKINS_ID@localhost:18080/job/helloworld</a>
JENKINS_PROJ_URL=<a href="http://localhost:18080/job/helloworld">http://localhost:18080/job/helloworld</a></p>

<p>curl $JENKINS_PROJ_AUTH_URL/lastBuild/api/json</p>

<h1>Get the current configuration and save it locally</h1>

<p>curl -X GET $JENKINS_PROJ_URL/config.xml</p>

<p>curl &lsquo;<a href="http://">http://</a>&rsquo;$JENKINS_ID'@localhost:18080/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,&ldquo;:&rdquo;,//crumb)&lsquo;
Jenkins-Crumb:a4296173a91d900c11af07d932559fcd</p>

<p>curl -X POST -H &ldquo;Jenkins-Crumb:a4296173a91d900c11af07d932559fcd&rdquo;  $JENKINS_PROJ_AUTH_URL/build</p>

<p>curl -s $JENKINS_PROJ_AUTH_URL/lastBuild/api/json | jq .</p>

<h1>&mdash; TODO &mdash;</h1>

<p>progress（排队中）|pending（构建中），每三秒去重新获取结果进行判断<br/>
while grep -qE &ldquo;In progress|pending&rdquo; build.tmp2;</p>

<p>if grep -qE &ldquo;Success&rdquo; build.tmp2 ;then<br/>
elif grep -qE &ldquo;Unstable&rdquo; build.tmp2 ;then<br/>
elif grep -qE &ldquo;Failed|Aborted&rdquo; build.tmp2 ;then<br/>
echo &ldquo;#Open Link: ${jobPage}${newbuild}/console see details&rdquo;</p>

<p>```</p>

<p>BuildName</p>

<ul>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Build+Name+Setter+Plugin">https://wiki.jenkins.io/display/JENKINS/Build+Name+Setter+Plugin</a></li>
<li><a href="https://stackoverflow.com/questions/42172320/how-to-set-the-jenkins-build-name-based-on-some-conditions">https://stackoverflow.com/questions/42172320/how-to-set-the-jenkins-build-name-based-on-some-conditions</a></li>
<li><a href="https://stackoverflow.com/questions/30111298/how-to-use-build-name-setter-plugin">https://stackoverflow.com/questions/30111298/how-to-use-build-name-setter-plugin</a></li>
</ul>


<p>jenkins的使用案例</p>

<ul>
<li><a href="http://debugtalk.com/post/iOS-Android-Packing-with-Jenkins-details/">http://debugtalk.com/post/iOS-Android-Packing-with-Jenkins-details/</a></li>
</ul>


<h2>参考</h2>

<p>API使用</p>

<ul>
<li><a href="https://gist.githubusercontent.com/julianchurchill/8780920/raw/ae3ab0c120857b0fe69fe3718d720cb4ef94c4b8/checkJenkins.sh">https://gist.githubusercontent.com/julianchurchill/8780920/raw/ae3ab0c120857b0fe69fe3718d720cb4ef94c4b8/checkJenkins.sh</a></li>
<li><a href="https://www.nczonline.net/blog/2015/10/triggering-jenkins-builds-by-url/">Triggering Jenkins builds by URL</a></li>
</ul>


<p>登录/权限问题</p>

<ul>
<li><a href="https://stackoverflow.com/questions/10698419/how-can-a-jenkins-user-authentication-details-be-passed-to-a-script-which-uses">https://stackoverflow.com/questions/10698419/how-can-a-jenkins-user-authentication-details-be-passed-to-a-script-which-uses</a></li>
<li><a href="http://www.scmgalaxy.com/tutorials/ways-to-login-jenkins-using-command-line">http://www.scmgalaxy.com/tutorials/ways-to-login-jenkins-using-command-line</a></li>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Jenkins+Script+Console#JenkinsScriptConsole-Remoteaccess">https://wiki.jenkins.io/display/JENKINS/Jenkins+Script+Console#JenkinsScriptConsole-Remoteaccess</a></li>
<li><a href="http://russellsimpkins.blogspot.jp/2014/10/calling-jenkins-job-with-bash-script.html">Calling a jenkins job with a bash script</a></li>
<li><a href="https://issues.jenkins-ci.org/browse/JENKINS-42200">No valid crumb was included in the request in kubernetes</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[保护/加密JAVA代码]]></title>
    <link href="http://winse.github.io/blog/2017/08/10/java-bytecode-security/"/>
    <updated>2017-08-10T02:10:39+08:00</updated>
    <id>http://winse.github.io/blog/2017/08/10/java-bytecode-security</id>
    <content type="html"><![CDATA[<p>由于Java代码生成的是中间过程字节码，javap以及一些反编译的工具基本能看代码的大概，对于提供给客户的代码需要做一些处理：混淆或者加密。下面分几块把在实际操作过程中参考的内容罗列出来，希望对看到本文并感兴趣的你有所帮助。</p>

<h2>自定义ClassLoader</h2>

<p>混淆+ClassLoader</p>

<ul>
<li><a href="http://www.voidcn.com/blog/zmx729618/article/p-4375840.html">java源代码加密+使用proguard混淆java web项目代码+自定义Classloader</a> 思路不错</li>
</ul>


<p>自定义ClassLoader并用Java实现解密</p>

<ul>
<li><a href="http://www.aspphp.online/bianchen/java/gyjava/201701/112687.html">利用DES加密的算法保護Java源代碼</a> 为啥要加密，以及一般的保护措施（混淆、加密盘、自定义classloader）。实现有点low，用Java写的加密人家调试下就全部请求怎么弄的了。</li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-secureclass/index.html">运用加密技术保护Java源代码</a> Java实现加解密通过自定义classloader。2001年的文章啊，牛逼</li>
<li><a href="http://blog.csdn.net/dianacody/article/details/38585209">Java代码加密与反编译（二）：用加密算法DES修改classLoader实现对.class文件加密</a> 有点实践了上一篇ibm文章的意思。</li>
</ul>


<p>自定义ClassLoader（jvmti）用C++实现解密</p>

<ul>
<li><a href="https://wenku.baidu.com/view/587af93767ec102de2bd892c.html">ClassLoader加密技术改进研究pdf</a> 理论派。classloader的实现用C++写（loadClass用JNI实现），但是还是需要对原有代码进行一定的修改</li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-protectjava/index.html">如何有效的保护 JAVA 程序</a> 这种ClassLoader加密实现有点复杂了，还改java.c的loadClass？2002年的文章啊：解决了 ClassLoader 本身的安全性，其不失为一个比较好安全方案。</li>
<li><a href="http://www.alonemonkey.com/2016/05/25/encrypt-jar-class/]%20%E9%9D%9E%E5%B8%B8%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E4%B8%80%E7%AF%87%E3%80%82%E8%AE%B2%E4%BA%86%E8%87%AA%E5%AE%9A%E4%B9%89classloader%E5%92%8Cjvmti%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E6%BA%90%E7%A0%81%E5%B7%A5%E7%A8%8B[JarEncrypt](https://github.com/AloneMonkey/JarEncrypt">jar包加密保护解决方案</a>，参考。</li>
<li><a href="http://www.codeceo.com/article/jvmti-jni-java.html">通过JVMTI和JNI对JAVA加密</a> 用jvmti来实现加解密，牛逼的一篇文章啊！一步步按他的操作可以实现，还附有源码，参考。</li>
<li><a href="http://www.oracle.com/technetwork/articles/java/jvmti-136367.html">http://www.oracle.com/technetwork/articles/java/jvmti-136367.html</a></li>
</ul>


<p>其他一些</p>

<ul>
<li><a href="http://cjnetwork.iteye.com/blog/851544#bc1819690">java源程序加密解决方案(基于Classloader解密)</a> 本身是一篇很棒的文章，多重加密保障ClassLoader安全。又有大神的回复：java的class加密都可以通过dumpclass来还原出来，囧</li>
<li><a href="http://rednaxelafx.iteye.com/blog/727938">如何dump出一个Java进程里的类对应的Class文件？</a> 大神的sun.jvm.hotspot.tools.jcore.ClassDump文章，只要知道类名就无敌了啊</li>
</ul>


<p></p>

<h2>JNI</h2>

<p>javah</p>

<ul>
<li><a href="http://www.tricoder.net/blog/?p=197">Calling native functions from Java with JNI and Maven</a> maven搭建native的环境，整体的结构很值得学习</li>
<li><a href="http://www.mojohaus.org/maven-native/native-maven-plugin/javah-mojo.html">http://www.mojohaus.org/maven-native/native-maven-plugin/javah-mojo.html</a> maven native插件</li>
<li><a href="https://stackoverflow.com/questions/25138413/java-jni-maven-native-maven-plugin-how-to-set-shared-library-final-name">https://stackoverflow.com/questions/25138413/java-jni-maven-native-maven-plugin-how-to-set-shared-library-final-name</a> 从生成.h到最后打包一条龙，值得学习。</li>
</ul>


<p>环境部署及入门</p>

<ul>
<li><a href="http://blog.csdn.net/ididcan/article/details/6828982">JNI简单实现Java调用C++/C的HelloWorld</a> 搭开发环境的时刻，可以按照步骤一步步来</li>
<li><a href="http://blog.csdn.net/wwj_748/article/details/28136061">JNI_最简单的Java调用C/C++代码</a> 直接VS建空项目，不错。思路清晰。中文入门不二之选！</li>
<li><a href="http://www.javamex.com/tutorials/jni/getting_started.shtml">Getting started with JNI</a> 需要小翻个墙啊，有介绍Additional Include Directories的方式配置java的头文件。</li>
<li><a href="https://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html">Java programming with JNI</a> 了解JNI没有比这篇更好的文章了，即介绍了java调c++，又介绍了c++调用java。</li>
<li><a href="http://tinggo.iteye.com/blog/1185551">VS项目配置详解</a> VS预定义头：DEBUG，RELEASE的一些头可以定义在配置里面。有点像makefile里面决定打什么版本。</li>
</ul>


<p>配jni.h的 附加目录 的时刻，需要选择 配置 和 平台 的配置！！需要对应好！ jni的.h文件需要放到c++的项目下面去，引用外部的好像找不到，有问题。</p>

<p>java与c++类型之间的转换</p>

<ul>
<li><a href="https://stackoverflow.com/questions/8439233/how-to-convert-jbytearray-to-native-char-in-jni">How to convert jbyteArray to native char* in jni?</a></li>
<li><a href="https://stackoverflow.com/questions/12854333/jni-in-c-to-read-file-to-jbytearray">JNI in C++ to read file to jbyteArray</a></li>
</ul>


<p>JNI调用C++的加密算法</p>

<ul>
<li><a href="http://blog.csdn.net/wtbee/article/details/11658017">Java实现DES对称加密算法（附Android下3DES的JNI源码）</a> 有简单介绍DES的只是。中间换成过他的DES的实现，但是感觉怪怪的，有点不太靠谱。后面换成OPENSSL了。</li>
<li><a href="http://www.cnblogs.com/kolin/p/4256614.html">JNI调用c++实现AES加密解密</a> android的，用的应该也是OPENSSL。可以参考过程</li>
</ul>


<h2>OPENSSL</h2>

<ul>
<li><a href="http://www.qmailer.net/archives/183.html">OpenSSL编程-对称加密及DES/3DES简介</a> 简单的介绍</li>
<li><a href="http://blog.csdn.net/duanxingheng/article/details/11655037">OPENSSL库的使用-DES篇</a> 看看算法还可以。算法介绍，有对OPENSSL DES库的介绍和使用</li>
<li><a href="https://www.madboa.com/geek/openssl/">OpenSSL Command-Line</a></li>
<li><a href="http://www.cnblogs.com/gordon0918/p/5317701.html">openssl 对称加密算法enc命令详解</a> 命令行的使用</li>
<li><a href="https://www.slideshare.net/guanzhi/crypto-with-openssl">https://www.slideshare.net/guanzhi/crypto-with-openssl</a></li>
<li><a href="http://www.linuxjournal.com/article/4822">An Introduction to OpenSSL Programming</a> 2001年的太老了，留个纪念。</li>
</ul>


<p>WINDOWS安装/编译安装OPENSSL然后在VS里面应用：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/11383942/how-to-use-openssl-with-visual-studio">https://stackoverflow.com/questions/11383942/how-to-use-openssl-with-visual-studio</a></li>
<li><a href="https://stackoverflow.com/questions/17127824/using-openssl-in-visual-studio-2012">https://stackoverflow.com/questions/17127824/using-openssl-in-visual-studio-2012</a></li>
<li><a href="https://stackoverflow.com/questions/32156336/how-to-include-openssl-in-visual-studio-expres-2012-windows-7-x64">https://stackoverflow.com/questions/32156336/how-to-include-openssl-in-visual-studio-expres-2012-windows-7-x64</a></li>
<li><a href="http://slproweb.com/products/Win32OpenSSL.html">http://slproweb.com/products/Win32OpenSSL.html</a></li>
</ul>


<p>NuGet安装OpenSSL on VS2015-1.0.2版本：（我用的这种方式）</p>

<ul>
<li><a href="https://stackoverflow.com/questions/40431034/openssl-nuget-package-not-installing-in-vs-2015">https://stackoverflow.com/questions/40431034/openssl-nuget-package-not-installing-in-vs-2015</a> VS2015 安装openssl v1.0.2 才有v140的include。 v1.0.2.1安装不了，参考。</li>
</ul>


<p>GCC</p>

<ul>
<li><a href="https://stackoverflow.com/questions/1894013/how-to-use-openssl-in-gcc">How to use OpenSSL in GCC?</a> 加依赖: -L/usr/lib -lssl -lcrypto -o server</li>
</ul>


<p>DES</p>

<ul>
<li><a href="https://my.oschina.net/mawx/blog/85424">https://my.oschina.net/mawx/blog/85424</a> Java DESede用C++ Openssl实现 参考下他的链接</li>
<li><a href="http://www.open-open.com/solution/view/1320502797546">http://www.open-open.com/solution/view/1320502797546</a> Java与C++通过DES、blowfish互相加解密</li>
<li><a href="http://blog.fpmurphy.com/2010/04/openssl-des-api.html#sthash.MA71jwqK.dpbs">http://blog.fpmurphy.com/2010/04/openssl-des-api.html#sthash.MA71jwqK.dpbs</a> OpenSSL DES APIs</li>
</ul>


<p>AES</p>

<ul>
<li><a href="https://www.lovelucy.info/openssl-aes-encryption.html">AES加密和解密——使用openssl编程</a> 参考他的makefile。AES用的是OPENSSL，写的中规中矩</li>
<li><a href="http://www.cnblogs.com/luop/p/4334160.html">密码算法详解——AES</a></li>
<li><a href="http://www.ssdfans.com/?p=238">AES加密算法图解</a> flash动画很赞</li>
<li><a href="http://yuanshuilee.blog.163.com/blog/static/21769727520140942826137/">openssl之aes加密（AES_cbc_encrypt 与 AES_encrypt 的编程案例）</a> 很棒的一篇，参考。</li>
<li><a href="https://blog.poxiao.me/p/advanced-encryption-standard-and-block-cipher-mode/">https://blog.poxiao.me/p/advanced-encryption-standard-and-block-cipher-mode/</a> 高级加密标准AES的工作模式（ECB、CBC、CFB、OFB），还有接口的介绍，非常好的一篇文章</li>
</ul>


<p>AES CBC 相互加解密 Java/PHP/C++ java和c++加解密，互通</p>

<ul>
<li><a href="https://actom.me/blog/aes-cbc-%E7%9B%B8%E4%BA%92%E5%8A%A0%E8%A7%A3%E5%AF%86-javaphpc.html">AES CBC 相互加解密 Java/PHP/C++</a> 非常牛逼的一篇，参考。</li>
<li><a href="http://blog.sina.com.cn/s/blog_48d4cf2d0101eqdf.html">http://blog.sina.com.cn/s/blog_48d4cf2d0101eqdf.html</a> Java和C/C++进行DES/AES密文传输</li>
<li><a href="https://stackoverflow.com/questions/39128103/how-do-i-decrypt-a-java-des-encrypted-message-using-openssl">https://stackoverflow.com/questions/39128103/how-do-i-decrypt-a-java-des-encrypted-message-using-openssl</a></li>
<li><a href="https://stackoverflow.com/questions/9038298/java-desede-encrypt-openssl-equivalent">https://stackoverflow.com/questions/9038298/java-desede-encrypt-openssl-equivalent</a></li>
<li><a href="http://www.cnblogs.com/WonKerr/archive/2009/11/11/DES_C_JAVA.html">http://www.cnblogs.com/WonKerr/archive/2009/11/11/DES_C_JAVA.html</a> DES 算法的 C++ 与 JAVA 互相加解密</li>
<li><a href="http://juliusdavies.ca/commons-ssl/pbe.html">OpenSSL&rsquo;s &ldquo;enc&rdquo; in Java (PBE / Password Based Encryption)</a></li>
<li><a href="http://openssl.6102.n7.nabble.com/Compatibility-between-Java-crypto-and-open-ssl-td13992.html">http://openssl.6102.n7.nabble.com/Compatibility-between-Java-crypto-and-open-ssl-td13992.html</a></li>
<li><a href="https://ruby-china.org/topics/26490">https://ruby-china.org/topics/26490</a></li>
</ul>


<p></p>

<ul>
<li><a href="https://shanetully.com/2012/06/openssl-rsa-aes-and-c/">OpenSSL, RSA, AES and C++</a> 好鬼长复杂没怎么看，搜AES找到了。</li>
</ul>


<h4>OPENSSL MD5： VS + GCC + JAVA + 命令行</h4>

<ul>
<li><a href="http://www.askyb.com/cpp/openssl-md5-hashing-example-in-cpp/">OpenSSL MD5 Hashing Example in C++</a></li>
<li><a href="https://stackoverflow.com/questions/4583967/how-to-encode-md5-sum-into-base64-in-bash">https://stackoverflow.com/questions/4583967/how-to-encode-md5-sum-into-base64-in-bash</a> LINUX命令行</li>
<li><a href="https://askubuntu.com/questions/53846/how-to-get-the-md5-hash-of-a-string-directly-in-the-terminal">https://askubuntu.com/questions/53846/how-to-get-the-md5-hash-of-a-string-directly-in-the-terminal</a> md5sum</li>
<li><a href="https://superuser.com/questions/72765/can-you-use-openssl-to-generate-an-md5-or-sha-hash-on-a-directory-of-files">https://superuser.com/questions/72765/can-you-use-openssl-to-generate-an-md5-or-sha-hash-on-a-directory-of-files</a> 循环算一个目录下文件的MD5</li>
<li><a href="https://www.codeproject.com/Articles/1016357/OpenSSL-Tour-for-Win-Developer#DESCBC">https://www.codeproject.com/Articles/1016357/OpenSSL-Tour-for-Win-Developer#DESCBC</a> OPENSSL各种算法的使用</li>
</ul>


<pre><code># SHA256, used in chef cookbooks
openssl dgst -sha256 path/to/myfile
# MD5
openssl dgst -md5 path/to/myfile
echo -n 'text to be encrypted' | md5sum -
$ echo -n 123456 | md5sum | awk '{print $1}'
$ echo -n Welcome | md5sum

[root@cu2 ~]# gcc -Wall -lcrypto -lssl opensslmd5.cpp -o md5
[root@cu2 ~]# ./md5
md5 digest: 56ab24c15b72a457069c5ea42fcfc640
</code></pre>

<p>makefile</p>

<pre><code>CC=g++
CFLAGS=-Wall -g -O2
LIBS=-lcrypto

all: aes

aes: aes.cc
    $(CC) $(CFLAGS) aes.cc -o $@ $(LIBS)

clean:
    @rm -f aes
</code></pre>

<h4>OPENSSL命令行</h4>

<pre><code>openssl des3 -nosalt -k abc123 -in file.txt -out file.des3 #不加盐，key为abc123来加密
openssl des3 -d -nosalt -in file.des3 -out f.txt -k abc123#解密

默认是-salt，加盐的，如果不加盐，则根据pass生成的key和iv不变，例：

You can get openssl to base64-encode the message by using the -a
stefano:~$ openssl aes-256-cbc -in attack-plan.txt -a

[root@cu2 ~]# echo -n DES | openssl aes-128-cbc -a -salt -k abcdefghijklmnop
[root@cu2 ~]# echo -n DES | openssl aes-128-cbc -k abcdefghijklmnop |  openssl aes-128-cbc -d -k abcdefghijklmnop
</code></pre>

<h2>其他</h2>

<p>SHELL二进制编码：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script">https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script</a> hexdump</li>
</ul>


<pre><code>el@defiant ~ $ printf '%x\n' 26
el@defiant ~ $ echo $((0xAA))
printf -v result1 "%x" "$decimal1"
% xxd -l 16 -p /dev/random
193f6c54814f0576bc27d51ab39081dc
$ echo -n $'\x12\x34' | xxd -p

$ echo -n $'\x12\x34' | hexdump -e '"%x"'

od -vt x1|awk '{$1="";print}'
echo "obase=16; 34" | bc
</code></pre>

<p>c++命令行不直接关闭。。。最后用断点的方式替代了，没找到好的方法！！</p>

<p>文件读写</p>

<ul>
<li><a href="http://blog.csdn.net/lightlater/article/details/6364931">C++读写二进制文件</a></li>
<li><a href="http://blog.csdn.net/guyue6670/article/details/6681037">fopen中w w+ wb区别</a> 人家代码写的是w+，加密class后多了0D。后面问了搞C的同事才知道二进制要用wb，C就是一堆坑啊！</li>
</ul>


<p>g++</p>

<ul>
<li><a href="https://stackoverflow.com/questions/4828228/sprintf-s-was-not-declared-in-this-scope">https://stackoverflow.com/questions/4828228/sprintf-s-was-not-declared-in-this-scope</a> snprintf</li>
</ul>


<p>git</p>

<ul>
<li><a href="https://git-scm.com/docs/git-archive">https://git-scm.com/docs/git-archive</a> GIT打包</li>
</ul>


<h2>重要的参考文章再列一遍</h2>

<ul>
<li><a href="http://blog.csdn.net/wwj_748/article/details/28136061">JNI_最简单的Java调用C/C++代码</a></li>
<li><a href="http://www.alonemonkey.com/2016/05/25/encrypt-jar-class/">jar包加密保护解决方案</a> 源码<a href="https://github.com/AloneMonkey/JarEncrypt">JarEncrypt</a></li>
<li><a href="http://www.codeceo.com/article/jvmti-jni-java.html">通过JVMTI和JNI对JAVA加密</a></li>
<li><a href="https://stackoverflow.com/questions/40431034/openssl-nuget-package-not-installing-in-vs-2015">https://stackoverflow.com/questions/40431034/openssl-nuget-package-not-installing-in-vs-2015</a></li>
<li><a href="https://actom.me/blog/aes-cbc-%E7%9B%B8%E4%BA%92%E5%8A%A0%E8%A7%A3%E5%AF%86-javaphpc.html">AES CBC 相互加解密 Java/PHP/C++</a></li>
</ul>


<p>TODO 编译打包</p>

<ul>
<li><a href="http://www.tricoder.net/blog/?p=197">http://www.tricoder.net/blog/?p=197</a></li>
<li><a href="https://stackoverflow.com/questions/25138413/java-jni-maven-native-maven-plugin-how-to-set-shared-library-final-name">https://stackoverflow.com/questions/25138413/java-jni-maven-native-maven-plugin-how-to-set-shared-library-final-name</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Start Guide]]></title>
    <link href="http://winse.github.io/blog/2017/06/04/jenkins-start-guide/"/>
    <updated>2017-06-04T18:19:23+08:00</updated>
    <id>http://winse.github.io/blog/2017/06/04/jenkins-start-guide</id>
    <content type="html"><![CDATA[<p>从原始的Eclipse右键导出打包，到后面使用maven打包，就单自己一个人使用开发部署是完全没问题的。现在的jenkins是对工具的封装、可视化和自动化，对于团队合作还是有一定的作用的，时时刻刻告诉我们代码是可运行的。</p>

<p>但是如果一个很久前的项目，又需要新加/修改功能，一下子还捡不起来，不放心啊还得验证一把。还有就是，测试有时刻他们自己打包，不会的还的教她们使用工具，人家烦自己也累。</p>

<p>jenkins是一个持续集成的工具，原来也接触过，但是都没用起来，都是搞开发，大部分时刻都能自己搞定。当下由于情况比较特殊，很多代码都直接在生产改，测试环境就不顾上了，但是测试环境不能总是旧代码啊，就想着有个自动化的东西来进行部署。</p>

<p>主要就是完成一个代码自动化部署的工作：自己搭建一个jenkins，从oschina上拉代码，编译后部署到tomcat并重启。</p>

<h2><a href="https://jenkins.io/download/">安装Jenkins</a></h2>

<pre><code>wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war
nohup java -jar jenkins.war --httpPort=8081 &gt;/var/log/jenkins.log 2&gt;&amp;1 &amp; 
</code></pre>

<h2>建立到oschina的无密钥登录</h2>

<p>由于项目是私有的，通过https需要输入密码，还是git方式无密钥登录方式便捷一些。本地linux执行ssh-keygen，然后把 id_rsa.pub 的内容拷贝到项目的公钥处进行配置。可以参考文档： <a href="http://git.mydoc.io/?t=154712">http://git.mydoc.io/?t=154712</a>。</p>

<p>也可以结合 本地ssh-agent 和 ssh-forward 来弄。</p>

<h2>配置项目</h2>

<p>第一次登录需要进行一些配置，默认创建的admin密码会保存在 ~/.jenkins/secrets/initialAdminPassword 。（在初始化页面创建新用户报错，也不知道啥原因。登录后再建吧）</p>

<p>新版本的按照默认安装插件还不够，需要再添加一些。登录成功后，添加如下插件：</p>

<ul>
<li>Deploy to container Plugin  把war发布到容器tomcat&hellip;</li>
<li>Nexus Artifact Uploader  上传jar到私服</li>
<li><p>Maven Integration plugin 集成maven</p></li>
<li><p>ThinBackup 备份也是有必要的，用的越久越是必要！！</p></li>
</ul>


<p>配置maven：</p>

<p>自己下载个maven解压后，在jenkins - Global Tool Configuration上面配置maven地址即可（把 自动安装 的勾去掉就可以填地址了）</p>

<p>然后配置JOB：</p>

<ul>
<li>构建一个maven项目：填任务的名称，然后点击左下角的OK</li>
<li>源码管理git: 填写地址，然后新增Credentials - SSH Username with private key - From the Jenkins master ~/.ssh 起一个容易区分的名字</li>
<li>构建触发器： Build periodically - 0 0 * * * 每天一次</li>
<li>Build：web/pom.xml ; clean package -Papp,dist -DskipTests 就是mvn命令的一串参数</li>
<li>Post Steps: Run only if build succeeds - Execute Shell</li>
</ul>


<pre><code>/opt/apache-tomcat-8.0.26/bin/shutdown.sh ; sleep 1 
rm -rf /opt/apache-tomcat-8.0.26/webapps/app.war 
cp $WORKSPACE/web/app/target/app.war /opt/apache-tomcat-8.0.26/webapps 
cd /opt/apache-tomcat-8.0.26/webapps ; ./deploy.sh 
BUILD_ID=dontKillMe nohup /opt/apache-tomcat-8.0.26/bin/startup.sh &amp; 
sleep 3
</code></pre>

<p>注意：这里的BUILD_ID挺有意思的！！！</p>

<p>也可以配置 <strong>构建后操作</strong> 把包发布到tomcat manager（呵呵，无奈原始包webapps下的都被我删了)，就用脚本弄了。</p>

<h2>构建</h2>

<p>完成上面的操作后，就可以执行跑一次看看效果了。其他的还有很多功能：权限等。</p>

<h2>多节点(集群)</h2>

<p>如果只有一台jenkins的时刻，远程发布项目一般都scp或者使用tomcat-manager进行处理，如果把部署的机器作为jenkins node的话，就可以把部署的任务放到该节点本地跑，就不需要考虑远程部署的问题了。</p>

<p>配置节点： <a href="http://blog.csdn.net/e295166319/article/details/54134487">windows</a></p>

<pre><code>    用法  : 只允许运行绑定到这台机器的Job
  启动方法 ： Launch slave agents via SSH（在主机配置无密钥登录，填用户、Private key：From the Jenkins master ~/.ssh）
</code></pre>

<p>配置好后，在界面点击 <code>Launch agent</code>，会把agent拷贝到机器并启动agent。</p>

<p>然后任务的话，配置 <strong> Restrict where this project can be run </strong> 。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.cnblogs.com/gao241/archive/2013/03/20/2971416.html">Jenkins配置基于角色的项目权限管理</a></li>
<li><a href="http://www.cnblogs.com/zz0412/p/jenkins_jj_14.html">Jenkins进阶系列之——14配置Jenkins用户和权限</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Spawning+processes+from+build">https://wiki.jenkins-ci.org/display/JENKINS/Spawning+processes+from+build</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jenkins/">https://www.ibm.com/developerworks/cn/java/j-lo-jenkins/</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
</feed>
