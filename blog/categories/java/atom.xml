<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Winse Blog]]></title>
  <link href="http://winse.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://winse.github.io/"/>
  <updated>2022-03-20T20:55:18+08:00</updated>
  <id>http://winse.github.io/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[编译JCEF - Win64]]></title>
    <link href="http://winse.github.io/blog/2018/10/20/jcef-build-on-win64/"/>
    <updated>2018-10-20T10:47:59+08:00</updated>
    <id>http://winse.github.io/blog/2018/10/20/jcef-build-on-win64</id>
    <content type="html"><![CDATA[<h2>参考</h2>

<ul>
<li><a href="https://bitbucket.org/chromiumembedded/java-cef/wiki/BranchesAndBuilding">https://bitbucket.org/chromiumembedded/java-cef/wiki/BranchesAndBuilding</a></li>
<li><a href="https://bitbucket.org/Johness/java-cef/wiki/%E7%BC%96%E8%AF%91V49%E4%B8%BAWindows%E5%B9%B3%E5%8F%B0">编译V49为Windows平台</a> gif图片，过程很清晰。就是有点旧！</li>
<li><a href="https://my.oschina.net/penngo/blog/1538071">https://my.oschina.net/penngo/blog/1538071</a> 先下载 chromium-clang-format，最后创建项目的目录结构和添加DLL库路径</li>
<li><a href="http://wzdark.github.io/personalInfo/2015/12/02/jcef.html">http://wzdark.github.io/personalInfo/2015/12/02/jcef.html</a></li>
<li><a href="https://medium.com/@daniel.bischoff/integrating-chromium-as-a-web-renderer-in-a-java-application-with-jcef-72f67a677db6">https://medium.com/@daniel.bischoff/integrating-chromium-as-a-web-renderer-in-a-java-application-with-jcef-72f67a677db6</a> 创建项目，以及一些参数</li>
</ul>


<h2>简单过程摘录</h2>

<p>注意点：</p>

<ol>
<li>依赖：git/python2.7/java8/cmake3/visual studio 2017（这是我编译的环境，具体的版本要求请查看官网文档）</li>
<li>需要用git下载源码</li>
<li>先把 <a href="https://storage.googleapis.com/chromium-clang-format/6ddedd571c56b8c184f30a3c1fc36984e8c10ccd">chromium-clang-format</a> 下载放到 tools 目录下面</li>
</ol>


<p>步骤：</p>

<ol>
<li>cmake-3.12.3-win64-x64.zip，配置环境变量PATH</li>
<li>安装版python-2.7.15.amd64.msi、同时配置把python.exe加入到PATH</li>
<li>把 PortableGit 加入PATH： <code>set PATH=D:\PortableGit\bin;%PATH%</code></li>
<li>使用 VS 的命令行运行</li>
<li>命令：</li>
</ol>


<pre><code>F:\wv&gt;git clone https://bitbucket.org/chromiumembedded/java-cef.git src

F:\wv\src&gt;mkdir jcef_build &amp;&amp; cd jcef_build

F:\wv\src\jcef_build&gt;cmake -G "Visual Studio 14 Win64" ..
用vs编译本地代码：
# Open jcef.sln in Visual Studio
# - Select Build &gt; Configuration Manager and change the "Active solution configuration" to "Release"
# - Select Build &gt; Build Solution.

cd ..\tools
compile.bat win64

run.bat win64 Release detailed

F:\wv\src\tools&gt;make_distrib.bat win64
</code></pre>

<p>生成的运行包放在 binary_distrib 目录下。查看下 <code>binary_distrib/win64/run.bat</code> 了解运行配置，同时参考上面文章中提到的项目的创建方法。</p>

<pre><code>java -cp "./bin;./bin/*" -Djava.library.path=./bin/lib/win64 tests.detailed.MainFrame
</code></pre>

<p>过程截图：</p>

<p><img src="/images/blogs/jcef/vs-cmd.png" alt="" /></p>

<pre><code>**********************************************************************
** Visual Studio 2017 Developer Command Prompt v15.7.4
** Copyright (c) 2017 Microsoft Corporation
**********************************************************************
[vcvarsall.bat] Environment initialized for: 'x64'

C:\Program Files (x86)\Microsoft Visual Studio\2017\Community&gt;F:

F:\&gt;cd wv
F:\wv&gt;set PATH=D:\PortableGit\bin;%PATH%
F:\wv&gt;git clone https://bitbucket.org/chromiumembedded/java-cef.git src

F:\wv\src&gt;mkdir jcef_build &amp;&amp; cd jcef_build

F:\wv\src\jcef_build&gt;cmake -G "Visual Studio 14 Win64" ..
-- Selecting Windows SDK version  to target Windows 10.0.16299.
-- The C compiler identification is MSVC 19.0.24234.1
-- The CXX compiler identification is MSVC 19.0.24234.1
-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/x86_amd64/cl.exe
-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/x86_amd64/cl.exe -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/x86_amd64/cl.exe
-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/x86_amd64/cl.exe -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Downloading F:/wv/src/third_party/cef/cef_binary_3.3497.1831.g461fa1f_windows64.tar.bz2.sha1...
-- Downloading F:/wv/src/third_party/cef/cef_binary_3.3497.1831.g461fa1f_windows64.tar.bz2...
-- [download 0% complete]
-- [download 1% complete]
。。。
-- [download 98% complete]
-- [download 99% complete]
-- [download 100% complete]
-- Extracting F:/wv/src/third_party/cef/cef_binary_3.3497.1831.g461fa1f_windows64.tar.bz2...
CMake Warning (dev) at CMakeLists.txt:153 (find_package):
  Policy CMP0074 is not set: find_package uses &lt;PackageName&gt;_ROOT variables.
  Run "cmake --help-policy CMP0074" for policy details.  Use the cmake_policy
  command to set the policy and suppress this warning.

  CMake variable CEF_ROOT is set to:

    F:/wv/src/third_party/cef/cef_binary_3.3497.1831.g461fa1f_windows64

  For compatibility, CMake is ignoring the variable.
This warning is for project developers.  Use -Wno-dev to suppress it.

-- Found PythonInterp: C:/Python27/python.exe (found version "2.7.15")
-- Found JNI: C:/Java/jdk/lib/jawt.lib (Required is at least version "1.7")
-- Generating native/jcef_version.h file...
File native/jcef_version.h updated.
-- Downloading clang-format from Google Storage...
0&gt; Failed to fetch file gs://chromium-clang-format/6ddedd571c56b8c184f30a3c1fc36984e8c10ccd for tools/buildtools/win/clang-format.exe, skipping. [Err: F:\wv\src\tools\buildtools\external_bin\gsutil\gsutil_4.15\gsutil\third_party\boto\boto\pyami\config.py:71: UserWarning: Unable to load AWS_CREDENTIAL_FILE ()
  warnings.warn('Unable to load AWS_CREDENTIAL_FILE (%s)' % full_path)
Failure: Unable to find the server at www.googleapis.com.
]
Downloading 1 files took 3153.963000 second(s)
Failed to fetch file gs://chromium-clang-format/6ddedd571c56b8c184f30a3c1fc36984e8c10ccd for tools/buildtools/win/clang-format.exe. [Err: F:\wv\src\tools\buildtools\external_bin\gsutil\gsutil_4.15\gsutil\third_party\boto\boto\pyami\config.py:71: UserWarning: Unable to load AWS_CREDENTIAL_FILE ()
  warnings.warn('Unable to load AWS_CREDENTIAL_FILE (%s)' % full_path)
Failure: Unable to find the server at www.googleapis.com.
]
CMake Error at CMakeLists.txt:265 (message):
  Execution failed with unexpected result: 1


-- Configuring incomplete, errors occurred!
See also "F:/wv/src/jcef_build/CMakeFiles/CMakeOutput.log".

&lt;&lt;== https://my.oschina.net/penngo/blog/1538071
&lt;&lt;&lt;&lt;----https://storage.googleapis.com/chromium-clang-format/6ddedd571c56b8c184f30a3c1fc36984e8c10ccd
~~~~~~

F:\wv\src\jcef_build&gt;cmake -G "Visual Studio 14 Win64" ..
-- Selecting Windows SDK version  to target Windows 10.0.16299.
CMake Warning (dev) at CMakeLists.txt:153 (find_package):
  Policy CMP0074 is not set: find_package uses &lt;PackageName&gt;_ROOT variables.
  Run "cmake --help-policy CMP0074" for policy details.  Use the cmake_policy
  command to set the policy and suppress this warning.

  CMake variable CEF_ROOT is set to:

    F:/wv/src/third_party/cef/cef_binary_3.3497.1831.g461fa1f_windows64

  For compatibility, CMake is ignoring the variable.
This warning is for project developers.  Use -Wno-dev to suppress it.

-- Generating native/jcef_version.h file...
File native/jcef_version.h is already up to date.
-- Downloading clang-format from Google Storage...
0&gt; File tools/buildtools/win/clang-format.exe exists and SHA1 matches. Skipping.
Success!
Downloading 1 files took 0.006000 second(s)
-- *** CEF CONFIGURATION SETTINGS ***
-- Generator:                    Visual Studio 14 2015 Win64
-- Platform:                     Windows
-- Project architecture:         x86_64
-- Binary distribution root:     F:/wv/src/third_party/cef/cef_binary_3.3497.1831.g461fa1f_windows64
-- CEF Windows sandbox:          ON
-- Visual Studio ATL support:    ON
-- Standard libraries:           comctl32.lib;rpcrt4.lib;shlwapi.lib;ws2_32.lib;dbghelp.lib;psapi.lib;version.lib;winmm.lib
-- Compile defines:              __STDC_CONSTANT_MACROS;__STDC_FORMAT_MACROS;WIN32;_WIN32;_WINDOWS;UNICODE;_UNICODE;WINVER=0x0601;_WIN32_WINNT=0x601;NOMINMAX;WIN32_LEAN_AND_MEAN;_HAS_EXCEPTIONS=0;PSAPI_VERSION=1;CEF_USE_SANDBOX;CEF_USE_ATL
-- Compile defines (Debug):
-- Compile defines (Release):    NDEBUG;_NDEBUG
-- C compile flags:              /MP;/Gy;/GR-;/W4;/WX;/wd4100;/wd4127;/wd4244;/wd4481;/wd4512;/wd4701;/wd4702;/wd4996;/Zi
-- C compile flags (Debug):      /MTd;/RTC1;/Od
-- C compile flags (Release):    /MT;/O2;/Ob2;/GF
-- C++ compile flags:            /MP;/Gy;/GR-;/W4;/WX;/wd4100;/wd4127;/wd4244;/wd4481;/wd4512;/wd4701;/wd4702;/wd4996;/Zi
-- C++ compile flags (Debug):    /MTd;/RTC1;/Od
-- C++ compile flags (Release):  /MT;/O2;/Ob2;/GF
-- Exe link flags:                /MANIFEST:NO;/LARGEADDRESSAWARE
-- Exe link flags (Debug):       /DEBUG
-- Exe link flags (Release):
-- Shared link flags:
-- Shared link flags (Debug):    /DEBUG
-- Shared link flags (Release):
-- CEF Binary files:             chrome_elf.dll;d3dcompiler_43.dll;d3dcompiler_47.dll;libcef.dll;libEGL.dll;libGLESv2.dll;natives_blob.bin;snapshot_blob.bin;v8_context_snapshot.bin;swiftshader
-- CEF Resource files:           cef.pak;cef_100_percent.pak;cef_200_percent.pak;cef_extensions.pak;devtools_resources.pak;icudtl.dat;locales
-- *** JCEF CONFIGURATION SETTINGS ***
-- Python executable:            C:/Python27/python.exe
-- Java directory:               C:/Java/jdk
-- JNI libraries:                C:/Java/jdk/lib/jawt.lib;C:/Java/jdk/lib/jvm.lib
-- JNI include directories:      C:/Java/jdk/include;C:/Java/jdk/include/win32;C:/Java/jdk/include
-- Configuring done
-- Generating done
-- Build files have been written to: F:/wv/src/jcef_build

F:\wv\src\jcef_build&gt;
</code></pre>

<p><img src="/images/blogs/jcef/vs2017.png" alt="" /></p>

<p><img src="/images/blogs/jcef/compile.png" alt="" /></p>

<p><img src="/images/blogs/jcef/run.png" alt="" /></p>

<p><img src="/images/blogs/jcef/run-windows.png" alt="" /></p>

<pre><code>F:\wv\src\tools&gt;make_distrib.bat win64
正在加载程序包org.cef.browser的源文件...
正在加载程序包org.cef.browser.mac的源文件...
正在加载程序包org.cef.callback的源文件...
正在加载程序包org.cef的源文件...
正在加载程序包org.cef.handler的源文件...
正在加载程序包org.cef.misc的源文件...
正在加载程序包org.cef.network的源文件...
正在构造 Javadoc 信息...
.\org\cef\browser\CefRenderer.java:11: 错误: 程序包com.jogamp.opengl不存在
import com.jogamp.opengl.GL2;
                        ^
.\org\cef\browser\CefRenderer.java:15: 错误: 找不到符号
    private GL2 initialized_context_ = null;
            ^
  符号:   类 GL2
  位置: 类 CefRenderer
.\org\cef\browser\CefRenderer.java:34: 错误: 找不到符号
    protected void initialize(GL2 gl2) {
                              ^
  符号:   类 GL2
  位置: 类 CefRenderer
.\org\cef\browser\CefRenderer.java:64: 错误: 找不到符号
    protected void cleanup(GL2 gl2) {
                           ^
  符号:   类 GL2
  位置: 类 CefRenderer
.\org\cef\browser\CefRenderer.java:69: 错误: 找不到符号
    protected void render(GL2 gl2) {
                          ^
  符号:   类 GL2
  位置: 类 CefRenderer
.\org\cef\browser\CefRenderer.java:161: 错误: 找不到符号
    protected void onPaint(GL2 gl2, boolean popup, Rectangle[] dirtyRects, ByteBuffer buffer,
                           ^
  符号:   类 GL2
  位置: 类 CefRenderer
.\org\cef\browser\CefBrowserOsr.java:23: 错误: 程序包com.jogamp.nativewindow不存在
import com.jogamp.nativewindow.NativeSurface;
                              ^
.\org\cef\browser\CefBrowserOsr.java:24: 错误: 程序包com.jogamp.opengl.awt不存在
import com.jogamp.opengl.awt.GLCanvas;
                            ^
.\org\cef\browser\CefBrowserOsr.java:25: 错误: 程序包com.jogamp.opengl不存在
import com.jogamp.opengl.GLAutoDrawable;
                        ^
.\org\cef\browser\CefBrowserOsr.java:26: 错误: 程序包com.jogamp.opengl不存在
import com.jogamp.opengl.GLEventListener;
                        ^
.\org\cef\browser\CefBrowserOsr.java:27: 错误: 程序包com.jogamp.opengl不存在
import com.jogamp.opengl.GLProfile;
                        ^
.\org\cef\browser\CefBrowserOsr.java:28: 错误: 程序包com.jogamp.opengl不存在
import com.jogamp.opengl.GLCapabilities;
                        ^
.\org\cef\browser\CefBrowserOsr.java:44: 错误: 找不到符号
    private GLCanvas canvas_;
            ^
  符号:   类 GLCanvas
  位置: 类 CefBrowserOsr
.\org\cef\browser\mac\CefBrowserWindowMac.java:9: 错误: 程序包sun.lwawt不存在
import sun.lwawt.LWComponentPeer;
                ^
.\org\cef\browser\mac\CefBrowserWindowMac.java:10: 错误: 程序包sun.lwawt不存在
import sun.lwawt.PlatformWindow;
                ^
.\org\cef\browser\mac\CefBrowserWindowMac.java:11: 错误: 程序包sun.lwawt.macosx不存在
import sun.lwawt.macosx.CFRetainedResource;
                       ^
.\org\cef\browser\mac\CefBrowserWindowMac.java:12: 错误: 程序包sun.lwawt.macosx不存在
import sun.lwawt.macosx.CPlatformWindow;
                       ^
标准 Doclet 版本 1.8.0_181
正在构建所有程序包和类的树...
正在生成..\out\docs\org\cef\browser\CefBrowser.html...
正在生成..\out\docs\org\cef\browser\CefBrowserFactory.html...
正在生成..\out\docs\org\cef\browser\CefBrowserWindow.html...
正在生成..\out\docs\org\cef\browser\CefFrame.html...
正在生成..\out\docs\org\cef\browser\CefMessageRouter.html...
.\org\cef\browser\CefMessageRouter.java:185: 警告 - @return 标记没有参数。
.\org\cef\browser\CefMessageRouter.java:185: 警告 - @param argument "config" 不是参数名称。
正在生成..\out\docs\org\cef\browser\CefMessageRouter.CefMessageRouterConfig.html...
正在生成..\out\docs\org\cef\browser\CefRequestContext.html...
。。。
正在生成..\out\docs\constant-values.html...
正在构建所有程序包和类的索引...
正在生成..\out\docs\overview-tree.html...
正在生成..\out\docs\index-all.html...
正在构建所有类的索引...
正在生成..\out\docs\allclasses-frame.html...
正在生成..\out\docs\allclasses-noframe.html...
正在生成..\out\docs\index.html...
正在生成..\out\docs\overview-summary.html...
正在生成..\out\docs\help-doc.html...
29 个警告
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
F:\wv\src\java\tests\detailed\BrowserFrame.java -&gt; F:\wv\src\binary_distrib\win64\bin\tests\detailed\BrowserFrame.java
F:\wv\src\java\tests\detailed\MainFrame.java -&gt; F:\wv\src\binary_distrib\win64\bin\tests\detailed\MainFrame.java
。。。
F:\wv\src\java\tests\detailed\ui\StatusPanel.java -&gt; F:\wv\src\binary_distrib\win64\bin\tests\detailed\ui\StatusPanel.java
F:\wv\src\java\tests\simple\MainFrame.java -&gt; F:\wv\src\binary_distrib\win64\bin\tests\simple\MainFrame.java
复制了 34 个文件
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
系统找不到指定的文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
已复制         1 个文件。
F:\wv\src\jcef_build\native\Release\cef.pak -&gt; F:\wv\src\binary_distrib\win64\bin\lib\win64\cef.pak
F:\wv\src\jcef_build\native\Release\cef_100_percent.pak -&gt; F:\wv\src\binary_distrib\win64\bin\lib\win64\cef_100_percent.pak
。。。
F:\wv\src\jcef_build\native\Release\locales\zh-CN.pak -&gt; F:\wv\src\binary_distrib\win64\bin\lib\win64\locales\zh-CN.pak
F:\wv\src\jcef_build\native\Release\locales\zh-TW.pak -&gt; F:\wv\src\binary_distrib\win64\bin\lib\win64\locales\zh-TW.pak
复制了 58 个文件
F:\wv\src\jcef_build\native\Release\swiftshader\libEGL.dll -&gt; F:\wv\src\binary_distrib\win64\bin\lib\win64\swiftshader\libEGL.dll
F:\wv\src\jcef_build\native\Release\swiftshader\libGLESv2.dll -&gt; F:\wv\src\binary_distrib\win64\bin\lib\win64\swiftshader\libGLESv2.dll
复制了 2 个文件
F:\wv\src\out\docs\allclasses-frame.html -&gt; F:\wv\src\binary_distrib\win64\docs\allclasses-frame.html
F:\wv\src\out\docs\allclasses-noframe.html -&gt; F:\wv\src\binary_distrib\win64\docs\allclasses-noframe.html
。。。
F:\wv\src\out\docs\org\cef\network\package-summary.html -&gt; F:\wv\src\binary_distrib\win64\docs\org\cef\network\package-summary.html
F:\wv\src\out\docs\org\cef\network\package-tree.html -&gt; F:\wv\src\binary_distrib\win64\docs\org\cef\network\package-tree.html
复制了 151 个文件
Creating README.TXT file.
已复制         1 个文件。
F:\wv\src\third_party\jogamp\gluegen.LICENSE.txt -&gt; F:\wv\src\binary_distrib\win64\gluegen.LICENSE.txt
F:\wv\src\third_party\jogamp\jogl.LICENSE.txt -&gt; F:\wv\src\binary_distrib\win64\jogl.LICENSE.txt
复制了 2 个文件
F:\wv\src\tools\distrib\win64\compile.bat -&gt; F:\wv\src\binary_distrib\win64\compile.bat
F:\wv\src\tools\distrib\win64\run.bat -&gt; F:\wv\src\binary_distrib\win64\run.bat
复制了 2 个文件

F:\wv\src\tools&gt;
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用注解生成代码]]></title>
    <link href="http://winse.github.io/blog/2018/06/10/java-source-annotation-processor/"/>
    <updated>2018-06-10T12:51:39+08:00</updated>
    <id>http://winse.github.io/blog/2018/06/10/java-source-annotation-processor</id>
    <content type="html"><![CDATA[<p>Java里面随处可见annotation（注解），RetentionPolicy 指示了注解使用的情况：</p>

<ul>
<li>SOURCE，比如 @Override, @SuppressWarnings</li>
<li>RUNTIME，最熟悉的莫过于Spring Bean中使用的 @Controller, @Service 一般和反射同时使用。</li>
<li>CLASS</li>
</ul>


<p>而 CLASS 则是用于 compile 编译阶段的注解。一个注解的处理器，以Java代码（或编译过的字节码）作为输入，生成Java文件。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被javac编译。</p>

<p>可以自己实现一些类似groovy语法糖的功能（lombok框架修改bytecode为类生成新方法getter/setter、或者使用生成新的辅助类等）；减少机械的、冗余代码的管理，使得代码更简洁便于阅读。</p>

<h2>代码生成</h2>

<p>先来了解下整个过程，javac 从 ServiceLoader 获取一个 Processor 标注处理类，判断是否为符合条件的标注，再收集类的相关信息，然后使用 Filer 创建新的类。<a href="http://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a> ，<a href="https://liuzhengyang.github.io/2017/10/20/annotation-processing/">java annotation processor</a> 主要涉及到如下三部分：</p>

<ul>
<li>Annotation: @BuilderProperty</li>
<li>Processor: BuilderProcessor</li>
<li><p>Service:</p>

<p>通过google的auto-service来注册服务，最终会在 META-INF/services/ 生成名称为 javax.annotation.processing.Processor 的文件，内容为当前被标注的类名。</p></li>
</ul>


<p>项目的目录结构如下：</p>

<p><img src="/images/blogs/annotation-processor-projects.png" alt="" /></p>

<h3>具体实现：</h3>

<ul>
<li>BuilderProperty 注解</li>
</ul>


<pre><code>package com.github.winse.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface BuilderProperty {
}
</code></pre>

<ul>
<li>BuilderProcessor</li>
</ul>


<pre><code>package com.github.winse.processor;

import com.github.winse.annotation.BuilderProperty;
import com.google.auto.service.AutoService;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ExecutableType;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * @see BuilderProperty
 */
@SupportedAnnotationTypes("com.github.winse.annotation.BuilderProperty")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@AutoService(Processor.class)
public class BuilderProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {
            Set&lt;? extends Element&gt; annotationElements = roundEnv.getElementsAnnotatedWith(annotation);

            Map&lt;Boolean, List&lt;Element&gt;&gt; annotationMethods = annotationElements.stream()
                    .collect(Collectors.partitioningBy(element -&gt; ((ExecutableType) element.asType()).getParameterTypes().size() == 1 &amp;&amp; element.getSimpleName().toString().startsWith("set")));

            List&lt;Element&gt; setters = annotationMethods.get(true);
            List&lt;Element&gt; otherMethods = annotationMethods.get(false);

            otherMethods.forEach(element -&gt; processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "@BuildProperty must be applied to a setXxx method with a single argument", element));

            if (setters.isEmpty()) {
                continue;
            }

            String className = ((TypeElement) setters.get(0).getEnclosingElement()).getQualifiedName().toString();

            Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(
                    setter -&gt; setter.getSimpleName().toString(),
                    setter -&gt; ((ExecutableType) setter.asType()).getParameterTypes().get(0).toString()
            ));

            try {
                writeBuilderType(className, setterMap);
            } catch (IOException e) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
            }
        }
        return true;
    }

    private void writeBuilderType(String className, Map&lt;String, String&gt; setterMap) throws IOException {
        String packageName = null;
        int lastDot = className.lastIndexOf(".");
        if (lastDot &gt; 0) {
            packageName = className.substring(0, lastDot);
        }

        String simpleClassName = className.substring(lastDot + 1);
        String builderClassName = className + "Builder";
        String builderSimpleClassName = builderClassName.substring(lastDot + 1);

        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);
        try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {
            if (packageName != null) {
                out.printf("package %s;\n", packageName);
                out.println();
            }

            out.printf("public class %s {\n", builderSimpleClassName);
            out.println();
            out.printf("  private %s object = new %s();\n", simpleClassName, simpleClassName);
            out.println();
            out.printf("  public %s build() {\n", simpleClassName);
            out.printf("    return object;\n");
            out.printf("  }\n");
            out.println();

            setterMap.entrySet().forEach(setter -&gt; {
                String methodName = setter.getKey();
                String argumentType = setter.getValue();

                out.printf("  public %s %s(%s value){\n", builderSimpleClassName, methodName, argumentType);
                out.printf("    object.%s(value);\n", methodName);
                out.printf("    return this;\n");
                out.printf("  }\n");
                out.println();
            });

            out.printf("}\n");

        }
    }

}
</code></pre>

<h3>测试使用：</h3>

<ul>
<li>build.gradle</li>
</ul>


<p>我使用的是4.7的版本，4.7及以上版本可以直接使用 annotationProcessor 来添加标注处理器。（其他版本可以使用 apt 来处理）</p>

<pre><code>plugins {
    id "net.ltgt.apt" version "0.10"
}

sourceSets.main.java.srcDirs += ['build/generated/source/apt/main']

dependencies {
    compile rootProject
    annotationProcessor project(':compiler')
}
</code></pre>

<ul>
<li>Person</li>
</ul>


<p>这是一个POJO类，BuilderProcessor处理器会根据BuilderProperty注解来生成PersonBuilder类。</p>

<pre><code>package com.github.winse.example;

import com.github.winse.annotation.BuilderProperty;

public class Person {
    private int age;
    private String name;

    @BuilderProperty
    public void setAge(int age) {
        this.age = age;
    }

    @BuilderProperty
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }
}
</code></pre>

<h3>生成代码效果</h3>

<p>在 gradle 面板中选择子项目 <code>:example</code> ，然后选择 Tasks 下的 build 任务进行构建。构建完后在 <code>example/build/generated/source/apt</code> 目录下生成了对应的 Builder 代码。</p>

<pre><code>package com.github.winse.example;

public class PersonBuilder {

  private Person object = new Person();

  public Person build() {
    return object;
  }

  public PersonBuilder setName(java.lang.String value){
    object.setName(value);
    return this;
  }

  public PersonBuilder setAge(int value){
    object.setAge(value);
    return this;
  }

}
</code></pre>

<h2>注解处理器调试</h2>

<p>不会调试说明还没有真正的入门。并且没有调试的情况下，解决异常、错误也是一件异常痛苦的事情。注解处理器生成代码是在编译阶段来生成代码的，所以调试的选项配置添加到 javac 。而 gradle 提供了一种相对简单的方式来进行。</p>

<p>参考</p>

<ul>
<li><a href="https://stackoverflow.com/questions/8587096/how-do-you-debug-java-annotation-processors-using-intellij">how do you debug java annotation processors using intellij?
</a></li>
<li><a href="https://discuss.gradle.org/t/how-do-you-attach-a-debugger-to-gradle-so-that-i-can-debug-it-running-a-task/7526/5">How do you attach a debugger to gradle so that I can debug it running a task?</a></li>
</ul>


<p></p>

<p>具体步骤如下：</p>

<ol>
<li><p>在命令行运行构建</p>

<p>添加调试参数后，gradle 会 <strong>暂停等待远程调试</strong> ，相当于添加了 JVM 调试参数。<a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties">Gradle properties</a></p>

<pre><code>hello-annotation-processor\example&gt;gradle clean build --no-daemon -Dorg.gradle.debug=true
或者
hello-annotation-processor&gt;gradle example:clean example:compileJava --no-daemon -Dorg.gradle.debug=true
</code></pre>

<p>注： &ndash;no-daemon 不加也是可以的，但是运行该次构建后不会停止。</p>

<p><img src="/images/blogs/annotation-processor-debug-s1.png" alt="" /></p></li>
<li><p>远程调试</p>

<p><img src="/images/blogs/annotation-processor-debug-s2.png" alt="" /></p></li>
</ol>


<h3>其他调试配置方式</h3>

<ul>
<li><p>通过环境变量</p>

<pre><code>example&gt;set GRADLE_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005

example&gt;gradle clean build
Listening for transport dt_socket at address: 5005
</code></pre></li>
<li><p>修改 ~/.gradle/gradle.properties</p>

<p>这种方式不推荐，因为它是全局的。</p>

<pre><code>org.gradle.daemon=false
org.gradle.debug=true
</code></pre>

<p>或者</p>

<pre><code>org.gradle.daemon=true
org.gradle.jvmargs=-XX:MaxPermSize=4g -XX:+HeapDumpOnOutOfMemoryError -Xmx4g -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5006

$ gradle --daemon
</code></pre>

<p>Then attach your debugger client to port 5006, set your breakpoint, then run your test.</p>

<p>注：该配置放到项目目录下没用。</p></li>
</ul>


<h2>其他</h2>

<ul>
<li>Gradle参数优化 <a href="https://stackoverflow.com/questions/16775197/building-and-running-app-via-gradle-and-android-studio-is-slower-than-via-eclips/19500539#19500539">Building and running app via Gradle and Android Studio is slower than via Eclipse</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebStart的使用以及如何结合JVMTI]]></title>
    <link href="http://winse.github.io/blog/2018/04/07/java-webstart-jnlp-with-jvmti/"/>
    <updated>2018-04-07T00:36:47+08:00</updated>
    <id>http://winse.github.io/blog/2018/04/07/java-webstart-jnlp-with-jvmti</id>
    <content type="html"><![CDATA[<p>当新技术叠加老功能时总能把人折磨一番，新仇加旧恨，原本的老功能也不是熟到透，然后还得去结合新功能，真的简直要人命。</p>

<p>最近有上新功能，把Swing客户端的代码通过webstart的方式发布给客户用，这样用户只需要点击网页上的链接，就可以使用Swing客户端了。感觉体验上还是厉害不少的，只是感觉啊！现实往往更残酷，我们先避开不谈。</p>

<p>首先简单的介绍下webstart、jnlp的一些知识，然后讲讲怎么结合jvmti、以及过程中遇到问题时定位查找解决的一些小知识点。</p>

<h2>JNLP</h2>

<p>为了便于借鉴参考，我这里用的是 <code>jre1.8.0_162</code></p>

<ul>
<li>docs <a href="https://docs.oracle.com/javase/tutorial/deployment/webstart/developing.html">https://docs.oracle.com/javase/tutorial/deployment/webstart/developing.html</a></li>
<li>example <a href="https://docs.oracle.com/javase/tutorial/deployment/webstart/running.html">https://docs.oracle.com/javase/tutorial/deployment/webstart/running.html</a></li>
<li>syntax <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/syntax.html">https://docs.oracle.com/javase/8/docs/technotes/guides/javaws/developersguide/syntax.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-ecl-rcpws/index.html">使用 WebStart 发布 RCP 应用程序</a></li>
<li><a href="http://javatechniques.com/blog/launching-java-webstart-from-the-command-line/">Launching Java WebStart from the Command Line</a></li>
</ul>


<p><strong> 签名： </strong></p>

<pre><code>jarsigner.exe -keystore Keystore application.jar alias
</code></pre>

<p><strong> 说说调试： </strong></p>

<ul>
<li>首先你得安装jre，不然Windows的控制面板没有Java这一项！</li>
<li>然后打开 <code>Java控制面板 - 高级 - 调试</code> 的选项。刚开始调试可以同时把 <code>Java控制台</code> 也显示出来</li>
<li>远程调试 选项在 <code>Java控制面板 - Java - Java运行时环境设置 - 运行时参数</code> 添加！</li>
</ul>


<p>参考</p>

<ul>
<li><a href="https://stackoverflow.com/questions/26668723/remote-debugging-java-web-start-under-jvm-1-8">Remote debugging java web start under JVM 1.8</a></li>
<li>Development Tips <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/plugin004.html">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/plugin004.html</a></li>
<li>Configuration Problems <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/plugin001.html">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/plugin001.html</a></li>
<li><a href="https://docs.oracle.com/javase/1.5.0/docs/guide/javaws/developersguide/troubleshooting.03.06.html">https://docs.oracle.com/javase/1.5.0/docs/guide/javaws/developersguide/troubleshooting.03.06.html</a></li>
<li><a href="https://stackoverflow.com/questions/686061/how-can-i-debug-applications-under-java-web-start-jnlp">How can I debug applications under Java Web Start (JNLP)?</a></li>
<li><a href="https://blackboard.secure.force.com/publickbarticleview?id=kA770000000CbHX">Java - Associating JNLP files on Windows without using the Control Panel</a></li>
</ul>


<p></p>

<p><strong> 缓冲： </strong></p>

<p>目录</p>

<pre><code>C:\Users\winse\AppData\LocalLow\Sun\Java\Deployment
</code></pre>

<p>调出 <em>Java高速缓冲查看器</em> 界面</p>

<pre><code>javaws -viewer
</code></pre>

<p><strong> 证书： </strong></p>

<p>证书是用jre对应目录下的： jre1.8.0_162\lib\security\cacerts</p>

<ul>
<li><a href="https://blogs.oracle.com/jtc/installing-trusted-certificates-into-a-java-keystore">Installing Trusted Certificates into a Java Keystore</a></li>
<li><a href="https://stackoverflow.com/questions/10077714/adding-certificate-to-keystore-using-java-code">Adding certificate to keystore using java code</a></li>
<li><a href="https://stackoverflow.com/questions/4325263/how-to-import-a-cer-certificate-into-a-java-keystore">How to import a .cer certificate into a java keystore?</a></li>
<li><a href="https://web.archive.org/web/20130319003303/http://dzone.com/snippets/ssl-download-certificate-chain">SSL : Download Certificate Chain From A Remote Host And Add The Certificates To A Local Keystore</a></li>
</ul>


<p></p>

<h2>结合JVMTI（仇恨点）</h2>

<p>既然都是agent，那么加载时机也同样有<strong>两种</strong>：启动时（Agent_OnLoad）和运行时Attach（Agent_OnAttach）。</p>

<ul>
<li><a href="http://www.fanyilun.me/2017/07/18/%E8%B0%88%E8%B0%88Java%20Intrumentation%E5%92%8C%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/">谈谈Java Intrumentation和相关应用</a></li>
<li><a href="http://www.cnblogs.com/lancao008/archive/2012/03/29/2423469.html">基于jvmti方式加密java</a></li>
<li><a href="https://blog.csdn.net/ooppookid/article/details/51809545">Java千百问<em>08JDK详解（013）</em>JVMTI是什么</a></li>
<li><a href="http://www.cnblogs.com/princessd8251/articles/5177698.html">动态替换目标进程的Java类</a></li>
</ul>


<p><strong> 动态loadAgent </strong></p>

<ul>
<li><a href="https://liuzhengyang.github.io/2017/10/21/dynamic-attach-jvm/">dynamic-attach-jvm</a></li>
</ul>


<p></p>

<p><strong> 修改加载 动态链接库dll 的方式： </strong></p>

<p>默认是不能在程序里面动态修改加载库地址的 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4280189">JDK-4280189 : loadLibrary() fails to load a shared lib whose path is in java.library.path</a> 。</p>

<ol>
<li>修改环境变量PATH，-Djava.library.path</li>
<li>运行时动态修改java.library.path：usr_paths/sys_paths</li>
<li>把dll拷贝到环境变量PATH的一个路径下面</li>
</ol>


<p>参考</p>

<ul>
<li><a href="https://dzone.com/articles/jni-java-web-start-applet">JNI in Java Web Start / Applet environment</a></li>
<li><a href="https://www.chilkatsoft.com/java-loadlibrary-windows.asp">How to Load a Java Native/Dynamic Library (DLL)</a></li>
<li><a href="http://www.cnblogs.com/princessd8251/articles/5177698.html">动态替换目标进程的Java类</a></li>
</ul>


<p></p>

<p><strong> 解决 DLL依赖 问题的终极完美方法： </strong></p>

<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/7d83bc18.aspx">Search Path Used by Windows to Locate a DLL</a></li>
</ul>


<blockquote><ol>
<li>The directory where the executable module for the current process is located.</li>
<li>The current directory.</li>
<li>The Windows system directory. The GetSystemDirectory function retrieves the path of this directory.</li>
<li>The Windows directory. The GetWindowsDirectory function retrieves the path of this directory.</li>
<li>The directories listed in the PATH environment variable.</li>
</ol>
</blockquote>

<ul>
<li><a href="https://stackoverflow.com/questions/518228/is-it-possible-to-add-a-directory-to-dll-search-path-from-a-batch-file-or-cmd-sc">Is it possible to add a directory to DLL search path from a batch file or cmd script?</a></li>
<li><a href="https://rgrzywinski.wordpress.com/2006/03/27/cant-find-dependent-libraries/">Can’t find dependent libraries</a></li>
</ul>


<blockquote><p>You might need to use something such as Dependency Walker to trace the set of DLL dependencies.</p></blockquote>

<p>把所有的库全部按依赖顺序执行一遍 System.loadLibrary ！！</p>

<p><strong> com.sun.tools.attach.AttachNotSupportedException: no providers installed </strong></p>

<ul>
<li><a href="http://www.chenjianjx.com/myblog/entry/com-sun-tools-attach-attachnotsupportedexception">http://www.chenjianjx.com/myblog/entry/com-sun-tools-attach-attachnotsupportedexception</a></li>
</ul>


<blockquote><ol>
<li>你没有使用sun jdk</li>
<li>你使用了sun jdk，并且JAVA_HOME指向了这个jdk，但是你的path下的"java"命令不是这个jdk里面的java，而是操作系统给你默认安装的jre下的，如c:\Program Files\java..</li>
</ol>
</blockquote>

<h2>小结</h2>

<p>最傻瓜式的点击就能运行是最佳体验，我们暂时不能通过控制面板添加 <code>-agentlib:lib</code> 的方式来初始化JVMTI。最终通过以上添加tools.jar的VirtualMachine.loadAgentLibrary运行时attach方式来实现。</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中使用代理-基于Shandowsocks]]></title>
    <link href="http://winse.github.io/blog/2018/01/26/proxy-on-java-via-shandowsocks/"/>
    <updated>2018-01-26T20:50:05+08:00</updated>
    <id>http://winse.github.io/blog/2018/01/26/proxy-on-java-via-shandowsocks</id>
    <content type="html"><![CDATA[<p>在开发过程中，时不时需要要代理一下，来访问我们需要的资源，比方说：DEBUG生产<strong>集群</strong>的应用、还有在Java中翻墙等等。解决了全局的代理能完成我们访问到资源的时刻，又有新的要求，比方说：只有特定的资源走代理等等。</p>

<p>下面把要点简单罗列下，以供参考：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/1432961/how-do-i-make-httpurlconnection-use-a-proxy">https://stackoverflow.com/questions/1432961/how-do-i-make-httpurlconnection-use-a-proxy</a></li>
<li><a href="http://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html">http://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html</a></li>
<li><a href="https://stackoverflow.com/questions/120797/how-do-i-set-the-proxy-to-be-used-by-the-jvm">https://stackoverflow.com/questions/120797/how-do-i-set-the-proxy-to-be-used-by-the-jvm</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html">https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html</a></li>
</ul>


<p>JDK官网基本内容全部都包括了，其他链接作为理解辅助，看看人家的实际需求与具体解决方法。</p>

<h2>Java全应用级代理（全局）</h2>

<ul>
<li>走HTTP</li>
</ul>


<p>Shandowsocks转HTTP，前面Docker翻墙安装Kubernate有弄过，参考：<a href="/blog/2017/02/04/privoxy-http-proxy-for-shadowsocks/">Privoxy</a> 。</p>

<p>也可以直接用Shandowsocks提供的 <code>启用系统代理 -&gt; 系统代理模式 -&gt; 全局模式</code> 来转换，启用HTTP代理功能。（开全局模式，本地会把socks代理转成为一个http的代理）</p>

<pre><code>-Dhttp.proxyHost=127.0.0.1
-Dhttp.proxyPort=7070
-Dhttps.proxyHost=127.0.0.1
-Dhttps.proxyPort=7070
-Dhttp.nonProxyHosts="localhost|127.0.0.1|192.168.*"
</code></pre>

<blockquote><ul>
<li>http.proxyHost: the host name of the proxy server</li>
<li>http.proxyPort: the port number, the default value being 80.</li>
<li>http.nonProxyHosts:a list of hosts that should be reached directly, bypassing the proxy. This is a list of patterns separated by &lsquo;|&rsquo;. The patterns may start or end with a &lsquo;*&rsquo; for wildcards. Any host matching one of these patterns will be reached through a direct connection instead of through a proxy.</li>
</ul>
</blockquote>

<p></p>

<ul>
<li>走Socks</li>
</ul>


<pre><code>-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=7070
</code></pre>

<ul>
<li>使用系统代理</li>
</ul>


<pre><code>-Djava.net.useSystemProxies=true
</code></pre>

<h2>部分/使用时设置（自动切换）</h2>

<ul>
<li>应用内通过 setProperty <strong>临时</strong> 进行设置（这种有缺陷，中间一段时间相当于全局代理了，不推荐）</li>
</ul>


<pre><code>System.setProperty("http.proxyHost", proxyHost);
System.setProperty("http.proxyPort", proxyPort);
System.setProperty("https.proxyHost", proxyHost);
System.setProperty("https.proxyPort", proxyPort);
</code></pre>

<p>用完之后，取消设置：</p>

<pre><code>System.clearProperty("http.proxyHost");
...
</code></pre>

<ul>
<li>请求时指定代理：</li>
</ul>


<pre><code>SocketAddress addr = new InetSocketAddress("webcache.example.com", 8080);
Proxy proxy = new Proxy(Proxy.Type.HTTP, addr);

URL url = new URL("http://java.example.org/");
URLConnection conn = url.openConnection(proxy);
</code></pre>

<ul>
<li>（选择性的）配置哪些访问走代理：ProxySelector</li>
</ul>


<p>任何请求访问网络之前，会被ProxySelector拦截。根据规则获取一个符合的Proxy（或者Proxy.NO_PROXY），然后通过这个代理去访问网络。</p>

<blockquote><p>As you can see, with Java SE 5.0, the developer gains quite a bit of control and flexibility when it comes to proxies. Still, there are situations where one would like to decide which proxy to use dynamically, for instance to do some load balancing between proxies, or depending on the destination, in which case the API described so far would be quite cumbersome. That&rsquo;s where the ProxySelector comes into play.</p>

<p>The best thing about the ProxySelector is that it is plugable! Which means that if you have needs that are not covered by the default one, you can write a replacement for it and plug it in!</p></blockquote>

<p>基本上看JDK官网的内容就好了，非常全。也可以参考下 <a href="http://archive.oreilly.com/pub/a/onjava/excerpt/jvntwkprg_3e/index.html?page=3#javanp3-CHP-7-SECT-4">URLs and URIs, Proxies and Passwords</a></p>

<p>注册自定义的Selector：</p>

<pre><code>public static void main(String[] args) {
    MyProxySelector ps = new MyProxySelector(ProxySelector.getDefault());
    ProxySelector.setDefault(ps);
    // rest of the application
}
</code></pre>

<p>Selector实现：</p>

<pre><code>public class MyProxySelector extends ProxySelector {
    // Keep a reference on the previous default
    ProxySelector defsel = null;

    /*
     * Inner class representing a Proxy and a few extra data
     */
    class InnerProxy {
        Proxy proxy;
        SocketAddress addr;
        // How many times did we fail to reach this proxy?
        int failedCount = 0;

        InnerProxy(InetSocketAddress a) {
            this(a, Proxy.Type.HTTP);
        }

        InnerProxy(InetSocketAddress a, Proxy.Type type) {
            addr = a;
            proxy = new Proxy(type, a);
        }

        SocketAddress address() {
            return addr;
        }

        Proxy toProxy() {
            return proxy;
        }

        int failed() {
            return ++failedCount;
        }
    }

    /*
     * A list of proxies, indexed by their address.
     */
    HashMap&lt;SocketAddress, InnerProxy&gt; proxies = new HashMap&lt;SocketAddress, InnerProxy&gt;();

    MyProxySelector(ProxySelector def) {
        // Save the previous default
        defsel = def;

        // Populate the HashMap (List of proxies)
        InnerProxy i = new InnerProxy(new InetSocketAddress("webcache1.example.com", 8080));
        proxies.put(i.address(), i);
        i = new InnerProxy(new InetSocketAddress("webcache2.example.com", 8080));
        proxies.put(i.address(), i);
        i = new InnerProxy(new InetSocketAddress("webcache3.example.com", 8080));
        proxies.put(i.address(), i);
    }

    /*
     * This is the method that the handlers will call.
     * Returns a List of proxy.
     */
    public java.util.List&lt;Proxy&gt; select(URI uri) {
        // Let's stick to the specs. 
        if (uri == null) {
            throw new IllegalArgumentException("URI can't be null.");
        }

        /* 这里可以指定你自己的规则/配置
         * If it's a http (or https) URL, then we use our own list.
         */
        String protocol = uri.getScheme();
        if ("http".equalsIgnoreCase(protocol) ||
                "https".equalsIgnoreCase(protocol)) {
            ArrayList&lt;Proxy&gt; l = new ArrayList&lt;Proxy&gt;();
            for (InnerProxy p : proxies.values()) {
                l.add(p.toProxy());
            }
            return l;
        }

        /*
         * Not HTTP or HTTPS (could be SOCKS or FTP)
         * defer to the default selector.
         */
        if (defsel != null) {
            return defsel.select(uri);
        } else {
            ArrayList&lt;Proxy&gt; l = new ArrayList&lt;Proxy&gt;();
            l.add(Proxy.NO_PROXY);
            return l;
        }
    }

    /*
     * Method called by the handlers when it failed to connect
     * to one of the proxies returned by select().
     */
    public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
        // Let's stick to the specs again.
        if (uri == null || sa == null || ioe == null) {
            throw new IllegalArgumentException("Arguments can't be null.");
        }

        /*
         * Let's lookup for the proxy 
         */
        InnerProxy p = proxies.get(sa); 
        if (p != null) {
            /*
             * It's one of ours, if it failed more than 3 times
             * let's remove it from the list.
             */
            if (p.failed() &gt;= 3)
                    proxies.remove(sa);
        } else {
            /*
             * Not one of ours, let's delegate to the default.
             */
            if (defsel != null)
              defsel.connectFailed(uri, sa, ioe);
        }
    }
}
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用ADT调试Xamarin程序中的Java库]]></title>
    <link href="http://winse.github.io/blog/2014/08/29/xamarin-application-use-adt-eclipse-debug-java-code/"/>
    <updated>2014-08-29T12:08:11+08:00</updated>
    <id>http://winse.github.io/blog/2014/08/29/xamarin-application-use-adt-eclipse-debug-java-code</id>
    <content type="html"><![CDATA[<p>在编写SDK的时刻，有用户需要使用Xamarin来开发应用。我们这边暂时没有这个方面的经验，有点瞎扯扯意味，路是崎岖的前进是痛苦的。</p>

<h2>封装Android-SDK</h2>

<p>Xamarin是使用C#语言来编写代码的，所以需要先把Android的jar库包装成为C#的代码。<a href="http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/">可选方式有3种</a>)，这里选用Wrapper的形式，不过多讲解，看文章<a href="http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/binding_a_java_library_(.jar">Binding a Java Library - Consuming .JARs from C#</a>/)。</p>

<p>建立Binding项目，把依赖的包加入到Jars目录下。由于Bmob-Android官方的包是进行混淆的，有些代码不会用到的/没有必要Wrapper生成jni代码调用的，可以通过removenote去掉不生成C#的wrapper类。第二点就是java的泛型是会被抹掉的，而C#的是会编入程序中的，遇到Comparable这种类型的方法时，需要进行参数强制转换下。第三点就是接口回调，有多个方法时会导致名称冲突，需要为每个接口的方法都配置一个Args的节点属性。这些都是官网的例子中有说明，有需要可以具体参考上面链接的文章内容。</p>

<pre><code>    &lt;metadata&gt;
        &lt;remove-node path="/api/package[@name='cn.bmob.im.db']" /&gt;

      &lt;attr path="/api/package[@name='cn.bmob.im.inteface']/interface[@name='DownloadListener']/method[@name='onError']" name="argsType"&gt;DownloadListenerErrorEventArgs&lt;/attr&gt;
    &lt;/metadata&gt;

    &lt;enum-method-mappings&gt;
      &lt;mapping jni-class="cn/bmob/im/bean/BmobRecent"&gt;
        &lt;method jni-name="compareTo" parameter="p0" clr-enum-type="Java.Lang.Object" /&gt;
      &lt;/mapping&gt;
      &lt;mapping jni-class="cn/bmob/im/BmobDownloadManager"&gt;
        &lt;method jni-name="doInBackground" parameter="p0" clr-enum-type="Java.Lang.Object[]" /&gt;
      &lt;/mapping&gt;
    &lt;/enum-method-mappings&gt;
</code></pre>

<p>还有另一个坑是，混淆后内部类会被扁平化，导致jar2xml执行时获取类的getSimpleName名称会抛异常，我这里直接反编译源码改成getName就好了，仅仅是代码中全路径和仅类名的却别，暂时来看没啥印象。</p>

<p>然后编译，加入到主项目的依赖中就可以使用该库的Java功能了。名称可能并不能全部对应上，与Java中的方法名和常量名大小写、下划线的不同罢了。</p>

<h2>调试</h2>

<p>下面是重点，但是很简短。</p>

<p>作为写SDK的，肯定不仅仅要用特定的工具，还的把中间的过程也扭顺，即既要做一个好点（example），又得实现连接的线（SDK）。</p>

<p>如果Android SDK的代码没有执行，该怎么办？Xamarin中都是C#的代码并不能用于调试java啊！问题自然归结到怎么用两个工具（Xamarin和Eclipse）来同时调试一个Xamarin Android应用的问题？！</p>

<p>先讲讲我遇到的坑，由于是开发者发给我的应用，不知道结构是怎么样的。我直接用Xamarin打开，是没有带可执行属性的，在Run-With菜单中是能看到我的实体机器的，但是就是不能把程序发布上去！提示【执行失败。未将对象引用设置到对象的实例。】然后就没了。最终在stackoverflow中找到了类型问题的解决方法，需要设置运行属性。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAAt6AVtg6AALZEEiP4tQ304.png" alt="" /></p>

<p>配置如下，在解决方案属性中【构建-配置-ConfigurationMappings】把项目添加为构建项。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAA4uAT9qmAAKI8-zKAn8494.png" alt="" /></p>

<p>可能还会遇到的问题是版本的问题，报错【java.lang.RuntimeException: Unable to get provider mono.MonoRuntimeProvider: java.lang.RuntimeException: Unable to find application Mono.Android.DebugRuntime or Mono.Android.Platform.ApiLevel_19!】需要在csproj的配置中修改AndroidUseLatestPlatformSdk属性为false。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAC4KAOV-HAAFU6knDvFQ527.png" alt="" /></p>

<p>下面的步骤才是本文的关键：</p>

<p>首先，在MainActivity的onCreate方法开始出打个断点，便于初始化功能调试，点击左上角的开始运行按钮。这样就能把代码发布到机器，且运行后会停留在onCreate处。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QACtCAHOqDAAELanVrybU938.png" alt="" /></p>

<p>Xamarin调试效果图</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAC_yAYqbpAAHBQT48VSA253.png" alt="" /></p>

<p>再，打开ecilpse导入<code>obj\Debug\android</code>目录下的项目【Import-Android-Existing Android Code Into Workspace】，错误什么的无所谓。这个项目只是用了ADT能识别而已。然后再java包的代码里面打上断点。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QADTuAd3cyAACtJUn8Pdk976.png" alt="" /></p>

<p>最后，起到定乾坤作用的就是DDMS的Devices试图的小爬虫，选择你要调试的程序，然后点击它就可以了。切换到Xamarin继续运行程序，接下来就会运行停留到eclipse中的java包中的断点程序出。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QADnWAJQyIAABt1LtWjUA456.png" alt="" /></p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QADueALec-AAEQhd4vxMY835.png" alt="" /></p>

<p>OK，接下来就按照eclipse的调试技巧弄就好了。</p>

<p>步骤很简单，查询的路子却是艰辛的。第一次尝试成本总是昂贵的，第二步自然会慢慢顺起来。fighting&hellip;</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
</feed>
