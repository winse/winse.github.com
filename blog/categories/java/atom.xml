<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Winse Blog]]></title>
  <link href="http://winse.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://winse.github.io/"/>
  <updated>2014-07-21T12:19:09+08:00</updated>
  <id>http://winse.github.io/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java反编译工具使用记录]]></title>
    <link href="http://winse.github.io/blog/2013/10/24/java-decompiler-tools/"/>
    <updated>2013-10-24T20:20:00+08:00</updated>
    <id>http://winse.github.io/blog/2013/10/24/java-decompiler-tools</id>
    <content type="html"><![CDATA[<h2>工具</h2>

<ul>
<li><a href="http://varaneckas.com/jad/">jad</a></li>
<li><a href="http://jd.benow.ca/">JD-core</a></li>
<li>参考 <a href="http://zhouliang.pro/2010/06/26/jad/">http://zhouliang.pro/2010/06/26/jad/</a></li>
</ul>


<h2>差异</h2>

<p>JD-Core还是比较与时俱进的，对泛型/foreach等新的语法都支持。Jad则只支持到only 45.3(1.1), 46.0 and 47.0(1.3)。  <br/>
任何事物都不是完美的，结合两个工具来看反编译后的源码能更好的回归源码的真相。</p>

<ul>
<li>JD-Core解析双for循环是存在问题！结合jad可能更好的明白源码。</li>
<li>内部类解析<strong>都</strong>不够好，JD-Core相对错误少一些</li>
</ul>


<h2>对比</h2>

<p>这里就[for循环]/[双层for循环]/[内部类]进行对比。</p>

<h3>单for循环</h3>

<p><strong>源码</strong></p>

<pre><code>List&lt;String&gt; list = Arrays.asList("abc", "bcd");

public void testForEach() {
    for (String ele : list) { // for编译成字节码后使用iterator的形式
        System.out.println(ele);
    }
}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>List&lt;String&gt; list = Arrays.asList(new String[] { "abc", "bcd" });

public void testForEach() {
for (String ele : this.list)
    System.out.println(ele);
}
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public JavaDecompilerTest()
{
    list = Arrays.asList(new String[] {
        "abc", "bcd"
    });
}

public void testForEach()
{
    String ele;
    for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(ele))
        ele = (String)iterator.next();

}

List list;
</code></pre>

<h3>双层for循环</h3>

<p><strong>源码</strong></p>

<pre><code>List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
{
    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    map.put("12", "23");
    list.add(map);
}

public void testForIndex() {
    for (int i = 0; i &lt; list.size(); i++) {
        Map&lt;String, String&gt; map = list.get(i);
        for (String key : map.keySet())
            System.out.println(map.get(key));
    }
}

public void testForEach() {
    for (Map&lt;String, String&gt; map : list) {
        for (String key : map.keySet())
            System.out.println(map.get(key));
    }
}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>  List&lt;Map&lt;String, String&gt;&gt; list;

  public JavaDecompilerTest2()
  {
    this.list = new ArrayList();

    Map map = new HashMap();
    map.put("12", "23");
    this.list.add(map);
  }

  public void testForIndex() {
    for (int i = 0; i &lt; this.list.size(); i++) {
      Map map = (Map)this.list.get(i);
      for (String key : map.keySet())
        System.out.println((String)map.get(key));
    }
  }

  public void testForEach()
  {
    Iterator localIterator2;
    for (Iterator localIterator1 = this.list.iterator(); localIterator1.hasNext(); 
      localIterator2.hasNext())
    {
      Map map = (Map)localIterator1.next();
      localIterator2 = map.keySet().iterator(); continue; String key = (String)localIterator2.next();
      System.out.println((String)map.get(key));
    }
  }
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public JavaDecompilerTest2()
{
    list = new ArrayList();
    Map map = new HashMap();
    map.put("12", "23");
    list.add(map);
}

public void testForIndex()
{
    for(int i = 0; i &lt; list.size(); i++)
    {
        Map map = (Map)list.get(i);
        String key;
        for(Iterator iterator = map.keySet().iterator(); iterator.hasNext(); System.out.println((String)map.get(key)))
            key = (String)iterator.next();

    }

}

public void testForEach()
{
    for(Iterator iterator = list.iterator(); iterator.hasNext();)
    {
        Map map = (Map)iterator.next();
        String key;
        for(Iterator iterator1 = map.keySet().iterator(); iterator1.hasNext(); System.out.println((String)map.get(key)))
            key = (String)iterator1.next();

    }

}

List list;
</code></pre>

<h3>内部类</h3>

<p><strong>源码</strong></p>

<pre><code>public class JavaDecompilerTest3 {

    private class Test2 {}

    Test2 test = new Test2();

}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>public class JavaDecompilerTest3
{
  JavaDecompilerTest3.Test2 test = new JavaDecompilerTest3.Test2(null);

  private class Test2
  {
    private Test2()
    {
    }
  }
}
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public class JavaDecompilerTest3
{
    private class Test2
    {

        final JavaDecompilerTest3 this$0;

        private Test2()
        {
            this$0 = JavaDecompilerTest3.this;
            super();
        }

        Test2(Test2 test2)
        {
            this();
        }
    }


    public JavaDecompilerTest3()
    {
        test = new Test2(null);
    }

    Test2 test;
}
</code></pre>

<h2>后记</h2>

<p>工具javap可以查看class的方法签名，通过jd-gui和jad可以反编译得到源码，如果代码没有混淆的话，多半就能了解代码的功能了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Filter Mapping Url-pattern That Excludes Subdirectories]]></title>
    <link href="http://winse.github.io/blog/2012/07/26/ssh-urlpattern-excludes-subdirectory/"/>
    <updated>2012-07-26T14:04:00+08:00</updated>
    <id>http://winse.github.io/blog/2012/07/26/ssh-urlpattern-excludes-subdirectory</id>
    <content type="html"><![CDATA[<p>需求其实就是把eclipse osgi导出的应用嵌入到原有的ssh开发的程序中。
但是整合过程遇到一些问题。ssh会对资源进行拦截处理，导致OSGi获取不到请求，OSGi和ssh的应用最好分开管理。
可以利用SSH提供的excludePattern配置正则表达式来实现排除处理！</p>

<h2>Struts拦截器配置</h2>

<pre><code>    &lt;filter&gt; 
      &lt;filter-name&gt;struts-cleanup&lt;/filter-name&gt; 
      &lt;filter-class&gt; 
       org.apache.struts2.dispatcher.ActionContextCleanUp 
      &lt;/filter-class&gt; 
    &lt;/filter&gt;
    &lt;filter-mapping&gt; 
      &lt;filter-name&gt;struts-cleanup&lt;/filter-name&gt; 
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 
    &lt;/filter-mapping&gt; 

    &lt;filter&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;       
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;/struts/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>

<h2>添加OSGi支持</h2>

<p>把eclipse osgi应用嵌入需要在web.xml中添加：</p>

<pre><code>    &lt;servlet id="bridge"&gt;
        &lt;servlet-name&gt;equinoxbridgeservlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.eclipse.equinox.servletbridge.BridgeServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;commandline&lt;/param-name&gt;
            &lt;param-value&gt;-console&lt;/param-value&gt;         
        &lt;/init-param&gt;       
        &lt;init-param&gt;
            &lt;param-name&gt;enableFrameworkControls&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;         
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;extendedFrameworkExports&lt;/param-name&gt;
            &lt;param-value&gt;&lt;/param-value&gt;         
        &lt;/init-param&gt;   
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;equinoxbridgeservlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;
            /osgi/*
        &lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>

<h2>整合遇到的问题及解决</h2>

<p>由于struts的filter过滤了htm，导致osgi的htm文件被struts"劫"取了~~</p>

<p>经过一番挣扎，解决方法如下：</p>

<p>在struts过滤器中增加排除参数。</p>

<pre><code>  &lt;filter&gt;
    &lt;filter-name&gt;struts&lt;/filter-name&gt;
    &lt;filter-class&gt;
        org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;struts.action.excludePattern&lt;/param-name&gt;
        &lt;param-value&gt;/osgi/.*&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
</code></pre>

<h2>为啥怎么弄，解释如下：</h2>

<p><strong>1 读取init-param初始化参数excludedPatterns</strong></p>

<pre><code>    protected List&lt;Pattern&gt; excludedPatterns = null;

    public void init(FilterConfig filterConfig) throws ServletException {
        InitOperations init = new InitOperations();
        try {
            FilterHostConfig config = new FilterHostConfig(filterConfig);
            init.initLogging(config);
            Dispatcher dispatcher = init.initDispatcher(config);
            init.initStaticContentLoader(config, dispatcher);

            prepare = new PrepareOperations(filterConfig.getServletContext(), dispatcher);
            execute = new ExecuteOperations(filterConfig.getServletContext(), dispatcher);
            this.excludedPatterns = init.buildExcludedPatternsList(dispatcher); // 获取不被Struts处理的请求Regex模式

            postInit(dispatcher, filterConfig);
        } finally {
            init.cleanup();
        }

    }
</code></pre>

<p><strong> 2 使用excludedPatterns</strong></p>

<pre><code>    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) 
                        throws IOException, ServletException {
        //父类向子类转：强转为httpReq请求、httpResp响应
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        try {
            //。。。@@根据Regex模式(excludedPatterns)对请求进行处理
            if ( excludedPatterns != null &amp;&amp; prepare.isUrlExcluded(request, excludedPatterns)) {
                chain.doFilter(request, response);
            } else {
                request = prepare.wrapRequest(request);
                ActionMapping mapping = prepare.findActionMapping(request, response, true);
                if (mapping == null) {
                    boolean handled = execute.executeStaticResourceRequest(request, response);
                    if (!handled) {
                        chain.doFilter(request, response);
                    }
                } else {
                    execute.executeAction(request, response, mapping);
                }
            }
        } finally {
             prepare.cleanupRequest(request);
        }
    }
</code></pre>

<h2>后记</h2>

<p>其实SSH就是对请求进行过滤拦截转发！Struts提供了不处理请求配置罢了。</p>

<p>看到的其他实现：</p>

<pre><code>    // First cast ServletRequest to HttpServletRequest.
    HttpServletRequest hsr = (HttpServletRequest) request;

    // Check if requested resource is not in /test folder.
    if (!hsr.getServletPath().startsWith("/test/")) {
        // Not in /test folder. Do your thing here.
    }
</code></pre>

<p>web.xml中<url-pattern>的3种写法</p>

<ol>
<li>完全匹配 <url-pattern>/test/list.do</url-pattern></li>
<li>目录匹配 <url-pattern>/test/*</url-pattern></li>
<li>扩展名匹配 <url-pattern>*.do</url-pattern></li>
</ol>


<p>servlet-mapping的重要规则：</p>

<ul>
<li>容器会首先查找完全匹配，如果找不到，再查找目录匹配，如果也找不到，就查找扩展名匹配。</li>
<li>如果一个请求匹配多个“目录匹配”，容器会选择最长的匹配。</li>
</ul>


<h2>参考资源：</h2>

<ul>
<li><a href="http://ari.iteye.com/blog/829843">http://ari.iteye.com/blog/829843</a></li>
<li><a href="http://www.docjar.org/html/api/org/apache/struts2/dispatcher/ng/filter/StrutsPrepareAndExecuteFilter.java.html">http://www.docjar.org/html/api/org/apache/struts2/dispatcher/ng/filter/StrutsPrepareAndExecuteFilter.java.html</a></li>
<li><a href="http://selectshy.iteye.com/blog/1293458">servlet-mapping</a></li>
<li><a href="http://space.itpub.net/13750068/viewspace-493899">Struts2的工作原理</a></li>
<li><a href="http://stackoverflow.com/questions/3125296/can-i-exclude-some-concrete-urls-from-url-pattern-inside-filter-mapping">Can I exclude some concrete urls from <url-pattern> inside <filter-mapping>?</a></li>
<li><a href="http://stackoverflow.com/questions/3466897/filter-mapping-url-pattern-that-excludes-subdirectories">Filter mapping url-pattern that excludes subdirectories</a></li>
<li><a href="http://www.blogjava.net/liuspring/archive/2008/09/01/226073.html">http://www.blogjava.net/liuspring/archive/2008/09/01/226073.html</a></li>
<li><a href="http://tuckey.org/urlrewrite/">urlrewrite</a></li>
<li><a href="http://urlrewritefilter.googlecode.com/svn/trunk/src/doc/manual/4.0/index.html#filterparams">http://urlrewritefilter.googlecode.com/svn/trunk/src/doc/manual/4.0/index.html#filterparams</a></li>
</ul>


<hr />

<p><a href="http://winse.iteye.com/blog/1607884">【原文地址】</a></p>
]]></content>
  </entry>
  
</feed>
