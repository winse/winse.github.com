<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Winse Blog]]></title>
  <link href="http://winse.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://winse.github.io/"/>
  <updated>2014-07-29T22:10:40+08:00</updated>
  <id>http://winse.github.io/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Win编译32位openjdk]]></title>
    <link href="http://winse.github.io/blog/2014/07/21/build-openjdk/"/>
    <updated>2014-07-21T14:23:57+08:00</updated>
    <id>http://winse.github.io/blog/2014/07/21/build-openjdk</id>
    <content type="html"><![CDATA[<p>win编译32位openjdk7u60:</p>

<p><div><script src='https://gist.github.com/3e6b42012dfb228a5b02.js?file=OpenJDK-Build-README.md'></script>
<noscript><pre><code>## 编译jdk7u60过程中的注意点: 

0. 先看目录下的README-builds.html，不要太认真看个大概就行
1. 下载最新的Microsoft DirectX SDK，安装时路径不要带括号
2. 安装procps代替free.exe(检查可用内存是会用到，没有应该也可以就是多个警告而已)
3. cygwin-make的版本问题，使用3.81 [snapshot](http://farm6.staticflickr.com/5486/14325549816_da7343282b_o.png)
4. VS2010的cl命令显示的信息一直是中文的话，需要修改源码跳过版本号的检查 [snapshot](http://farm3.staticflickr.com/2928/14162188587_7874083086_o.png)
5. 语言问题，导致编译corba失败！而后面有需要用到这个工程！ [snapshot](http://farm3.staticflickr.com/2936/14347140552_0f29391905_o.png)
6. PATH顺序问题，link.exe和find.exe [snapshot](http://farm6.staticflickr.com/5483/14347108132_9abdac5ae8_o.png)
7. 编译时间有点长！ [snapshot](http://farm4.staticflickr.com/3867/14162097680_40d5f69561_o.png) [java-version](http://farm4.staticflickr.com/3881/14162098450_7e86bd5b0b_o.png)
8. 默认的make不带调试信息的，需要用`make fastdebug_build`。

## 步骤：

1、 下载

可以的话，通过cygwin的setup.exe安装mercurial也行。

* hg: &lt;http://tortoisehg.bitbucket.org/download/index.html&gt;
* source: http://hg.openjdk.java.net/jdk7u/jdk7u60/

```
cd E:
cd git/
mkdir openjdk
cd openjdk/

HG_HOME=/cygdrive/c/Program\ Files/TortoiseHg/
PATH=$PATH:$HG_HOME

hg clone http://hg.openjdk.java.net/jdk7u/jdk7u60/
cd jdk7u60/
ls
./get_source.sh
```

2、 安装依赖软件

* jdk1.7.0_02/apache-ant-1.9.0
* Visual Studio2010
* Cygwin
  * 按照README-builds.html#cygwin，能找的必须安装，找不到的随意。
  * 安装procps，包括了free.exe。
  * 安装binutils，包括了ar.exe。
  * 替换[make.exe](http://www.cmake.org/files/cygwin/make.exe), 添加[cygintl-3.dll](http://www.opendll.com/dll/c/__32-cygintl-3.dll.zip)。
* 下载解压[freetype](http://jaist.dl.sourceforge.net/project/gnuwin32/freetype/2.3.5-1/freetype-2.3.5-1-bin.zip) 
  * 把bin目录下的freetype6.dll文件拷贝到../lib/freetype.dll
  * 添加[zlib1.dll](http://75.duote.org/win_dll/zlib1.zip) 也可以下载[安装版本](http://jaist.dl.sourceforge.net/project/gnuwin32/freetype/2.3.5-1/)包括了zlib1.dll
  * [snapshot](http://farm4.staticflickr.com/3922/14162193337_65d281fc73_o.png)
* 下载安装[Microsoft DirectX](http://download.microsoft.com/download/F/1/7/F178BCE4-FA19-428F-BB60-F3DEE1130BFA/DXSDK_Feb10.exe)
  * 安装路径不要带括号 

3、 配置环境

* 切换为英文语言环境，当你重新启动看到的是【Welcome】的时刻说明你修改成功了！重启后记得make clean再进行后面的操作！
 * Windows7安装更新，添加英文语言包
* 环境变量的所有路径最好是/ 而不是\，不能带双引号（否则中间编译的时刻会遇到问题）[snapshot](http://farm4.staticflickr.com/3862/14162030769_8766efa9a5_o.png)
* PATH路径顺序的问题，cygwin/bin放在vs的后面，但需要放在windows的前面。link.exe和find.exe的问题

如果是在X64机器上编译，需要加ARCH_DATA_MODEL的参数。参见【README-builds.html#creating】

## 参考：

* 【膜拜】[openjdk windows 编译](http://blog.csdn.net/instruder/article/details/8834117)
* 【有点老，不过注意事项还是相同的】 [自己动手编译Windows版的OpenJDK 7](http://icyfenix.iteye.com/blog/1097344) 
* 【linux下安装】&lt;http://khotyn.iteye.com/blog/1225348&gt;
* 【cl版本问题，以及make程序问题】&lt;http://www.myexception.cn/program/779678.html&gt;
* 【emitPermissionCheck问题】&lt;http://mail.openjdk.java.net/pipermail/jdk6-dev/2013-November/003104.html&gt; &lt;http://comments.gmane.org/gmane.comp.java.openjdk.jdk6.devel/976&gt;</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java反编译工具使用记录]]></title>
    <link href="http://winse.github.io/blog/2013/10/24/java-decompiler-tools/"/>
    <updated>2013-10-24T20:20:00+08:00</updated>
    <id>http://winse.github.io/blog/2013/10/24/java-decompiler-tools</id>
    <content type="html"><![CDATA[<h2>工具</h2>

<ul>
<li><a href="http://varaneckas.com/jad/">jad</a></li>
<li><a href="http://jd.benow.ca/">JD-core</a></li>
<li>参考 <a href="http://zhouliang.pro/2010/06/26/jad/">http://zhouliang.pro/2010/06/26/jad/</a></li>
</ul>


<h2>差异</h2>

<p>JD-Core还是比较与时俱进的，对泛型/foreach等新的语法都支持。Jad则只支持到only 45.3(1.1), 46.0 and 47.0(1.3)。  <br/>
任何事物都不是完美的，结合两个工具来看反编译后的源码能更好的回归源码的真相。</p>

<ul>
<li>JD-Core解析双for循环是存在问题！结合jad可能更好的明白源码。</li>
<li>内部类解析<strong>都</strong>不够好，JD-Core相对错误少一些</li>
</ul>


<h2>对比</h2>

<p>这里就[for循环]/[双层for循环]/[内部类]进行对比。</p>

<h3>单for循环</h3>

<p><strong>源码</strong></p>

<pre><code>List&lt;String&gt; list = Arrays.asList("abc", "bcd");

public void testForEach() {
    for (String ele : list) { // for编译成字节码后使用iterator的形式
        System.out.println(ele);
    }
}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>List&lt;String&gt; list = Arrays.asList(new String[] { "abc", "bcd" });

public void testForEach() {
for (String ele : this.list)
    System.out.println(ele);
}
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public JavaDecompilerTest()
{
    list = Arrays.asList(new String[] {
        "abc", "bcd"
    });
}

public void testForEach()
{
    String ele;
    for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(ele))
        ele = (String)iterator.next();

}

List list;
</code></pre>

<h3>双层for循环</h3>

<p><strong>源码</strong></p>

<pre><code>List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
{
    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    map.put("12", "23");
    list.add(map);
}

public void testForIndex() {
    for (int i = 0; i &lt; list.size(); i++) {
        Map&lt;String, String&gt; map = list.get(i);
        for (String key : map.keySet())
            System.out.println(map.get(key));
    }
}

public void testForEach() {
    for (Map&lt;String, String&gt; map : list) {
        for (String key : map.keySet())
            System.out.println(map.get(key));
    }
}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>  List&lt;Map&lt;String, String&gt;&gt; list;

  public JavaDecompilerTest2()
  {
    this.list = new ArrayList();

    Map map = new HashMap();
    map.put("12", "23");
    this.list.add(map);
  }

  public void testForIndex() {
    for (int i = 0; i &lt; this.list.size(); i++) {
      Map map = (Map)this.list.get(i);
      for (String key : map.keySet())
        System.out.println((String)map.get(key));
    }
  }

  public void testForEach()
  {
    Iterator localIterator2;
    for (Iterator localIterator1 = this.list.iterator(); localIterator1.hasNext(); 
      localIterator2.hasNext())
    {
      Map map = (Map)localIterator1.next();
      localIterator2 = map.keySet().iterator(); continue; String key = (String)localIterator2.next();
      System.out.println((String)map.get(key));
    }
  }
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public JavaDecompilerTest2()
{
    list = new ArrayList();
    Map map = new HashMap();
    map.put("12", "23");
    list.add(map);
}

public void testForIndex()
{
    for(int i = 0; i &lt; list.size(); i++)
    {
        Map map = (Map)list.get(i);
        String key;
        for(Iterator iterator = map.keySet().iterator(); iterator.hasNext(); System.out.println((String)map.get(key)))
            key = (String)iterator.next();

    }

}

public void testForEach()
{
    for(Iterator iterator = list.iterator(); iterator.hasNext();)
    {
        Map map = (Map)iterator.next();
        String key;
        for(Iterator iterator1 = map.keySet().iterator(); iterator1.hasNext(); System.out.println((String)map.get(key)))
            key = (String)iterator1.next();

    }

}

List list;
</code></pre>

<h3>内部类</h3>

<p><strong>源码</strong></p>

<pre><code>public class JavaDecompilerTest3 {

    private class Test2 {}

    Test2 test = new Test2();

}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>public class JavaDecompilerTest3
{
  JavaDecompilerTest3.Test2 test = new JavaDecompilerTest3.Test2(null);

  private class Test2
  {
    private Test2()
    {
    }
  }
}
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public class JavaDecompilerTest3
{
    private class Test2
    {

        final JavaDecompilerTest3 this$0;

        private Test2()
        {
            this$0 = JavaDecompilerTest3.this;
            super();
        }

        Test2(Test2 test2)
        {
            this();
        }
    }


    public JavaDecompilerTest3()
    {
        test = new Test2(null);
    }

    Test2 test;
}
</code></pre>

<h2>后记</h2>

<p>工具javap可以查看class的方法签名，通过jd-gui和jad可以反编译得到源码，如果代码没有混淆的话，多半就能了解代码的功能了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Filter Mapping Url-pattern That Excludes Subdirectories]]></title>
    <link href="http://winse.github.io/blog/2012/07/26/ssh-urlpattern-excludes-subdirectory/"/>
    <updated>2012-07-26T14:04:00+08:00</updated>
    <id>http://winse.github.io/blog/2012/07/26/ssh-urlpattern-excludes-subdirectory</id>
    <content type="html"><![CDATA[<p>需求其实就是把eclipse osgi导出的应用嵌入到原有的ssh开发的程序中。
但是整合过程遇到一些问题。ssh会对资源进行拦截处理，导致OSGi获取不到请求，OSGi和ssh的应用最好分开管理。
可以利用SSH提供的excludePattern配置正则表达式来实现排除处理！</p>

<h2>Struts拦截器配置</h2>

<pre><code>    &lt;filter&gt; 
      &lt;filter-name&gt;struts-cleanup&lt;/filter-name&gt; 
      &lt;filter-class&gt; 
       org.apache.struts2.dispatcher.ActionContextCleanUp 
      &lt;/filter-class&gt; 
    &lt;/filter&gt;
    &lt;filter-mapping&gt; 
      &lt;filter-name&gt;struts-cleanup&lt;/filter-name&gt; 
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 
    &lt;/filter-mapping&gt; 

    &lt;filter&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;       
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
      &lt;filter-name&gt;struts&lt;/filter-name&gt;
      &lt;url-pattern&gt;/struts/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>

<h2>添加OSGi支持</h2>

<p>把eclipse osgi应用嵌入需要在web.xml中添加：</p>

<pre><code>    &lt;servlet id="bridge"&gt;
        &lt;servlet-name&gt;equinoxbridgeservlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.eclipse.equinox.servletbridge.BridgeServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;commandline&lt;/param-name&gt;
            &lt;param-value&gt;-console&lt;/param-value&gt;         
        &lt;/init-param&gt;       
        &lt;init-param&gt;
            &lt;param-name&gt;enableFrameworkControls&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;         
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;extendedFrameworkExports&lt;/param-name&gt;
            &lt;param-value&gt;&lt;/param-value&gt;         
        &lt;/init-param&gt;   
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;equinoxbridgeservlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;
            /osgi/*
        &lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>

<h2>整合遇到的问题及解决</h2>

<p>由于struts的filter过滤了htm，导致osgi的htm文件被struts"劫"取了~~</p>

<p>经过一番挣扎，解决方法如下：</p>

<p>在struts过滤器中增加排除参数。</p>

<pre><code>  &lt;filter&gt;
    &lt;filter-name&gt;struts&lt;/filter-name&gt;
    &lt;filter-class&gt;
        org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;struts.action.excludePattern&lt;/param-name&gt;
        &lt;param-value&gt;/osgi/.*&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
</code></pre>

<h2>为啥怎么弄，解释如下：</h2>

<p><strong>1 读取init-param初始化参数excludedPatterns</strong></p>

<pre><code>    protected List&lt;Pattern&gt; excludedPatterns = null;

    public void init(FilterConfig filterConfig) throws ServletException {
        InitOperations init = new InitOperations();
        try {
            FilterHostConfig config = new FilterHostConfig(filterConfig);
            init.initLogging(config);
            Dispatcher dispatcher = init.initDispatcher(config);
            init.initStaticContentLoader(config, dispatcher);

            prepare = new PrepareOperations(filterConfig.getServletContext(), dispatcher);
            execute = new ExecuteOperations(filterConfig.getServletContext(), dispatcher);
            this.excludedPatterns = init.buildExcludedPatternsList(dispatcher); // 获取不被Struts处理的请求Regex模式

            postInit(dispatcher, filterConfig);
        } finally {
            init.cleanup();
        }

    }
</code></pre>

<p><strong> 2 使用excludedPatterns</strong></p>

<pre><code>    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) 
                        throws IOException, ServletException {
        //父类向子类转：强转为httpReq请求、httpResp响应
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        try {
            //。。。@@根据Regex模式(excludedPatterns)对请求进行处理
            if ( excludedPatterns != null &amp;&amp; prepare.isUrlExcluded(request, excludedPatterns)) {
                chain.doFilter(request, response);
            } else {
                request = prepare.wrapRequest(request);
                ActionMapping mapping = prepare.findActionMapping(request, response, true);
                if (mapping == null) {
                    boolean handled = execute.executeStaticResourceRequest(request, response);
                    if (!handled) {
                        chain.doFilter(request, response);
                    }
                } else {
                    execute.executeAction(request, response, mapping);
                }
            }
        } finally {
             prepare.cleanupRequest(request);
        }
    }
</code></pre>

<h2>后记</h2>

<p>其实SSH就是对请求进行过滤拦截转发！Struts提供了不处理请求配置罢了。</p>

<p>看到的其他实现：</p>

<pre><code>    // First cast ServletRequest to HttpServletRequest.
    HttpServletRequest hsr = (HttpServletRequest) request;

    // Check if requested resource is not in /test folder.
    if (!hsr.getServletPath().startsWith("/test/")) {
        // Not in /test folder. Do your thing here.
    }
</code></pre>

<p>web.xml中<url-pattern>的3种写法</p>

<ol>
<li>完全匹配 <url-pattern>/test/list.do</url-pattern></li>
<li>目录匹配 <url-pattern>/test/*</url-pattern></li>
<li>扩展名匹配 <url-pattern>*.do</url-pattern></li>
</ol>


<p>servlet-mapping的重要规则：</p>

<ul>
<li>容器会首先查找完全匹配，如果找不到，再查找目录匹配，如果也找不到，就查找扩展名匹配。</li>
<li>如果一个请求匹配多个“目录匹配”，容器会选择最长的匹配。</li>
</ul>


<h2>参考资源：</h2>

<ul>
<li><a href="http://ari.iteye.com/blog/829843">http://ari.iteye.com/blog/829843</a></li>
<li><a href="http://www.docjar.org/html/api/org/apache/struts2/dispatcher/ng/filter/StrutsPrepareAndExecuteFilter.java.html">http://www.docjar.org/html/api/org/apache/struts2/dispatcher/ng/filter/StrutsPrepareAndExecuteFilter.java.html</a></li>
<li><a href="http://selectshy.iteye.com/blog/1293458">servlet-mapping</a></li>
<li><a href="http://space.itpub.net/13750068/viewspace-493899">Struts2的工作原理</a></li>
<li><a href="http://stackoverflow.com/questions/3125296/can-i-exclude-some-concrete-urls-from-url-pattern-inside-filter-mapping">Can I exclude some concrete urls from <url-pattern> inside <filter-mapping>?</a></li>
<li><a href="http://stackoverflow.com/questions/3466897/filter-mapping-url-pattern-that-excludes-subdirectories">Filter mapping url-pattern that excludes subdirectories</a></li>
<li><a href="http://www.blogjava.net/liuspring/archive/2008/09/01/226073.html">http://www.blogjava.net/liuspring/archive/2008/09/01/226073.html</a></li>
<li><a href="http://tuckey.org/urlrewrite/">urlrewrite</a></li>
<li><a href="http://urlrewritefilter.googlecode.com/svn/trunk/src/doc/manual/4.0/index.html#filterparams">http://urlrewritefilter.googlecode.com/svn/trunk/src/doc/manual/4.0/index.html#filterparams</a></li>
</ul>


<hr />

<p><a href="http://winse.iteye.com/blog/1607884">【原文地址】</a></p>
]]></content>
  </entry>
  
</feed>
