<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Winse Blog]]></title>
  <link href="http://winseliu.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://winseliu.com/"/>
  <updated>2016-12-01T16:34:00+08:00</updated>
  <id>http://winseliu.com/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用ADT调试Xamarin程序中的Java库]]></title>
    <link href="http://winseliu.com/blog/2014/08/29/xamarin-application-use-adt-eclipse-debug-java-code/"/>
    <updated>2014-08-29T12:08:11+08:00</updated>
    <id>http://winseliu.com/blog/2014/08/29/xamarin-application-use-adt-eclipse-debug-java-code</id>
    <content type="html"><![CDATA[<p>在编写SDK的时刻，有用户需要使用Xamarin来开发应用。我们这边暂时没有这个方面的经验，有点瞎扯扯意味，路是崎岖的前进是痛苦的。</p>

<h2>封装Android-SDK</h2>

<p>Xamarin是使用C#语言来编写代码的，所以需要先把Android的jar库包装成为C#的代码。<a href="http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/">可选方式有3种</a>)，这里选用Wrapper的形式，不过多讲解，看文章<a href="http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/binding_a_java_library_(.jar">Binding a Java Library - Consuming .JARs from C#</a>/)。</p>

<p>建立Binding项目，把依赖的包加入到Jars目录下。由于Bmob-Android官方的包是进行混淆的，有些代码不会用到的/没有必要Wrapper生成jni代码调用的，可以通过removenote去掉不生成C#的wrapper类。第二点就是java的泛型是会被抹掉的，而C#的是会编入程序中的，遇到Comparable这种类型的方法时，需要进行参数强制转换下。第三点就是接口回调，有多个方法时会导致名称冲突，需要为每个接口的方法都配置一个Args的节点属性。这些都是官网的例子中有说明，有需要可以具体参考上面链接的文章内容。</p>

<pre><code>    &lt;metadata&gt;
        &lt;remove-node path="/api/package[@name='cn.bmob.im.db']" /&gt;

      &lt;attr path="/api/package[@name='cn.bmob.im.inteface']/interface[@name='DownloadListener']/method[@name='onError']" name="argsType"&gt;DownloadListenerErrorEventArgs&lt;/attr&gt;
    &lt;/metadata&gt;

    &lt;enum-method-mappings&gt;
      &lt;mapping jni-class="cn/bmob/im/bean/BmobRecent"&gt;
        &lt;method jni-name="compareTo" parameter="p0" clr-enum-type="Java.Lang.Object" /&gt;
      &lt;/mapping&gt;
      &lt;mapping jni-class="cn/bmob/im/BmobDownloadManager"&gt;
        &lt;method jni-name="doInBackground" parameter="p0" clr-enum-type="Java.Lang.Object[]" /&gt;
      &lt;/mapping&gt;
    &lt;/enum-method-mappings&gt;
</code></pre>

<p>还有另一个坑是，混淆后内部类会被扁平化，导致jar2xml执行时获取类的getSimpleName名称会抛异常，我这里直接反编译源码改成getName就好了，仅仅是代码中全路径和仅类名的却别，暂时来看没啥印象。</p>

<p>然后编译，加入到主项目的依赖中就可以使用该库的Java功能了。名称可能并不能全部对应上，与Java中的方法名和常量名大小写、下划线的不同罢了。</p>

<h2>调试</h2>

<p>下面是重点，但是很简短。</p>

<p>作为写SDK的，肯定不仅仅要用特定的工具，还的把中间的过程也扭顺，即既要做一个好点（example），又得实现连接的线（SDK）。</p>

<p>如果Android SDK的代码没有执行，该怎么办？Xamarin中都是C#的代码并不能用于调试java啊！问题自然归结到怎么用两个工具（Xamarin和Eclipse）来同时调试一个Xamarin Android应用的问题？！</p>

<p>先讲讲我遇到的坑，由于是开发者发给我的应用，不知道结构是怎么样的。我直接用Xamarin打开，是没有带可执行属性的，在Run-With菜单中是能看到我的实体机器的，但是就是不能把程序发布上去！提示【执行失败。未将对象引用设置到对象的实例。】然后就没了。最终在stackoverflow中找到了类型问题的解决方法，需要设置运行属性。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAAt6AVtg6AALZEEiP4tQ304.png" alt="" /></p>

<p>配置如下，在解决方案属性中【构建-配置-ConfigurationMappings】把项目添加为构建项。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAA4uAT9qmAAKI8-zKAn8494.png" alt="" /></p>

<p>可能还会遇到的问题是版本的问题，报错【java.lang.RuntimeException: Unable to get provider mono.MonoRuntimeProvider: java.lang.RuntimeException: Unable to find application Mono.Android.DebugRuntime or Mono.Android.Platform.ApiLevel_19!】需要在csproj的配置中修改AndroidUseLatestPlatformSdk属性为false。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAC4KAOV-HAAFU6knDvFQ527.png" alt="" /></p>

<p>下面的步骤才是本文的关键：</p>

<p>首先，在MainActivity的onCreate方法开始出打个断点，便于初始化功能调试，点击左上角的开始运行按钮。这样就能把代码发布到机器，且运行后会停留在onCreate处。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QACtCAHOqDAAELanVrybU938.png" alt="" /></p>

<p>Xamarin调试效果图</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QAC_yAYqbpAAHBQT48VSA253.png" alt="" /></p>

<p>再，打开ecilpse导入<code>obj\Debug\android</code>目录下的项目【Import-Android-Existing Android Code Into Workspace】，错误什么的无所谓。这个项目只是用了ADT能识别而已。然后再java包的代码里面打上断点。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QADTuAd3cyAACtJUn8Pdk976.png" alt="" /></p>

<p>最后，起到定乾坤作用的就是DDMS的Devices试图的小爬虫，选择你要调试的程序，然后点击它就可以了。切换到Xamarin继续运行程序，接下来就会运行停留到eclipse中的java包中的断点程序出。</p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QADnWAJQyIAABt1LtWjUA456.png" alt="" /></p>

<p><img src="http://file.bmob.cn/M00/0A/3C/wKhkA1QADueALec-AAEQhd4vxMY835.png" alt="" /></p>

<p>OK，接下来就按照eclipse的调试技巧弄就好了。</p>

<p>步骤很简单，查询的路子却是艰辛的。第一次尝试成本总是昂贵的，第二步自然会慢慢顺起来。fighting&hellip;</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查找逐步定位Java程序OOM的异常实践]]></title>
    <link href="http://winseliu.com/blog/2014/08/25/step-by-step-found-java-oom-error/"/>
    <updated>2014-08-25T21:12:13+08:00</updated>
    <id>http://winseliu.com/blog/2014/08/25/step-by-step-found-java-oom-error</id>
    <content type="html"><![CDATA[<p>类C语言，继C++之后的最辉煌耀眼的明星都属Java，其中最突出的又数内存管理。JVM对运行在其上的程序进行内存自动化分配和管理，减少开发人员的工作量之外便于统一的维护和管理。JDK提供了各种各样的工具来让开发实施人员了解运行的运行状态。</p>

<ul>
<li>jps -l -v -m</li>
<li>jstat -gcutil 2000 100</li>
<li>jmap</li>
<li>jinfo <a href="http://file.bmob.cn/M00/03/AD/wKhkA1PE2MGAB4-fAAGTqUeu-cE940.png">查看参数例子</a></li>
<li>jstack</li>
<li>jvisualvm/jconsole</li>
<li>mat(MemoryAnalyzer)</li>
<li>btrace</li>
<li>jclasslib（查看局部变量表）</li>
</ul>


<p>前段时间，接手(前面已经有成型的东西)使用Hadoop存储转换的项目，但是生产环境的程序总是隔三差五的OOM，同时使用的hive0.12.0也偶尔出现内存异常。这对于运维来说就是灭顶之灾！搞不好什么时刻程序就挂了！！必须咬咬牙把这个问题处理解决，开始把老古董们请出来，翻来基本不看的后半部分&ndash;Java内存管理。</p>

<ul>
<li>《Java程序性能优化-让你的Java程序更快、更稳定》第5章JVM调优/第6章Java性能调优工具</li>
<li>《深入理解Java虚拟机-JVM高级特性与最佳实践》第二部分自动内存管理机制</li>
</ul>


<p>这里用到的理论知识比较少。主要用Java自带的工具，加上内存堆分析工具（mat/jvisualvm）找出大对象，同时结合源代码定位问题。</p>

<p>下面主要讲讲实践，查找问题的思路。在本地进行测试的话，我们可以打断点，可以通过jvisualvm来查看整个运行过程内存的变化趋势图。但是到了linux服务器，并且还是生产环境的话，想要有本地一样的图形化工具来监控是比较困难的！一般服务器的内存都设置的比较大，而windows设置的内存又有限！所以内存达到1G左右，立马dump一个堆的内存快照然后下载到本地进行来分析（可以通过<code>-J-Xmx</code><a href="http://file.bmob.cn/M00/09/83/wKhkA1P7TV-ABDnOAAB-OnVBQic050.png">调整jvisualvm的内存</a>）。</p>

<ul>
<li>首先，由于报错是在Configuration加载配置文件时抛出OOM，第一反应肯定Configuraiton对象太多导致！同时查看dump的堆内存也佐证了这一点。直接把程序中的Configuration改成单例。</li>
</ul>


<p>程序对象内存占比排行（<code>jmap -histo PID</code>）：</p>

<p><img src="http://file.bmob.cn/M00/09/81/wKhkA1P7S8yARYSkAAiFW9cVN5w526.png" alt="" /></p>

<p>使用mat或者jvisualvm查看堆，确实Configuration对象过多（<code>jmap -dump:format=b,file=/tmp/bug.hprof PID</code>）：</p>

<p><img src="http://file.bmob.cn/M00/09/83/wKhkA1P7TbmAIdDEAAq3ktPBs6Q266.png" alt="" /></p>

<ul>
<li><p>修改后再次运行，但是没多大用！还是OOM！！</p></li>
<li><p>进一步分析，发现在Configuration中的属性/缓冲的都是弱引用是weakhashmap。</p></li>
</ul>


<p><img src="http://file.bmob.cn/M00/09/83/wKhkA1P7TfaAf4nwAAbcdgFiyXs804.png" alt="" /></p>

<p>OOM最终问题不在Configuration对象中的属性，哪谁hold住了Configuration对象呢？？</p>

<ul>
<li>再次从根源开始查找问题。程序中FileSystem对象使用<code>FileSystem.get(URI, Configuration, String)</code>获取，然后调用<code>get(URI,Configuration)</code>方法，其中的<strong>CACHE</strong>很是刺眼啊！</li>
</ul>


<p><img src="http://file.bmob.cn/M00/09/8D/wKhkA1P72pmAAMdnAAEYMjHFUAI853.png" alt="" /></p>

<p>缓冲FileSystem的Cache对象的Key是URI和UserGroupInformation两个属性来判断是否相等的。对于一个程序来说一般就读取一个HDFS的数据即URI前部分是确定的，重点在UserGroupInformation是通过<code>UserGroupInformation.getCurrentUser()</code>来获取的。</p>

<p>即获取在get时<code>UserGroupInformation.getBestUGI</code>得到的对象。而这个对象在UnSecure情况下每次都是调用<code>createRemoteUser</code>创建新的对象！也就是每调用一次<code>FileSystem.get(URI, Configuration, String)</code>就会缓存一个FileSystem对象，以及其hold住的Configuration都会被保留在内存中。
<img src="http://file.bmob.cn/M00/09/82/wKhkA1P7TBSAaYEoAAhzUA5j5MI991.png" alt="" /></p>

<p><img src="http://file.bmob.cn/M00/09/82/wKhkA1P7TJ2AfwJzAAhEVFjK7Ek367.png" alt="" /></p>

<p>只消耗不释放终究会坐吃山空啊！到最后也就必然OOM了。从mat的UserGroupInformation的个数查询，以及Cache对象的总量可以印证。</p>

<p><img src="http://file.bmob.cn/M00/09/82/wKhkA1P7TNeAB7JAAAdMg-udeR8285.png" alt="" /></p>

<p><img src="http://file.bmob.cn/M00/09/83/wKhkA1P7TU-ACoaCAApK4n-52hI027.png" alt="" /></p>

<h2>问题处理</h2>

<p>把程序涉及到FileSystem.get调用去掉user参数，使两个参数的方法。由于都使用getCurrentUser获取对象，也就是说程序整个运行过程中就一个FileSystem对象，但是与此同时就不能关闭获取到的FileSystem，如果当前运行的用户与集群所属用户不同，需要设置环境变量指定当前操作的用户！</p>

<pre><code>System.setProperty("HADOOP_USER_NAME", "hadoop");
</code></pre>

<p>查找代码中调用了FileSystem#close是一个痛苦的过程，由于FileSystem实现的是Closeable的close方法，用<strong>Open Call Hierarchy</strong>基本是大海捞中啊，根本不知道那个代码是自己的！！这里用btrace神器让咋也高大上一把。。。</p>

<p>当时操作的步骤找不到了，下图是调用Cache#getInternal方法监控代码<a href="https://gist.github.com/winse/161f6fe9120f2ec6b024">GIST</a>：</p>

<p><img src="http://file.bmob.cn/M00/09/84/wKhkA1P7UD2AFk2cAAXRQWzniL0296.png" alt="" /></p>

<h2>hive0.12内存溢出问题</h2>

<p>hive0.12.0查询程序MR内容溢出</p>

<p><img src="http://file.bmob.cn/M00/09/81/wKhkA1P7StSAOgX1AAoW9v-Fd4s439.png" alt="" /></p>

<p>在hive-0.13前官网文档中有提到内存溢出这一点，可以对应到FileSystem中代码的判断。</p>

<p><img src="http://file.bmob.cn/M00/09/85/wKhkA1P7UP-ACRVdAAJHBKNTq94580.png" alt="" /></p>

<pre><code>    String disableCacheName = String.format("fs.%s.impl.disable.cache", scheme);
    if (conf.getBoolean(disableCacheName, false)) {
      return createFileSystem(uri, conf);
    }
</code></pre>

<p>hive0.13.1处理</p>

<p><img src="http://file.bmob.cn/M00/09/84/wKhkA1P7T_CAcxVqAARr7CGiDvY177.png" alt="" /></p>

<p><img src="http://file.bmob.cn/M00/09/84/wKhkA1P7T6KAKoUiAAvODPwh1po815.png" alt="" /></p>

<p>新版本在每次查询（session）结束后都会把本次涉及到的FileSystem关闭掉。</p>

<p><img src="http://file.bmob.cn/M00/09/84/wKhkA1P7T9uAQQB3AAWrj_efwZU495.png" alt="" /></p>

<h2>理论知识</h2>

<p>从GC类型开始讲，对自动化内存的垃圾收集有个整体的感知： 新生代/s0（survivor space0、from space）/s1（survivor space1、to space）/永久代。虚拟机参数<code>-Xmx</code>,<code>-Xms</code>,<code>-Xmn</code>（<code>-Xss</code>）来调节各个代的大小和比例。</p>

<ul>
<li><code>-Xss</code> 参数来设置栈的大小。栈的大小直接决定了函数的调用可达深度</li>
<li><code>-XX:PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -Xms40m -Xmx40m -Xmn20m</code></li>
<li><code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code></li>
<li><code>-XX:NewRatio</code>和<code>-XX:SurvivorRatio</code></li>
<li><code>-XX:PermSize=2m -XX:MaxPermSize=4m -XX:+PrintGCDetails</code></li>
<li><code>-verbose:gc</code></li>
<li><code>-XX:+PrintGC</code></li>
<li><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/bug.hprof -XX:OnOutOfMemoryError=/reset.sh</code></li>
<li><code>jmap -dump:format=b,file=/tmp/bug.hprof PID</code></li>
<li><code>jmap -histo PID &gt; /tmp/s.txt</code></li>
<li><code>jstack -l PID</code></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[巧用Equals和Hashcode]]></title>
    <link href="http://winseliu.com/blog/2014/08/20/magical-use-java-equals-hashcode/"/>
    <updated>2014-08-20T11:03:54+08:00</updated>
    <id>http://winseliu.com/blog/2014/08/20/magical-use-java-equals-hashcode</id>
    <content type="html"><![CDATA[<p>java中让人疑惑的一点就是等于的判断，有使用<code>==</code>和<code>equals</code>， 有一些专门字符串初始化的资料来考你在是否已经真正的掌握判断两个对象是否一致。</p>

<p>同时，在重写equals时很多资料都强调要重写hashcode。</p>

<p>java中HashMap就是基于equals和hashcode来实现拉链的键值对。Map中存储了entry&lt;K,V>的数组，数组的下标是基于对象的hashcode再对entry长度[并]<code>&amp;</code>的结果。</p>

<p><img src="http://file.bmob.cn/M00/08/55/wKhkA1P0OO-AE9u3AABNzQK0pr8747.png" alt="" /></p>

<p>使用set/map来实现集合，并且对象重写了equals但没有重写hashcode的情况下，得到的结果与你臆想的不同。同时，在特定场景结合hashcode和equals可以实现很酷的效果。</p>

<ul>
<li>第一个例子A 重写了equals但是没有重写hashcode(ERROR)，此时判断元素是否在集合中结果可能并不是你想要的。</li>
<li>第二个B的例子 重写hashcode和equals对应后就正确了。</li>
<li>第三个AA是个很酷的例子 equals的条件更强，可以实现类似<code>map&lt;string, list&lt;string&gt;&gt;</code>的效果。</li>
</ul>


<pre><code>    static class A {

        String name;
        int age;

        public A(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public boolean equals(Object obj) {
            return new EqualsBuilder().append(getClass(), obj.getClass()).append(name, ((A) obj).name).isEquals();
        }

    }

    @Test
    public void testA() {
        Set&lt;A&gt; set = new HashSet&lt;&gt;();

        set.add(new A("abc", 12));
        set.add(new A("abc", 14));

        System.out.println(set.size());

        System.out.println(set.contains(new A("abc", 0)));
    }

    static class B extends A {

        public B(String name, int age) {
            super(name, age);
        }

        @Override
        public int hashCode() {
            return this.name.hashCode();
        }
    }

    @Test
    public void testB() {
        /* Set&lt;A&gt; */Set&lt;B&gt; set = new HashSet&lt;&gt;();

        set.add(new B("abc", 12));
        set.add(new B("abc", 14));

        System.out.println(set.size());

        System.out.println(set.contains(new B("abc", 0)));
    }

    static class AA extends A {
        public AA(String name, int age) {
            super(name, age);
        }

        @Override
        public boolean equals(Object obj) {
            return new EqualsBuilder().append(getClass(), obj.getClass()).append(name, ((A) obj).name)
                    .append(age, ((A) obj).age).isEquals();
        }

        @Override
        public int hashCode() {
            return this.name.hashCode();
        }
    }

    @Test
    public void testAA() {
        // 实现Map&lt;String, Set&lt;String&gt;&gt;的效果
        Set&lt;AA&gt; set = new HashSet&lt;&gt;();

        set.add(new AA("abc", 12));
        set.add(new AA("abc", 14));

        System.out.println(set.size());

        System.out.println(set.contains(new AA("abc", 0)));
    }
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="http://java.chinaitlab.com/base/879319.html">java中HashMap详解</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Win编译32位openjdk]]></title>
    <link href="http://winseliu.com/blog/2014/07/21/build-openjdk/"/>
    <updated>2014-07-21T14:23:57+08:00</updated>
    <id>http://winseliu.com/blog/2014/07/21/build-openjdk</id>
    <content type="html"><![CDATA[<p>win编译32位openjdk7u60:</p>

<p><div><script src='https://gist.github.com/3e6b42012dfb228a5b02.js?file=OpenJDK-Build-README.md'></script>
<noscript><pre><code>## 编译jdk7u60过程中的注意点: 

0. 先看目录下的README-builds.html，不要太认真看个大概就行
1. 下载最新的Microsoft DirectX SDK，安装时路径不要带括号
2. 安装procps代替free.exe(检查可用内存是会用到，没有应该也可以就是多个警告而已)
3. cygwin-make的版本问题，使用3.81 [snapshot](http://farm6.staticflickr.com/5486/14325549816_da7343282b_o.png)
4. VS2010的cl命令显示的信息一直是中文的话，需要修改源码跳过版本号的检查 [snapshot](http://farm3.staticflickr.com/2928/14162188587_7874083086_o.png)
5. 语言问题，导致编译corba失败！而后面有需要用到这个工程！ [snapshot](http://farm3.staticflickr.com/2936/14347140552_0f29391905_o.png)
6. PATH顺序问题，link.exe和find.exe [snapshot](http://farm6.staticflickr.com/5483/14347108132_9abdac5ae8_o.png)
7. 编译时间有点长！ [snapshot](http://farm4.staticflickr.com/3867/14162097680_40d5f69561_o.png) [java-version](http://farm4.staticflickr.com/3881/14162098450_7e86bd5b0b_o.png)
8. 默认的make不带调试信息的，需要用`make fastdebug_build`。

## 步骤：

1、 下载

可以的话，通过cygwin的setup.exe安装mercurial也行。

* hg: &lt;http://tortoisehg.bitbucket.org/download/index.html&gt;
* source: http://hg.openjdk.java.net/jdk7u/jdk7u60/

```
cd E:
cd git/
mkdir openjdk
cd openjdk/

HG_HOME=/cygdrive/c/Program\ Files/TortoiseHg/
PATH=$PATH:$HG_HOME

hg clone http://hg.openjdk.java.net/jdk7u/jdk7u60/
cd jdk7u60/
ls
./get_source.sh
```

2、 安装依赖软件

* jdk1.7.0_02/apache-ant-1.9.0
* Visual Studio2010
* Cygwin
  * 按照README-builds.html#cygwin，能找的必须安装，找不到的随意。
  * 安装procps，包括了free.exe。
  * 安装binutils，包括了ar.exe。
  * 替换[make.exe](http://www.cmake.org/files/cygwin/make.exe), 添加[cygintl-3.dll](http://www.opendll.com/dll/c/__32-cygintl-3.dll.zip)。
* 下载解压[freetype](http://jaist.dl.sourceforge.net/project/gnuwin32/freetype/2.3.5-1/freetype-2.3.5-1-bin.zip) 
  * 把bin目录下的freetype6.dll文件拷贝到../lib/freetype.dll
  * 添加[zlib1.dll](http://75.duote.org/win_dll/zlib1.zip) 也可以下载[安装版本](http://jaist.dl.sourceforge.net/project/gnuwin32/freetype/2.3.5-1/)包括了zlib1.dll
  * [snapshot](http://farm4.staticflickr.com/3922/14162193337_65d281fc73_o.png)
* 下载安装[Microsoft DirectX](http://download.microsoft.com/download/F/1/7/F178BCE4-FA19-428F-BB60-F3DEE1130BFA/DXSDK_Feb10.exe)
  * 安装路径不要带括号 

3、 配置环境

* 切换为英文语言环境，当你重新启动看到的是【Welcome】的时刻说明你修改成功了！重启后记得make clean再进行后面的操作！
 * Windows7安装更新，添加英文语言包
* 环境变量的所有路径最好是/ 而不是\，不能带双引号（否则中间编译的时刻会遇到问题）[snapshot](http://farm4.staticflickr.com/3862/14162030769_8766efa9a5_o.png)
* PATH路径顺序的问题，cygwin/bin放在vs的后面，但需要放在windows的前面。link.exe和find.exe的问题

如果是在X64机器上编译，需要加ARCH_DATA_MODEL的参数。参见【README-builds.html#creating】

## 参考：

* 【膜拜】[openjdk windows 编译](http://blog.csdn.net/instruder/article/details/8834117)
* 【有点老，不过注意事项还是相同的】 [自己动手编译Windows版的OpenJDK 7](http://icyfenix.iteye.com/blog/1097344) 
* 【linux下安装】&lt;http://khotyn.iteye.com/blog/1225348&gt;
* 【cl版本问题，以及make程序问题】&lt;http://www.myexception.cn/program/779678.html&gt;
* 【emitPermissionCheck问题】&lt;http://mail.openjdk.java.net/pipermail/jdk6-dev/2013-November/003104.html&gt; &lt;http://comments.gmane.org/gmane.comp.java.openjdk.jdk6.devel/976&gt;</code></pre></noscript></div>
</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java反编译工具使用记录]]></title>
    <link href="http://winseliu.com/blog/2013/10/24/java-decompiler-tools/"/>
    <updated>2013-10-24T20:20:00+08:00</updated>
    <id>http://winseliu.com/blog/2013/10/24/java-decompiler-tools</id>
    <content type="html"><![CDATA[<h2>工具</h2>

<ul>
<li><a href="http://varaneckas.com/jad/">jad</a></li>
<li><a href="http://jd.benow.ca/">JD-core</a></li>
<li>参考 <a href="http://zhouliang.pro/2010/06/26/jad/">http://zhouliang.pro/2010/06/26/jad/</a></li>
</ul>


<h2>差异</h2>

<p>JD-Core还是比较与时俱进的，对泛型/foreach等新的语法都支持。Jad则只支持到only 45.3(1.1), 46.0 and 47.0(1.3)。  <br/>
任何事物都不是完美的，结合两个工具来看反编译后的源码能更好的回归源码的真相。</p>

<ul>
<li>JD-Core解析双for循环是存在问题！结合jad可能更好的明白源码。</li>
<li>内部类解析<strong>都</strong>不够好，JD-Core相对错误少一些</li>
</ul>


<h2>对比</h2>

<p>这里就[for循环]/[双层for循环]/[内部类]进行对比。</p>

<h3>单for循环</h3>

<p><strong>源码</strong></p>

<pre><code>List&lt;String&gt; list = Arrays.asList("abc", "bcd");

public void testForEach() {
    for (String ele : list) { // for编译成字节码后使用iterator的形式
        System.out.println(ele);
    }
}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>List&lt;String&gt; list = Arrays.asList(new String[] { "abc", "bcd" });

public void testForEach() {
for (String ele : this.list)
    System.out.println(ele);
}
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public JavaDecompilerTest()
{
    list = Arrays.asList(new String[] {
        "abc", "bcd"
    });
}

public void testForEach()
{
    String ele;
    for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(ele))
        ele = (String)iterator.next();

}

List list;
</code></pre>

<h3>双层for循环</h3>

<p><strong>源码</strong></p>

<pre><code>List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
{
    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    map.put("12", "23");
    list.add(map);
}

public void testForIndex() {
    for (int i = 0; i &lt; list.size(); i++) {
        Map&lt;String, String&gt; map = list.get(i);
        for (String key : map.keySet())
            System.out.println(map.get(key));
    }
}

public void testForEach() {
    for (Map&lt;String, String&gt; map : list) {
        for (String key : map.keySet())
            System.out.println(map.get(key));
    }
}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>  List&lt;Map&lt;String, String&gt;&gt; list;

  public JavaDecompilerTest2()
  {
    this.list = new ArrayList();

    Map map = new HashMap();
    map.put("12", "23");
    this.list.add(map);
  }

  public void testForIndex() {
    for (int i = 0; i &lt; this.list.size(); i++) {
      Map map = (Map)this.list.get(i);
      for (String key : map.keySet())
        System.out.println((String)map.get(key));
    }
  }

  public void testForEach()
  {
    Iterator localIterator2;
    for (Iterator localIterator1 = this.list.iterator(); localIterator1.hasNext(); 
      localIterator2.hasNext())
    {
      Map map = (Map)localIterator1.next();
      localIterator2 = map.keySet().iterator(); continue; String key = (String)localIterator2.next();
      System.out.println((String)map.get(key));
    }
  }
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public JavaDecompilerTest2()
{
    list = new ArrayList();
    Map map = new HashMap();
    map.put("12", "23");
    list.add(map);
}

public void testForIndex()
{
    for(int i = 0; i &lt; list.size(); i++)
    {
        Map map = (Map)list.get(i);
        String key;
        for(Iterator iterator = map.keySet().iterator(); iterator.hasNext(); System.out.println((String)map.get(key)))
            key = (String)iterator.next();

    }

}

public void testForEach()
{
    for(Iterator iterator = list.iterator(); iterator.hasNext();)
    {
        Map map = (Map)iterator.next();
        String key;
        for(Iterator iterator1 = map.keySet().iterator(); iterator1.hasNext(); System.out.println((String)map.get(key)))
            key = (String)iterator1.next();

    }

}

List list;
</code></pre>

<h3>内部类</h3>

<p><strong>源码</strong></p>

<pre><code>public class JavaDecompilerTest3 {

    private class Test2 {}

    Test2 test = new Test2();

}
</code></pre>

<p><strong>JD-Core v0.3.5 JD-GUI v0.6.2</strong></p>

<pre><code>public class JavaDecompilerTest3
{
  JavaDecompilerTest3.Test2 test = new JavaDecompilerTest3.Test2(null);

  private class Test2
  {
    private Test2()
    {
    }
  }
}
</code></pre>

<p><strong>Jad v1.5.8e2.</strong></p>

<pre><code>public class JavaDecompilerTest3
{
    private class Test2
    {

        final JavaDecompilerTest3 this$0;

        private Test2()
        {
            this$0 = JavaDecompilerTest3.this;
            super();
        }

        Test2(Test2 test2)
        {
            this();
        }
    }


    public JavaDecompilerTest3()
    {
        test = new Test2(null);
    }

    Test2 test;
}
</code></pre>

<h2>后记</h2>

<p>工具javap可以查看class的方法签名，通过jd-gui和jad可以反编译得到源码，如果代码没有混淆的话，多半就能了解代码的功能了。</p>

<h2>读jdk7的try-resource的字节码</h2>

<p>先了解下字节码的规范：<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html">Compiling for the Java Virtual Machine</a></p>

<pre><code>$ javap -public -c -v ByteCodeTest.class
Classfile /E:/test/target/test-classes/com/ByteCodeTest.class
  Last modified 2016-5-6; size 992 bytes
  MD5 checksum ee7912d638a98f9a4a61d726e08c08f0
  Compiled from "ByteCodeTest.java"
public class com.ByteCodeTest
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Class              #2             // com/ByteCodeTest
   #2 = Utf8               com/ByteCodeTest
   #3 = Class              #4             // java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Methodref          #3.#9          // java/lang/Object."&lt;init&gt;":()V
   #9 = NameAndType        #5:#6          // "&lt;init&gt;":()V
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/ByteCodeTest;
  #14 = Utf8               tryResourceWithFinally
  #15 = Utf8               Exceptions
  #16 = Class              #17            // java/io/FileNotFoundException
  #17 = Utf8               java/io/FileNotFoundException
  #18 = Class              #19            // java/io/IOException
  #19 = Utf8               java/io/IOException
  #20 = Utf8               RuntimeVisibleAnnotations
  #21 = Utf8               Lorg/junit/Test;
  #22 = Class              #23            // java/io/FileInputStream
  #23 = Utf8               java/io/FileInputStream
  #24 = String             #25            //
  #25 = Utf8
  #26 = Methodref          #22.#27        // java/io/FileInputStream."&lt;init&gt;":(Ljava/lang/String;)V
  #27 = NameAndType        #5:#28         // "&lt;init&gt;":(Ljava/lang/String;)V
  #28 = Utf8               (Ljava/lang/String;)V
  #29 = Fieldref           #30.#32        // java/lang/System.out:Ljava/io/PrintStream;
  #30 = Class              #31            // java/lang/System
  #31 = Utf8               java/lang/System
  #32 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;
  #33 = Utf8               out
  #34 = Utf8               Ljava/io/PrintStream;
  #35 = String             #36            // ing
  #36 = Utf8               ing
  #37 = Methodref          #38.#40        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #38 = Class              #39            // java/io/PrintStream
  #39 = Utf8               java/io/PrintStream
  #40 = NameAndType        #41:#28        // println:(Ljava/lang/String;)V
  #41 = Utf8               println
  #42 = Methodref          #43.#45        // java/io/InputStream.close:()V
  #43 = Class              #44            // java/io/InputStream
  #44 = Utf8               java/io/InputStream
  #45 = NameAndType        #46:#6         // close:()V
  #46 = Utf8               close
  #47 = Methodref          #48.#50        // java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V
  #48 = Class              #49            // java/lang/Throwable
  #49 = Utf8               java/lang/Throwable
  #50 = NameAndType        #51:#52        // addSuppressed:(Ljava/lang/Throwable;)V
  #51 = Utf8               addSuppressed
  #52 = Utf8               (Ljava/lang/Throwable;)V
  #53 = Utf8               in
  #54 = Utf8               Ljava/io/InputStream;
  #55 = Utf8               StackMapTable
  #56 = Utf8               SourceFile
  #57 = Utf8               ByteCodeTest.java
{
  public com.ByteCodeTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #8                  // Method java/lang/Object."&lt;init&gt;":()V
         4: return
      LineNumberTable:
        line 10: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/ByteCodeTest;

  public void tryResourceWithFinally() throws java.io.FileNotFoundException, java.io.IOException;
    descriptor: ()V
    flags: ACC_PUBLIC
    Exceptions:
      throws java.io.FileNotFoundException, java.io.IOException
    RuntimeVisibleAnnotations:
      0: #21()
    Code:
      stack=3, locals=4, args_size=1
         0: aconst_null
         1: astore_1
         2: aconst_null
         3: astore_2
         4: new           #22                 // class java/io/FileInputStream
         7: dup
         8: ldc           #24                 // String
        10: invokespecial #26                 // Method java/io/FileInputStream."&lt;init&gt;":(Ljava/lang/String;)V
        13: astore_3
        14: getstatic     #29                 // Field java/lang/System.out:Ljava/io/PrintStream;
        17: ldc           #35                 // String ing
        19: invokevirtual #37                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        22: aload_3
        23: ifnull        66
        26: aload_3
        27: invokevirtual #42                 // Method java/io/InputStream.close:()V
        30: goto          66
        33: astore_1
        34: aload_3
        35: ifnull        42
        38: aload_3
        39: invokevirtual #42                 // Method java/io/InputStream.close:()V
        42: aload_1
        43: athrow
        44: astore_2
        45: aload_1
        46: ifnonnull     54
        49: aload_2
        50: astore_1
        51: goto          64
        54: aload_1
        55: aload_2
        56: if_acmpeq     64
        59: aload_1
        60: aload_2
        61: invokevirtual #47                 // Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V
        64: aload_1
        65: athrow
        66: return
      Exception table:
         from    to  target type
            14    22    33   any
             4    44    44   any
      LineNumberTable:
        line 14: 0
        line 15: 14
        line 16: 22
        line 17: 66
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      67     0  this   Lcom/ByteCodeTest;
           14      28     3    in   Ljava/io/InputStream;
      StackMapTable: number_of_entries = 6
        frame_type = 255 /* full_frame */
          offset_delta = 33
          locals = [ class com/ByteCodeTest, class java/lang/Throwable, class java/lang/Throwable, class java/io/InputStream ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 8
        frame_type = 65 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
        frame_type = 9 /* same */
        frame_type = 9 /* same */
        frame_type = 249 /* chop */
          offset_delta = 1
}
SourceFile: "ByteCodeTest.java"


  public void tryResourceWithFinally() throws FileNotFoundException, IOException {
    try (InputStream in = new FileInputStream("")) {
      System.out.println("ing");
    }
  }
</code></pre>

<p>异常eclipse提示啥直接抛出来，不要 <code>throws Exception</code> ，不然前面的 astore_1/astore_2 你就看不懂了！！！</p>

<ul>
<li><code>Code #NUM</code> ：（ldc #53）后面的 #NUM 表示常量池里面的对象。</li>
<li><code>dup</code> : init方法没有返回值，所以需要压两次栈， <a href="http://stackoverflow.com/questions/12438567/java-bytecode-dup">http://stackoverflow.com/questions/12438567/java-bytecode-dup</a></li>
<li><code>LocalVariableTable</code> : start-length作用域，slot存储单元，<a href="http://hllvm.group.iteye.com/group/topic/25858">http://hllvm.group.iteye.com/group/topic/25858</a></li>
</ul>


<p>解析：要看懂try-catch-finally，必须关注 <strong>Exception table</strong> ！</p>

<pre><code>any a1 = null
any a2 = null
any a3/in = new FileInputStream("")

System.out.println("ing")

    catch-1(33):
    // noop
    if(a3/in != null){
    in.close()
    }
    rethrow a1

if(a3/in != null){
in.close()
}

catch-2(44):
// noop
if(a3/in != null){
in.close()
}
if(a1 == null){
  // noop
  a1 = a2
  rethrow a1
} 

if (a1 == a2){
  rethrow a1
} 

a1.addSuppressed(a2)
rethrow a1
</code></pre>

<p>在添加自定义的finally：</p>

<pre><code>$ javap -public -c ByteCodeTest.class
Compiled from "ByteCodeTest.java"
public class com.ByteCodeTest {
  public com.ByteCodeTest();
    Code:
       0: aload_0
       1: invokespecial #8                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return

  public void tryResourceWithFinally() throws java.io.FileNotFoundException, java.io.IOException;
    Code:
       0: aconst_null
       1: astore_1
       2: aconst_null
       3: astore_2
       4: new           #22                 // class java/io/FileInputStream
       7: dup
       8: ldc           #24                 // String
      10: invokespecial #26                 // Method java/io/FileInputStream."&lt;init&gt;":(Ljava/lang/String;)V
      13: astore_3
      14: getstatic     #29                 // Field java/lang/System.out:Ljava/io/PrintStream;
      17: ldc           #35                 // String ing
      19: invokevirtual #37                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      22: aload_3
      23: ifnull        79
      26: aload_3
      27: invokevirtual #42                 // Method java/io/InputStream.close:()V
      30: goto          79
      33: astore_1
      34: aload_3
      35: ifnull        42
      38: aload_3
      39: invokevirtual #42                 // Method java/io/InputStream.close:()V
      42: aload_1
      43: athrow
      44: astore_2
      45: aload_1
      46: ifnonnull     54
      49: aload_2
      50: astore_1
      51: goto          64
      54: aload_1
      55: aload_2
      56: if_acmpeq     64
      59: aload_1
      60: aload_2
      61: invokevirtual #47                 // Method java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V
      64: aload_1
      65: athrow
      66: astore        4
      68: getstatic     #29                 // Field java/lang/System.out:Ljava/io/PrintStream;
      71: ldc           #53                 // String finish
      73: invokevirtual #37                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      76: aload         4
      78: athrow
      79: getstatic     #29                 // Field java/lang/System.out:Ljava/io/PrintStream;
      82: ldc           #53                 // String finish
      84: invokevirtual #37                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      87: return
    Exception table:
       from    to  target type
          14    22    33   any
           4    44    44   any
           0    66    66   any
}


  public void tryResourceWithFinally() throws FileNotFoundException, IOException {
    try (InputStream in = new FileInputStream("")) {
      System.out.println("ing");
    } finally {
      System.out.println("finish");
    }
  }
</code></pre>

<p>在异常表里面多了一条记录，比上面的复杂点。</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
</feed>
