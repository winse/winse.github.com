<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Winse Blog]]></title>
  <link href="http://winse.github.io/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://winse.github.io/"/>
  <updated>2023-03-26T00:12:09+08:00</updated>
  <id>http://winse.github.io/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[重新折腾raspberry2]]></title>
    <link href="http://winse.github.io/blog/2023/03/25/reinstall-raspberry2/"/>
    <updated>2023-03-25T21:24:35+08:00</updated>
    <id>http://winse.github.io/blog/2023/03/25/reinstall-raspberry2</id>
    <content type="html"><![CDATA[<p>买了新的raspberry4后，就没怎么去弄旧的树莓派2了，今天再次看到想着运行起来看看，插上电源后，一直亮着绿灯，然后就没其他反应了。</p>

<p>树莓派2有点旧，现在直接拿着新的手机充电器去接的时刻，一直起不来，刚开始是怀疑是用TTL接错线导致板子烧了，也没有显示器查看界面。</p>

<p>后面想着重新安装一下试试，然后拿着去接网线有线网络，这样就拿了一个旧的充电器的头。没想到这个时刻电源指示灯尽然闪起来了。想来这可能是电流过载保护了。</p>

<p>问题解决了，也把最新的重新安装的记录一下。</p>

<h2>安装</h2>

<p>参考：
* <a href="https://www.raspberrypi.com/documentation/computers/getting-started.html#installing-the-operating-system">Setting up your Raspberry Pi</a></p>

<h3>安装系统</h3>

<p>1 打开 <a href="https://www.raspberrypi.com/software/">Raspberry Pi Imager</a> 下载并安装，然后把SD card插入电脑。</p>

<p><img src="/images/blogs/rasp2/rasp2-1.png" alt="" /></p>

<p>2 设置初始化 用户和密码，并默认打开ssh服务（新版本已经去掉默认用户了，所以要设置一下 <a href="https://www.raspberrypi.com/news/raspberry-pi-bullseye-update-april-2022/">An update to Raspberry Pi OS Bullseye</a> ）</p>

<p><img src="/images/blogs/rasp2/rasp2-2.png" alt="" /></p>

<p>3 选择操作系统</p>

<p><img src="/images/blogs/rasp2/rasp2-3-1.png" alt="" /></p>

<p><img src="/images/blogs/rasp2/rasp2-3-2.png" alt="" /></p>

<p>4 连上有线网络，接通电源。然后打开路由管理界面，查看raspberry的ip地址</p>

<p><img src="/images/blogs/rasp2/rasp2-4-0.png" alt="" /></p>

<p>5 用ssh连接服务器</p>

<p><img src="/images/blogs/rasp2/rasp2-4-1.png" alt="" /></p>

<h3>配置Wifi网络</h3>

<p>原来已经买了usb的无线网卡，用 <code>ifconfig</code> 也能查看到 <code>wlan0</code> 的接口。</p>

<pre><code>root@raspberrypi:~# apt install vim 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
  libgpm2 vim-runtime
Suggested packages:
  gpm ctags vim-doc vim-scripts
The following NEW packages will be installed:
  libgpm2 vim vim-runtime
0 upgraded, 3 newly installed, 0 to remove and 0 not upgraded.
...
update-alternatives: using /usr/bin/vim.basic to provide /usr/bin/vim (vim) in auto mode
update-alternatives: using /usr/bin/vim.basic to provide /usr/bin/vimdiff (vimdiff) in auto mode
update-alternatives: using /usr/bin/vim.basic to provide /usr/bin/rvim (rvim) in auto mode
update-alternatives: using /usr/bin/vim.basic to provide /usr/bin/rview (rview) in auto mode
update-alternatives: using /usr/bin/vim.basic to provide /usr/bin/vi (vi) in auto mode
update-alternatives: using /usr/bin/vim.basic to provide /usr/bin/view (view) in auto mode
update-alternatives: using /usr/bin/vim.basic to provide /usr/bin/ex (ex) in auto mode
Processing triggers for man-db (2.9.4-2) ...
Processing triggers for libc-bin (2.31-13+rpt2+rpi1+deb11u5) ...

root@raspberrypi:~# echo "set mouse-=a" &gt;&gt;~/.vimrc
root@raspberrypi:~# vim /etc/wpa_supplicant/wpa_supplicant.conf    
root@raspberrypi:~# 


root@raspberrypi:~# iwlist wlan0 scan

# 算一个加密的配置
root@raspberrypi:~# wpa_passphrase winse
# reading passphrase from stdin
xxx
network={
        ssid="winse"
        #psk="xxx"
        psk=xxx
}

root@raspberrypi:~# cat /etc/wpa_supplicant/wpa_supplicant.conf   
country=CN
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
        ssid="winse"
        #psk="xxx"
        psk=xxx
}


# 配置服务
pi@raspberrypi:~ $ cat /lib/systemd/system/wpa_supplicant.service 
[Unit]
Description=WPA supplicant
Before=network.target
After=dbus.service
Wants=network.target
IgnoreOnIsolate=true

[Service]
#Type=dbus
#BusName=fi.w1.wpa_supplicant1
Type=forking
ExecStart=/sbin/wpa_supplicant -u -s -O /run/wpa_supplicant -c /etc/wpa_supplicant/wpa_supplicant.conf -i wlan0 -B -D wext
Restart=always

[Install]
WantedBy=multi-user.target
#Alias=dbus-fi.w1.wpa_supplicant1.service
pi@raspberrypi:~ $ cat /etc/systemd/system/dhclient.service 
[Unit]
Description= DHCP Client
Before=network.target

[Service]
Type=forking
ExecStart=/sbin/dhclient wlan0 -v
ExecStop=/sbin/dhclient wlan0 -r
Restart=always

[Install] 
WantedBy=multi-user.target
pi@raspberrypi:~ $ 

root@raspberrypi:~# systemctl daemon-reload 

root@raspberrypi:~# systemctl stop NetworkManager
root@raspberrypi:~# systemctl enable wpa_supplicant.service 
root@raspberrypi:~# systemctl enable dhclient.service
Created symlink /etc/systemd/system/multi-user.target.wants/dhclient.service → /etc/systemd/system/dhclient.service.
</code></pre>

<p>配置好后，重启服务器，再次查看路由器管理web界面：</p>

<p><img src="/images/blogs/rasp2/rasp2-5.png" alt="" /></p>

<p>然后再把网线拔掉，再重启一次确认一下。</p>

<h3>遇到的问题：</h3>

<p>1 <a href="https://zhuanlan.zhihu.com/p/136463580">https://zhuanlan.zhihu.com/p/136463580</a></p>

<pre><code>如果树莓派系统使用的是Raspbian Stretch，则ifup命令可能不起作用，可能会收到一条错误消息，
内容如下：“ ifdown：unknown interface wlan0 ”。可以使用以下任何命令来解决：
sudo ifconfig wlan0 up
</code></pre>

<p>2 <a href="https://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html">https://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html</a></p>

<pre><code>说明以及不同安全性的 WiFi 配置示例：
#ssid:网络的ssid
#psk:密码
#priority:连接优先级，数字越大优先级越高（不可以是负数）
#scan_ssid:连接隐藏WiFi时需要指定该值为1

如果你的 WiFi 没有密码

network={
  ssid="你的无线网络名称（ssid）"
  key_mgmt=NONE
}
如果你的 WiFi 使用WEP加密


network={
  ssid="你的无线网络名称（ssid）"
  key_mgmt=NONE
  wep_key0="你的wifi密码"
}
如果你的 WiFi 使用WPA/WPA2加密


network={
  ssid="你的无线网络名称（ssid）"
  key_mgmt=WPA-PSK
  psk="你的wifi密码"
}

如果你不清楚 WiFi 的加密模式，可以在安卓手机上用 root explorer 打开 /data/misc/wifi/wpa/wpa_supplicant.conf，查看 WiFi 的信息。
</code></pre>

<p>3 <a href="https://www.labno3.com/2021/03/22/setting-up-raspberry-pi-wifi/">https://www.labno3.com/2021/03/22/setting-up-raspberry-pi-wifi/</a></p>

<pre><code>如果连接有问题，一定要确认Pi是否支持WiFi。也有可能你的SSID是错误的，要扫描和检查，
使用sudo iwlist wlan0 scan并检查essid字段。
这个字段应该和你在ssid字段输入的一样。
</code></pre>

<p>4 查看信息 <a href="https://www.baeldung.com/linux/connect-network-cli">https://www.baeldung.com/linux/connect-network-cli</a></p>

<pre><code>root@raspberrypi:~# ip link show wlan0
3: wlan0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN mode DEFAULT group default qlen 1000
    link/ether 00:5a:39:e1:4d:bb brd ff:ff:ff:ff:ff:ff
root@raspberrypi:~# ip link set wlan0 up  
root@raspberrypi:~# ip link show wlan0
3: wlan0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN mode DEFAULT group default qlen 1000
    link/ether 00:5a:39:e1:4d:bb brd ff:ff:ff:ff:ff:ff
root@raspberrypi:~# 
root@raspberrypi:~# iw wlan0 link
Not connected.

root@raspberrypi:~# ifconfig wlan0 down
root@raspberrypi:~# ifconfig wlan0 up 
root@raspberrypi:~# ifconfig wlan0
wlan0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        ether 00:5a:39:e1:4d:bb  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>

<p>5 <a href="https://shapeshed.com/linux-wifi/">https://shapeshed.com/linux-wifi/</a></p>

<pre><code>wpa_cli
</code></pre>

<p>6 <a href="https://www.bilibili.com/read/cv8895717">https://www.bilibili.com/read/cv8895717</a></p>

<pre><code>vim /etc/wpa_supplicant/wpa_supplicant.conf 编辑该文件，在文件顶部增加以下内容
country=CN
ctrl_interface=/run/wpa_supplicant
update_config=1

特别说明：country=CN 由于各个国家wifi使用频段不同，尤其5G频段

vim /etc/rc.local 添加以下内容

#!/bin/bash

ip link set wlan0 up &amp;
wpa_supplicant -B -i wlan0 -D nl80211 -c /etc/wpa_supplicant/wpa_supplicant.conf &amp;
dhclient wlan0

exit 0
</code></pre>

<p>7 <a href="https://blog.csdn.net/u010049696/article/details/48765999">https://blog.csdn.net/u010049696/article/details/48765999</a></p>

<pre><code>配置service。进入到/usr/lib/systemd/system目录，可以看到下面四个文件：

wpa_supplicant-nl80211@.service
wpa_supplicant.service
wpa_supplicant@.service
wpa_supplicant-wired@.service

编辑wpa_supplicant.service文件，如下：

[Unit]
Description=WPA supplicant


[Service]
Type=dbus
BusName=fi.epitest.hostap.WPASupplicant
ExecStart=/usr/bin/wpa_supplicant -c/etc/wpa_supplicant/test.conf -i wlp3s0


[Install]
WantedBy=multi-user.target
Alias=dbus-fi.epitest.hostap.WPASupplicant.service

其中，只需修改ExecStart=/usr/bin/wpa_supplicant -c/etc/wpa_supplicant/test.conf -i wlp3s0即可。
</code></pre>

<p>8 <a href="https://www.linuxbabe.com/command-line/ubuntu-server-16-04-wifi-wpa-supplicant">https://www.linuxbabe.com/command-line/ubuntu-server-16-04-wifi-wpa-supplicant</a></p>

<pre><code>Auto Connect on Startup
To automatically connect to wireless network at boot time, we need to edit the wpa_supplicant.service file. It’s a good idea to copy the file from /lib/systemd/system/ directory to /etc/systemd/system/ directory, then edit it because we don’t want newer version of wpasupplicant to override our modifications.

sudo cp /lib/systemd/system/wpa_supplicant.service /etc/systemd/system/wpa_supplicant.service

sudo nano /etc/systemd/system/wpa_supplicant.service
Find the following line.

ExecStart=/sbin/wpa_supplicant -u -s -O /run/wpa_supplicant
Change it to the following. Obviously you need to change wlp3s0 if that isn’t your interface name.

ExecStart=/sbin/wpa_supplicant -u -s -c /etc/wpa_supplicant.conf -i wlp3s0
It’s recommended to always try to restart wpa_supplicant when failure is detected. Add the following right below the ExecStart line.

Restart=always
If you can find the following line in this file, comment it out (Add the # character at the beginning of the line).

Alias=dbus-fi.w1.wpa_supplicant1.service
Save and close the file. Then enable wpa_supplicant service to start at boot time.

sudo systemctl enable wpa_supplicant.service

~~~

sudo nano /etc/systemd/system/dhclient.service
Put the following text into the file.

[Unit]
Description= DHCP Client
Before=network.target

[Service]
Type=forking
ExecStart=/sbin/dhclient wlp3s0 -v
ExecStop=/sbin/dhclient wlp3s0 -r
Restart=always

[Install] 
WantedBy=multi-user.target
Save and close the file. Then enable this service.

sudo systemctl enable dhclient.service
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[请求复制/镜像]]></title>
    <link href="http://winse.github.io/blog/2023/03/25/mirror-request/"/>
    <updated>2023-03-25T18:28:14+08:00</updated>
    <id>http://winse.github.io/blog/2023/03/25/mirror-request</id>
    <content type="html"><![CDATA[<p>在测试一个新功能，如果写入原程序的情况下再写一份到新的程序呢？比如Elasticsearch和OpenSearch。还有把生产的流量引一份出来测试，如果来实现呢？</p>

<p>一般的转换功能复制，如logstash、vector，但这些不能返回结果，不符合。只能往反向代理上找：nginx。</p>

<ul>
<li><a href="https://cloud.tencent.com/developer/article/1495449">Nginx 流量镜像使用技巧</a></li>
<li><a href="https://juejin.cn/post/7101267337332375559">Nginx流量镜像</a></li>
</ul>


<h2>nginx_http_mirror_module模块</h2>

<p>当请求到达 Nginx 时，如果 Nginx 开启了流量镜像功能，就会将请求复制一份，并根据 mirror location 中的配置来处理这份复制的请求。</p>

<h2>配置</h2>

<pre><code>  listen 9200;
  server_name elasticsearch;
  client_max_body_size 50m;

# error_log /var/log/nginx/elasticsearch-errors.log;
# access_log /var/log/nginx/elasticsearch.log;

  location / {

    # Deny Nodes shutdown API
    if ($request_filename ~ "_shutdown") { 
      return 403;
      break;
    }

    # Deny access to cluster API
    if ($request_filename ~ "_cluster") {
      return 403;
      break;
    }

    # Pass requests to ETasticsearch
    proxy_pass http://localhost:9201;
    proxy_redirect off;

    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;

    # For CORS Ajax 
    proxy_pass_header Access-Control-Allow-origin;
    proxy_pass_header Access-Control-Allow-Method proxy_hide_header Access-Control-Allow-Headers;
    add_header Access-control-A1low-Headers 'X-Requested-with, Content-Type';
    # add_header Access-Control-Allow-credentials true;

    # Authorize access 
    #auth basic "elasticsearch";
    #auth_basic_user_file /usr/local/etc/elasticsearch/passwords;

    mirror /mirror;
    mirror_request_body on;
  }

  location /mirror {
    internal; # 指定此location只能被“内部的”请求调用

    # Pass requests to OpenSearch
    proxy_pass http://127.0.0.1:19200$request_uri;
    proxy_redirect off:

    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
  }
}

server {
  listen 127.0.0.1:19200;
  location / { # 增加一层，方便在nginx中输出日志定位问题
    proxy_pass https://192.168.1.21:9200;

    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;

    proxy_set_header Authorization "Basic YWRtaW46YWRtaW4=";
</code></pre>

<p>shell中计算base64的时刻要注意加上 <code>-ne</code> ，也可以直接网上 <a href="https://tool.chinaz.com/tools/base64.aspx">https://tool.chinaz.com/tools/base64.aspx</a> 算一下。</p>

<pre><code>echo -ne 'admin:admin'|base64 -
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xiaomi R4a Install Padavan]]></title>
    <link href="http://winse.github.io/blog/2022/04/11/xiaomi-r4a-install-padavan/"/>
    <updated>2022-04-11T21:19:31+08:00</updated>
    <id>http://winse.github.io/blog/2022/04/11/xiaomi-r4a-install-padavan</id>
    <content type="html"><![CDATA[<p>最近换了个小米的路由，想着登录ssh，能在路由上跑一些小的定时任务。但是无奈，绑定不通过，那就直接刷机了。</p>

<p>一开始是按照csdn上的文章刷opewrt的，但是都不成功，最后换成 老毛子Padavan 了。</p>

<h2>参考</h2>

<ul>
<li><a href="https://blog.csdn.net/qq_43206901/article/details/119106511">小米路由器R4A(千兆版)固件刷opewrt、刷官方固件</a></li>
<li><a href="https://www.0412.cyou/type/xiaomi.html">小米路由4A千兆版安装openwrt教程（R4A）</a></li>
</ul>


<h2>步骤描述</h2>

<h3>获取root权限</h3>

<p>使用 <code>WSL Ubuntu</code> 进行访问，python3已经安装了。</p>

<pre><code>winse@LAPTOP-I9ECVAQ4:OpenWRTInvasion-master$ python3 --version
Python 3.8.5

# https://github.com/acecilia/OpenWRTInvasion
winse@LAPTOP-I9ECVAQ4:OpenWRTInvasion-master$ ls
Dockerfile  readme                                     requirements.txt  set_english.py
extras      README.md                                  script.sh         speedtest_urls_template.xml
firmwares   remote_command_execution_vulnerability.py  script_tools      tcp_file_server.py

winse@LAPTOP-I9ECVAQ4:OpenWRTInvasion-master$ sudo apt install python3-pip

winse@LAPTOP-I9ECVAQ4:OpenWRTInvasion-master$ pip3 install -r requirements.txt
Requirement already satisfied: requests in /usr/lib/python3/dist-packages (from -r requirements.txt (line 1)) (2.22.0)

# stok获取：登录web访问后，浏览器的地址上就有stok的参数。
# 详情可查看参考的文章
winse@LAPTOP-I9ECVAQ4:OpenWRTInvasion-master$ python3 remote_command_execution_vulnerability.py
Router IP address [press enter for using the default 'miwifi.com']:
Enter router admin password: __xxx__
There two options to provide the files needed for invasion:
   1. Use a local TCP file server runing on random port to provide files in local directory `script_tools`.
   2. Download needed files from remote github repository. (choose this option only if github is accessable inside router device.)
Which option do you prefer? (default: 1)
****************
router_ip_address: miwifi.com
stok: __xxx__
file provider: local file server
****************
start uploading config file...
start exec command...
local file server is runing on 0.0.0.0:1135. root='script_tools'
local file server is getting 'busybox-mipsel' for 192.168.31.1.
local file server is getting 'dropbearStaticMipsel.tar.bz2' for 192.168.31.1.
done! Now you can connect to the router using several options: (user: root, password: root)
* telnet miwifi.com
* ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc -o UserKnownHostsFile=/dev/null root@miwifi.com
* ftp: using a program like cyberduck

winse@LAPTOP-I9ECVAQ4:OpenWRTInvasion-master$ ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc -o UserKnownHostsFile=/dev/null root@miwifi.com
The authenticity of host 'miwifi.com (192.168.31.1)' can't be established.
RSA key fingerprint is SHA256:AT91yqVuqPnmOO5wmke6V0Hl67GKXdkb48W/FU3WfEM.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added 'miwifi.com,192.168.31.1' (RSA) to the list of known hosts.
root@miwifi.com's password:

BusyBox v1.19.4 (2021-09-30 03:16:53 UTC) built-in shell (ash)
Enter 'help' for a list of built-in commands.

 -----------------------------------------------------
       Welcome to XiaoQiang!
 -----------------------------------------------------
  $$$$$$\  $$$$$$$\  $$$$$$$$\      $$\      $$\        $$$$$$\  $$\   $$\
 $$  __$$\ $$  __$$\ $$  _____|     $$ |     $$ |      $$  __$$\ $$ | $$  |
 $$ /  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ /  $$ |$$ |$$  /
 $$$$$$$$ |$$$$$$$  |$$$$$\         $$ |     $$ |      $$ |  $$ |$$$$$  /
 $$  __$$ |$$  __$$&lt; $$  __|        $$ |     $$ |      $$ |  $$ |$$  $$&lt;
 $$ |  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ |  $$ |$$ |\$$\
 $$ |  $$ |$$ |  $$ |$$$$$$$$\       $$$$$$$$$  |       $$$$$$  |$$ | \$$\
 \__|  \__|\__|  \__|\________|      \_________/        \______/ \__|  \__|


root@XiaoQiang:~# 
</code></pre>

<h3>安装breed</h3>

<p>用WinSCP登入路由，使用 <code>ftp协议</code> ，ip地址 <code>miwifi.com</code> ，账号 <code>root</code>，把 <code>breed-mt7621-pbr-m1.bin</code> 文件上传到tmp文件夹内，之后执行如下命令：</p>

<pre><code>root@XiaoQiang:~# cd /tmp
root@XiaoQiang:/tmp# ls breed-mt7621-pbr-*
breed-mt7621-pbr-m1.bin

root@XiaoQiang:/tmp# mtd -r write breed-mt7621-pbr-m1.bin Bootloader
Unlocking Bootloader ...

Writing from breed-mt7621-pbr-m1.bin to Bootloader ...
Rebooting ...
</code></pre>

<p>接上网线，再等一阵子（1,2分钟），然后访问 <code>http://192.168.1.1/</code> 。</p>

<h3>刷padavan</h3>

<p>下载r4a版本的padavan: <code>https://opt.cn2qq.com/padavan/</code></p>

<pre><code>MI-R4A_3.4.3.9-099.trx
</code></pre>

<p>访问 <code>192.168.1.1</code> ，备份eeprom和固件（重要），然后勾选固件，然后将小米4A的trx固件文件进行上传，然后完成固件更新流程。</p>

<p>更新过程请不要切断路由电源！更新完成后, 页面并不会自动刷新, 自己尝试能否进入路由配置页面。。</p>

<p>刷完后，这里需要多等待一点时间，耐心一点。</p>

<h3>访问</h3>

<pre><code>http://192.168.123.1/
admin/admin

在 [系统管理 - 服务] 页签开启ssh公钥登录。

[MI-R4A /home/root]# uname -a
Linux MI-R4A 3.4.113 #3 SMP Sun Apr 3 14:26:03 CST 2022 mips GNU/Linux
[MI-R4A /home/root]# uname -r
3.4.113
[MI-R4A /home/root]# uname -m
mips

#CPU/Memory information
$ cat /proc/cpuinfo

#Version
$ cat /proc/version

#SCSI/Sata devices
$ cat /proc/scsi/scsi

#Partitions
$ cat /proc/partitions

#安装 okpg , 进入 Shell 后，在根目录安装，输入如下：
[MI-R4A /home/root]# opkg.sh

# 升级：
[MI-R4A /home/root]# opkg update
Downloading http://bin.entware.net/mipselsf-k3.4/Packages.gz
Updated list of available packages in /opt/var/opkg-lists/entware

[MI-R4A /home/root]# opkg install jq
Installing jq (1.6-2) to root...
Downloading http://bin.entware.net/mipselsf-k3.4/jq_1.6-2_mipsel-3.4.ipk
Configuring jq.

# opkg list
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[斐讯K2刷机padavan]]></title>
    <link href="http://winse.github.io/blog/2021/09/15/k2-again/"/>
    <updated>2021-09-15T17:48:41+08:00</updated>
    <id>http://winse.github.io/blog/2021/09/15/k2-again</id>
    <content type="html"><![CDATA[<p>很久以前刷了过一次，最近朋友在路由器上加了clash代理甚是羡慕啊，于是乎想着自己也重新刷个高级一点的固件系统，然后整个网络的都可以google了，手机也可以，那定是爽极了。</p>

<p>不走不知道，重迈步、万重山、变了天呀。那一身汉不知是吓出还是干出来的。</p>

<p>以下过程仅供参考，因为我也是参考别人的，但是过程也是荆棘丛丛。</p>

<h2>了解k2刷padavan的流程</h2>

<ul>
<li><a href="https://blog.csdn.net/bingyu880101/article/details/82915433">斐讯K2 刷bread 和第三方老毛子Padavan固件</a></li>
<li><a href="https://www.cnblogs.com/DamonDing/p/8546617.html">刷机整个过程</a> *</li>
<li><a href="https://vircloud.net/linux/openwrt-psg1218.html">https://vircloud.net/linux/openwrt-psg1218.html</a> 图文*</li>
</ul>


<p>版本很重要，不对要命那就可能直接变砖了！</p>

<p>1) 中间升级斐讯版本搞了很多次，先升到 【K2_V22.6.506.28 + breed Web控制台助手v5.8版本】 不行（可能是各个零件没配值对，又或者windows的病毒防护和防火墙没关），    <br/>
2) 然后又升到 K2_V22.6.507.43 还是不行，    <br/>
3) 又降回 K2_V22.6.506.28，使用【路由器刷breed Web控制台助手v4.8版本】刷成功了。</p>

<ul>
<li>正确斐讯k2刷breed版本</li>
</ul>


<p><a href="https://github.com/kuangyeheng/k2_router_files">https://github.com/kuangyeheng/k2_router_files</a></p>

<ul>
<li>最后刷成功后访问地址是：192.168.123.1</li>
</ul>


<h2>简单流程介绍</h2>

<p>刷成功使用的文件如下：</p>

<pre><code>H大1001版本RT-AC54U-GPIO-1-PSG1218-64M_3.4.3.9-099.trx
K2_V22.6.506.28.bin
RoutAckProV1B2.rar
路由器刷breed+Web控制台助手v4.8版本.7z
</code></pre>

<p>步骤如下：</p>

<p>1) 接有线，进入192.168.2.1管理界面 <code>手动升级</code> 到 K2_V22.6.506.28</p>

<p>2) 打开 <code>RoutAckProV1B2.exe</code> 点击 <code>打开Telnet</code></p>

<p>3) 关闭杀毒/防病毒软件（会被检测出毒）和防火墙（会开启一个文件服务器），右键使用管理员身份运行 <code>路由器刷breed Web控制台助手v4.8版本.exe</code> ，选k2的刷机方案      <br/>
4) 稍微等等，会弹出刷成功提示。然后会弹出懒人模式，不管直接关掉</p>

<p>5) 断路由器的电，然后按着reset键不松手，最后通电5秒后再松开reset键      <br/>
6) 访问 <a href="http://192.168.1.1">http://192.168.1.1</a> 进入Breed Web恢复控制台   <br/>
7) 恢复出厂设置，选 <code>Config区（公版）</code>   <br/>
8) 固件更新，选 <code>固件</code> 上面的trx文件，然后等     <br/>
9) 偶尔刷新 192.168.123.1 , 访问成功就说明ok了。默认密码admin/admin</p>

<h2>科学上网</h2>

<p><a href="https://ssrv2ray.xyz/posts/%E8%80%81%E6%AF%9B%E5%AD%90padavan%E5%9B%BA%E4%BB%B6ssv2ray%E6%9C%BA%E5%9C%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A2%E9%98%85%E4%B8%8Eclash%E9%85%8D%E7%BD%AE">https://ssrv2ray.xyz/posts/%E8%80%81%E6%AF%9B%E5%AD%90padavan%E5%9B%BA%E4%BB%B6ssv2ray%E6%9C%BA%E5%9C%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A2%E9%98%85%E4%B8%8Eclash%E9%85%8D%E7%BD%AE</a></p>

<p><a href="https://viencoding.com/article/155">https://viencoding.com/article/155</a></p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在树莓派上部署redmine - Respberrypi]]></title>
    <link href="http://winse.github.io/blog/2020/05/11/redmine-on-arm-pi/"/>
    <updated>2020-05-11T10:33:44+08:00</updated>
    <id>http://winse.github.io/blog/2020/05/11/redmine-on-arm-pi</id>
    <content type="html"><![CDATA[<p>变废为宝。</p>

<p>服务器没怎么用，但是偶尔又想访问下文档或者redmine，狠狠心咬咬牙最后把x64上的迁移到了树莓派2： Raspbian GNU/Linux 9 (stretch) 。</p>

<p>温故下原来redmine的安装过程： <a href="http://www.winseliu.com/blog/2017/09/18/redmine-deploy-and-install-plugins/">Redmine部署以及插件安装</a></p>

<p>过程中涉及到了docker的重新编译，这其中主要使用ubuntu apt源码在本地arm上进行再编译。其中涉及的镜像有：</p>

<ul>
<li><a href="https://github.com/sameersbn/docker-ubuntu/tree/14.04">https://github.com/sameersbn/docker-ubuntu/tree/14.04</a></li>
<li><a href="https://github.com/sameersbn/docker-postgresql/tree/9.6-2">https://github.com/sameersbn/docker-postgresql/tree/9.6-2</a></li>
<li><a href="https://github.com/sameersbn/docker-redmine/tree/3.4.6">https://github.com/sameersbn/docker-redmine/tree/3.4.6</a></li>
</ul>


<h2>备份</h2>

<p>redmine直接整个目录打包 /srv/docker/redmine/redmine 。数据库的要备份出来，架构不同不兼容。</p>

<p>这是编译后arm postgres直接用x64的/srv/docker/redmine/postgresql的报错信息：
```
root@raspberrypi:~# docker run &ndash;rm -ti &ndash;entrypoint=&ldquo;bash&rdquo; -v /srv/docker/redmine/postgresql:/var/lib/postgresql sameersbn/postgresql:9.6-2</p>

<p>root@8f39c2904607:/var/lib/postgresql# sudo -HEu postgres /usr/lib/postgresql/9.6/bin/pg_ctl -D /var/lib/postgresql/9.6/main -w start
waiting for server to start&hellip;.FATAL:  database files are incompatible with server
DETAIL:  The database cluster was initialized with USE_FLOAT8_BYVAL but the server was compiled without USE_FLOAT8_BYVAL.
HINT:  It looks like you need to recompile or initdb.
LOG:  database system is shut down
stopped waiting
pg_ctl: could not start server
Examine the log output.
```</p>

<h2>编译ubuntu镜像</h2>

<p>直接使用最新的trusty发布版镜像。由于低版本的可能会没有 linux/arm/v7 : <a href="https://hub.docker.com/_/ubuntu/?tab=tags&amp;page=1&amp;name=trusty">https://hub.docker.com/_/ubuntu/?tab=tags&amp;page=1&amp;name=trusty</a></p>

<pre><code>root@raspberrypi:~/docker-ubuntu# vi Dockerfile
FROM ubuntu:trusty

docker build -t sameersbn/ubuntu:14.04.20170123 . 
docker tag sameersbn/ubuntu:14.04.20170123 sameersbn/ubuntu:14.04.20170711 
</code></pre>

<h2>编译postgres镜像</h2>

<p>由于postgresql apt的库中没有armhf的deb，需要先手动编译好对应的deb。先运行一个容器，再里面编译好postgres。</p>

<pre><code>wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add - \
 &amp;&amp; echo 'deb-src http://mirrors.zju.edu.cn/postgresql/repos/apt/ trusty-pgdg main' &gt; /etc/apt/sources.list.d/pgdg.list \
 &amp;&amp; sed -i 's/ports.ubuntu.com/mirrors.aliyun.com/' /etc/apt/sources.list \
 &amp;&amp; sed -Ei 's/^# deb-src /deb-src /' /etc/apt/sources.list \
 &amp;&amp; apt-get update

root@7d55994af11e:/# apt-get build-dep dh-exec postgresql-common  pgdg-keyring     
root@7d55994af11e:/# apt-get source --compile dh-exec postgresql-common  pgdg-keyring   

root@7d55994af11e:/# apt-get build-dep postgresql-${PG_VERSION} postgresql-client-${PG_VERSION} postgresql-contrib-${PG_VERSION} dh-exec
root@7d55994af11e:/# apt-get source --compile postgresql-${PG_VERSION} postgresql-client-${PG_VERSION} postgresql-contrib-${PG_VERSION} 
</code></pre>

<p>再测试安装一下这些deb：</p>

<pre><code>wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add - \
 &amp;&amp; echo 'deb-src http://mirrors.zju.edu.cn/postgresql/repos/apt/ trusty-pgdg main' &gt; /etc/apt/sources.list.d/pgdg.list \
 &amp;&amp; sed -i 's/ports.ubuntu.com/mirrors.aliyun.com/' /etc/apt/sources.list \
 &amp;&amp; sed -Ei 's/^# deb-src /deb-src /' /etc/apt/sources.list \
 &amp;&amp; apt-get update

apt-get install -y acl \
    libpipeline1 debhelper ssl-cert libxml2 libedit2 libxslt1.1 libperl5.18 libpython2.7 libpython3.4 libtcl8.6

dpkg -i pgdg-keyring_2018.2_all.deb postgresql-common_201.pgdg14.04+1_all.deb  postgresql-client-common_201.pgdg14.04+1_all.deb

dpkg -i libpq5_9.6.13-1.pgdg14.04+1_armhf.deb  postgresql-9.6_9.6.13-1.pgdg14.04+1_armhf.deb postgresql-client-9.6_9.6.13-1.pgdg14.04+1_armhf.deb postgresql-contrib-9.6_9.6.13-1.pgdg14.04+1_armhf.deb
</code></pre>

<p>修改Dockerfile，直接通过dpkg安装postgresql的deb：</p>

<pre><code>root@raspberrypi:~/docker-postgresql# less Dockerfile 
...
COPY deb/ /tmp/psql/

RUN wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add - \
 &amp;&amp; echo 'deb-src http://mirrors.zju.edu.cn/postgresql/repos/apt/ trusty-pgdg main' &gt; /etc/apt/sources.list.d/pgdg.list \
 &amp;&amp; sed -i 's/ports.ubuntu.com/mirrors.aliyun.com/' /etc/apt/sources.list \
 &amp;&amp; sed -Ei 's/^# deb-src /deb-src /' /etc/apt/sources.list \
 &amp;&amp; apt-get update \
 &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -y acl \
    libpipeline1 debhelper ssl-cert libxml2 libedit2 libxslt1.1 libperl5.18 libpython2.7 libpython3.4 libtcl8.6 \
 &amp;&amp; cd /tmp/psql \
 &amp;&amp; dpkg -i pgdg-keyring_2018.2_all.deb postgresql-common_201.pgdg14.04+1_all.deb  postgresql-client-common_201.pgdg14.04+1_all.deb \
 &amp;&amp; dpkg -i libpq5_9.6.13-1.pgdg14.04+1_armhf.deb  postgresql-9.6_9.6.13-1.pgdg14.04+1_armhf.deb postgresql-client-9.6_9.6.13-1.pgdg14.04+1_armhf.deb postgresql-contrib-9.6_9.6.13-1.pgdg14.04+1_armhf.deb \
 &amp;&amp; rm -rf /tmp/psql \
...

root@raspberrypi:~/docker-postgresql# docker build -t sameersbn/postgresql:9.6-2 .
</code></pre>

<h2>编译redmine镜像</h2>

<p>redmine主要是缺少ruby2.3的包，跟上面的步骤类似。先编译出arm的ruby2.3，再编译镜像。</p>

<pre><code>sed -i 's/ports.ubuntu.com/mirrors.aliyun.com/' /etc/apt/sources.list \
&amp;&amp; sed -Ei 's/^# deb-src /deb-src /' /etc/apt/sources.list

apt-get build-dep ruby${RUBY_VERSION} ruby${RUBY_VERSION}-dev
apt-get source --compile ruby${RUBY_VERSION} ruby${RUBY_VERSION}-dev


root@raspberrypi:~/docker-redmine# vi Dockerfile 
...
COPY deb/ /tmp/ruby/

RUN apt-key adv --keyserver keyserver.ubuntu.com --recv E1DD270288B4E6030699E45FA1715D88E1DF1F24 \
 &amp;&amp; echo "deb http://ppa.launchpad.net/git-core/ppa/ubuntu trusty main" &gt;&gt; /etc/apt/sources.list \
 &amp;&amp; apt-key adv --keyserver keyserver.ubuntu.com --recv 80F70E11F0F0D5F10CB20E62F5DA5F09C3173AA6 \
 &amp;&amp; echo "deb http://ppa.launchpad.net/brightbox/ruby-ng/ubuntu trusty main" &gt;&gt; /etc/apt/sources.list \
 &amp;&amp; apt-key adv --keyserver keyserver.ubuntu.com --recv 8B3981E7A6852F782CC4951600A6F0A3C300EE8C \
 &amp;&amp; echo "deb http://ppa.launchpad.net/nginx/stable/ubuntu trusty main" &gt;&gt; /etc/apt/sources.list \
 &amp;&amp; wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add - \
 &amp;&amp; echo 'deb-src http://apt.postgresql.org/pub/repos/apt/ trusty-pgdg main' &gt; /etc/apt/sources.list.d/pgdg.list \
 &amp;&amp; sed -i 's/ports.ubuntu.com/mirrors.aliyun.com/' /etc/apt/sources.list \
 &amp;&amp; sed -Ei 's/^# deb-src /deb-src /' /etc/apt/sources.list \
 &amp;&amp; apt-get update \
 &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -y supervisor logrotate nginx mysql-client postgresql-client \
      imagemagick subversion git cvs bzr mercurial darcs rsync   locales openssh-client \
      gcc g++ make patch pkg-config gettext-base   libc6-dev zlib1g-dev libxml2-dev \
      libmysqlclient18 libpq5 libyaml-0-2 libcurl3 libssl1.0.0 uuid-dev xz-utils \
      libxslt1.1 libffi6 zlib1g gsfonts \
      libgmpxx4ldbl libgmp-dev libtk8.5 libxft2 libxrender1 libxss1 x11-common libtcl8.5 rubygems-integration \
 &amp;&amp; dpkg -i /tmp/ruby/*.deb \
 &amp;&amp; rm -rf /tmp/ruby \
 &amp;&amp; update-locale LANG=C.UTF-8 LC_MESSAGES=POSIX \
 &amp;&amp; gem install --no-document --version '&lt; 2.0' bundler \
 &amp;&amp; rm -rf /var/lib/apt/lists/*
...

root@raspberrypi:~/docker-redmine# docker build -t sameersbn/redmine:3.4.6 .
</code></pre>

<p>如果docker构建失败，可以通过以下两种方式来进行调试：</p>

<pre><code># 1
docker commit $container-id image-id
docker run -ti $image-id bash

# 2 
失败也会有前一步骤的镜像已经提交，再次基础上检查后面的步骤
The last successful step is 2. It produced an image a3acfa4ab179. Now you start a container
docker run -it a3acfa4ab179 bash
</code></pre>

<h2>结合原有数据进行迁移</h2>

<pre><code># 备份
psql -U postgres -cC --if-exists -d redmine_production &gt;redmine.dump 

# 安装compose
root@raspberrypi:~/redmine/bin# python -m pip install --upgrade pip
root@raspberrypi:~/redmine/bin# pip install docker-compose

# 启动
root@raspberrypi:~/redmine/bin# docker-compose up -d 

# 数据库还原
docker cp redmine.dump e472d9ec3124:/var/lib/postgresql/
psql -U postgres &lt;redmine.dump

# redmine修复
root@3f0774db222d:/home/redmine/redmine# apt-get install libmysqlclient-dev                                    

https://stackoverflow.com/questions/13086073/rails-install-pg-cant-find-the-libpq-fe-h-header
root@3f0774db222d:/home/redmine/redmine# apt-get install libpq-dev
https://stackoverflow.com/questions/38200015/package-magickcore-was-not-found-in-the-pkg-config-search-path
root@3f0774db222d:/home/redmine/redmine# apt-get install libmagickwand-dev

root@3f0774db222d:/home/redmine/redmine# bundle install                    
</code></pre>

<p>后面就直接安装docker-compose.yml中的端口映射配置访问即可。</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
</feed>
