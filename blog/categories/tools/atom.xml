<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Winse Blog]]></title>
  <link href="http://winseliu.com/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://winseliu.com/"/>
  <updated>2017-07-09T14:52:33+00:00</updated>
  <id>http://winseliu.com/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[爬虫之CasperJS]]></title>
    <link href="http://winseliu.com/blog/2017/07/08/casperjs-crawler/"/>
    <updated>2017-07-08T15:56:06+00:00</updated>
    <id>http://winseliu.com/blog/2017/07/08/casperjs-crawler</id>
    <content type="html"><![CDATA[<p>用jsoup(java, scala, groovy)爬过数据，用cheerio(nodejs)爬过数据，每次爬取都要对页面HTML结构，数据来源URL进行研究。还要对网站的反扒做一些HEADER的设置。各种繁琐，主要还有一些数据型的网站验证复杂，很难通过简单的方式来破解它的那套反扒流程。</p>

<p><a href="http://docs.casperjs.org/en/latest/modules/casper.html">CasperJS</a>是在<a href="http://phantomjs.org/quick-start.html">phantomjs</a>基础上的一套工具库用来简化phantomjs的操作，降低使用和入门的门槛。而PhantomJS是类似浏览器的一个工具（headless browsers），你可以把它看做浏览器。所以可以通过CasperJS来操作浏览器访问地址，然后加载完页面后再提取数据，这样就不要考虑被反扒的风险，并且获取数据的方式相对容易和简单。</p>

<h2>先从官网的案例体验下HelloWorld以及如何调试</h2>

<p>下载最新的<a href="http://docs.casperjs.org/en/latest/installation.html#installing-from-npm">CasperJS（npm install）</a>即可，PhantomJS下载<a href="https://bitbucket.org/ariya/phantomjs/downloads/">1.9.8</a>版本，不推荐2+版本，有些功能有问题。</p>

<pre><code>
R:\test&gt;set PATH=C:\Users\winse\AppData\Roaming\npm\node_modules\casperjs\bin;E:\phantomjs-1.9.8-windows;%PATH

R:\test&gt;cat hello.js
var casper = require('casper').create();
// debugger

casper.start('http://casperjs.org/', function() {
    this.echo(this.getTitle());

    this.echo("Star: " + this.evaluate(function () { 
        return $(".octicon-star").parent().text().trim()
    }) )
});

casper.thenOpen('http://phantomjs.org', function() {
    this.echo(this.getTitle());

    this.echo("Intro: " + this.evaluate(function () { 
        return $(".intro h1").innerHTML
        // return document.querySelector(".intro h1").innerHTML
    }) )
});

casper.run();

R:\test&gt;casperjs  hello.js
CasperJS, a navigation scripting and testing utility for PhantomJS and SlimerJS
Star: 6,337 Stargazers
PhantomJS | PhantomJS
Intro: null
</code></pre>

<p></p>

<p>用js的方式来获取页面数据，非常完美，相比直接通过URL请求来获取数据，CasperJS就是慢了点（有点像我们每次都打开浏览器然后再访问，可以通过建立服务，然后在常驻PhantomJS访问页面）。</p>

<p>上面第二次获取的数据不是我们想要的，这里我们通过调试看看到底是什么原因导致的。在start前增加一行 <code>debugger</code> 。然后执行：</p>

<pre><code>casperjs hello.js --verbose --log-level=debug --remote-debugger-port=9000
</code></pre>

<p>打开浏览器方式 localhost:9000 点击 <strong>about:blank</strong> 链接，然后在Console窗口执行 <code>__run()</code> ，等一下下会停在debugger那一行，再然后就是愉快的debug就好了。</p>

<p>在 <a href="http://phantomjs.org">http://phantomjs.org</a> 那一段的evaluate代码处增加一个断点，运行到该断点后，再次打开 localhost:9000 会多出一个当前访问页面的链接，点击进去就像平时F12看到的调式窗口了。</p>

<ul>
<li><a href="http://phantomjs.org/troubleshooting.html#remote-debugging">http://phantomjs.org/troubleshooting.html#remote-debugging</a></li>
<li><a href="https://drupalize.me/blog/201410/using-remote-debugger-casperjs-and-phantomjs">https://drupalize.me/blog/201410/using-remote-debugger-casperjs-and-phantomjs</a></li>
<li><a href="https://stackoverflow.com/questions/15645371/setting-up-js-debugging-with-intellij-webstorm-and-phantomjs-casper">https://stackoverflow.com/questions/15645371/setting-up-js-debugging-with-intellij-webstorm-and-phantomjs-casper</a></li>
<li><a href="https://github.com/ariya/phantomjs/issues/12064">https://github.com/ariya/phantomjs/issues/12064</a></li>
</ul>


<p>注意: <a href="https://www.portablesoft.org/google-chrome-legacy-versions/">Chrome浏览器要用V54版本以下</a> 的。</p>

<p>调试详情如下：</p>

<pre><code>&gt; $(".intro h1")
null
&gt; $
bound: function () {
        return document.getElementById.apply(document, arguments);
    }
&gt; document.querySelector(".intro h1").innerHTML
"
        Full web stack&lt;br&gt;
        No browser required
      "
</code></pre>

<p>那我们把js脚本修改成querySelector来获取数据。再次执行：</p>

<pre><code>R:\test&gt;casperjs  hello.js
CasperJS, a navigation scripting and testing utility for PhantomJS and SlimerJS
Star: 6,337 Stargazers
PhantomJS | PhantomJS
Intro:
        Full web stack&lt;br&gt;
        No browser required
</code></pre>

<h2>功能特性</h2>

<ul>
<li>截图</li>
</ul>


<p>有现成的方法，但是需要自己<a href="https://uggedal.com/journal/phantomjs-default-background-color/">处理下背景颜色</a> <a href="http://phantomjs.org/tips-and-tricks.html">Tips and Tricks</a>。</p>

<pre><code>&gt; cat capture.js
var casper = require('casper').create({
    waitTimeout: 120000,
    logLevel: "debug",
    verbose: true
});
casper.userAgent('Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0')

casper.start('https://xueqiu.com/2054435398/32283614', function () {
    this.waitForSelector("div.status-content a[title*=xueqiu]");
}).then(function () {
    // white background
    this.evaluate(function () {
        var style = document.createElement('style'),
            text = document.createTextNode('body { background: #fff }');
        style.setAttribute('type', 'text/css');
        style.appendChild(text);
        document.head.insertBefore(style, document.head.firstChild);
    });
}).then(function () {
    this.capture('结庐问山.jpg');
});

casper.run()

&gt; casperjs capture.js --load-images=yes --disk-cache=yes --ignore-ssl-errors=true --output-encoding=gbk
</code></pre>

<p>用来截全屏的图片相当厉害，Chrome等自带的截图工具如果内容长了后很慢很麻烦，这种方式毫无压力啊。</p>

<ul>
<li>抓取层次页面</li>
</ul>


<p>一般抓数据有个列表页，然后根据列表页的详情地址，根据详情地址再获取数据。</p>

<pre><code>&gt; cat xueqiu.js
debugger

var fs = require('fs');
var casper = require('casper').create({
    waitTimeout: 120000,
    logLevel: "debug",
    verbose: true
});
casper.userAgent('Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0')

var links = []
var basedir = '.'
casper.start('https://xueqiu.com/2054435398/32283614', function () {
    this.waitForSelector("div.status-content a[title*=xueqiu]");
}).then(function () {
    var items = this.evaluate(function () {
        return $("div.status-content a[title*=xueqiu]").map(function (i, a) {
            return $(a).attr('href')
        })
    })

    for (var i = 0; i &lt; items.length; i++) {
        links.push(items[i]);
    }

    fs.write('all.html', this.getHTML(), 'w');
}).then(function () {
    this.eachThen(links, function (link) {
        var pathname = undefined;
        var url = link.data;

        this.thenOpen(url, function () {
            this.waitForSelector("div.status-content .detail");
        }).then(function () {
            pathname = this.evaluate(function () {
                var style = document.createElement('style'),
                    text = document.createTextNode('body { background: #fff }');
                style.setAttribute('type', 'text/css');
                style.appendChild(text);
                document.head.insertBefore(style, document.head.firstChild);

                return window.location.pathname;
            });
        }).then(function () {
            if (url.indexOf(pathname))
                this.capture(basedir + pathname + ".jpg");
            else
                this.echo(url);
        });

    })

});

casper.run()

&gt; casperjs xueqiu.js --load-images=yes --disk-cache=yes --ignore-ssl-errors=true --output-encoding=gbk --remote-debugger-port=9000
</code></pre>

<p>然后一堆堆的图片就生成出来了。由于访问的速度有限，有利有弊，慢一点还不要做时间上面的控制了，有点像人在操作的感觉。然后处理下异常的个别再导一次就可以了(错误的那一篇还是404的&hellip;哭笑)。</p>

<pre><code>$("div.status-content a[title*=xueqiu]").map(function(i, a){ return $(a).attr('href') }).length
177

$ find . -name '*.jpg' | wc -l
176
</code></pre>

<p>注意：Windows的命令窗口，多按几次Enter，有时一不小心就进入编辑模式了。</p>

<p>CasperJS足够强大，更多的模式等待你的开启。就写到此。</p>

<h2>后记</h2>

<p>关于爬虫获取数据 <a href="http://webmagic.io/docs/zh/posts/chx-cases/js-render-page.html">抓取前端渲染的页面</a> 这篇文章讲的挺中肯的，如果可能的话，用作者写的 <a href="https://github.com/code4craft/webmagic/blob/master/README-zh.md">WebMagic</a> 也是一个不错的选择。</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Start Guide]]></title>
    <link href="http://winseliu.com/blog/2017/06/04/jenkins-start-guide/"/>
    <updated>2017-06-04T10:19:23+00:00</updated>
    <id>http://winseliu.com/blog/2017/06/04/jenkins-start-guide</id>
    <content type="html"><![CDATA[<p>从原始的Eclipse右键导出打包，到后面使用maven打包，就单自己一个人使用开发部署是完全没问题的。现在的jenkins是对工具的封装、可视化和自动化，对于团队合作还是有一定的作用的，时时刻刻告诉我们代码是可运行的。</p>

<p>但是如果一个很久前的项目，又需要新加/修改功能，一下子还捡不起来，不放心啊还得验证一把。还有就是，测试有时刻他们自己打包，不会的还的教她们使用工具，人家烦自己也累。</p>

<p>jenkins是一个持续集成的工具，原来也接触过，但是都没用起来，都是搞开发，大部分时刻都能自己搞定。最新由于特殊情况，很多代码都直接在生产改，测试环境就不顾上了，但是测试环境不能总是旧代码啊，就想着有个自动化的东西来进行部署。</p>

<p>主要就是完成一个代码自动化部署的工作：自己搭建一个jenkins，从oschina上拉代码，编译后部署到tomcat并重启。</p>

<h2><a href="https://jenkins.io/download/">安装Jenkins</a></h2>

<pre><code>wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war
nohup java -jar jenkins.war --httpPort=8081 &gt;/var/log/jenkins.log 2&gt;&amp;1 &amp; 
</code></pre>

<h2>建立到oschina的无密钥登录</h2>

<p>由于项目是私有的，通过https需要输入密码，还是git方式无密钥登录方式便捷一些。本地linux执行ssh-keygen，然后把 id_rsa.pub 的内容拷贝到项目的公钥处进行配置。可以参考文档： <a href="http://git.mydoc.io/?t=154712">http://git.mydoc.io/?t=154712</a>。也可以结合 本地ssh-agent 和 ssh-forward 来弄。</p>

<h2>配置项目</h2>

<p>第一次登录需要进行一些配置，默认admin创建的密码会保存在 ~/.jenkins/secrets/initialAdminPassword 。（在初始化页面创建新用户报错，也不知道啥原因。登录后再建吧）</p>

<p>新版本的按照默认安装插件还不行够，需要再添加一些。登录成功后，添加如下插件：</p>

<pre><code>Deploy to container Plugin  把war发布到容器tomcat...
Nexus Artifact Uploader  上传jar到私服
Maven Integration plugin 集成maven
</code></pre>

<p>配置maven：</p>

<p>自己下载个maven解压后，在jenkins - Global Tool Configuration上面配置maven地址即可（把 自动安装 的勾去掉就可以填地址了）</p>

<p>然后配置JOB：</p>

<ul>
<li>构建一个maven项目：填任务的名称，然后点击左下角的OK</li>
<li>源码管理git: 填写地址，然后新增Credentials - SSH Username with private key - From the Jenkins master ~/.ssh 起一个容易区分的名字</li>
<li>构建触发器： Build periodically - 0 0 * * * 每天一次</li>
<li>Build：web/pom.xml ; clean package -Papp,dist -DskipTests 就是mvn命令的一串参数</li>
<li>Post Steps: Run only if build succeeds - Execute Shell</li>
</ul>


<pre><code>/opt/apache-tomcat-8.0.26/bin/shutdown.sh ; sleep 1 
rm -rf /opt/apache-tomcat-8.0.26/webapps/app.war 
cp $WORKSPACE/web/app/target/app.war /opt/apache-tomcat-8.0.26/webapps 
cd /opt/apache-tomcat-8.0.26/webapps ; ./deploy.sh 
BUILD_ID=dontKillMe nohup /opt/apache-tomcat-8.0.26/bin/startup.sh &amp; 
sleep 3
</code></pre>

<p>这里的BUILD_ID挺有意思啊！！</p>

<p>也可以配置[构建后操作]把包发布到tomcat manager，无奈webapps下的都被我删了。就用脚本弄了。</p>

<h2>构建</h2>

<p>完成上面的操作后，就可以执行跑一次看看效果了。其他的还有很多功能：权限等。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.cnblogs.com/gao241/archive/2013/03/20/2971416.html">Jenkins配置基于角色的项目权限管理</a></li>
<li><a href="http://www.cnblogs.com/zz0412/p/jenkins_jj_14.html">Jenkins进阶系列之——14配置Jenkins用户和权限</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Spawning+processes+from+build">https://wiki.jenkins-ci.org/display/JENKINS/Spawning+processes+from+build</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jenkins/">https://www.ibm.com/developerworks/cn/java/j-lo-jenkins/</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Privoxy把shadowsocks转换为Http代理]]></title>
    <link href="http://winseliu.com/blog/2017/02/04/privoxy-http-proxy-for-shadowsocks/"/>
    <updated>2017-02-04T07:36:08+00:00</updated>
    <id>http://winseliu.com/blog/2017/02/04/privoxy-http-proxy-for-shadowsocks</id>
    <content type="html"><![CDATA[<p><a href="https://program-think.blogspot.com/2014/12/gfw-privoxy.html">https://program-think.blogspot.com/2014/12/gfw-privoxy.html</a></p>

<p>Privoxy是一个代理辅助工具，这里用Privoxy把Shadowsocks socks5代理转换为http代理。</p>

<p>kubernetes的docker容器需要访问google的服务，docker暂时只支持http代理，而我手上有的代理是 <a href="http://99ss.in">shadowsocks</a> 的。这里通过Privoxy把socks5转成http代理。</p>

<h2>安装Shadowsocks</h2>

<ul>
<li><a href="http://blog.lxx1.com/1420">http://blog.lxx1.com/1420</a></li>
<li><a href="https://shadowsocks.org/en/download/clients.html">https://shadowsocks.org/en/download/clients.html</a></li>
</ul>


<pre><code>[root@k8s ~]# yum install epel-release python-pip -y

[root@k8s ~]# pip install shadowsocks
Collecting shadowsocks
  Downloading shadowsocks-2.8.2.tar.gz
Installing collected packages: shadowsocks
  Running setup.py install for shadowsocks ... done
Successfully installed shadowsocks-2.8.2
You are using pip version 8.1.2, however version 9.0.1 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.

上面软件已经安装好了, 推荐更新下pip.
[root@k8s ~]# pip install --upgrade pip
Collecting pip
  Downloading pip-9.0.1-py2.py3-none-any.whl (1.3MB)
    100% |████████████████████████████████| 1.3MB 46kB/s 
Installing collected packages: pip
  Found existing installation: pip 8.1.2
    Uninstalling pip-8.1.2:
      Successfully uninstalled pip-8.1.2
Successfully installed pip-9.0.1
</code></pre>

<p>填写shadowsocks服务端信息以及本地映射端口，启动客户端</p>

<pre><code>[root@k8s ~]# cat /etc/shadowsocks.json 
{
"server": "xxxxxx",
"server_port": xxx,
"local_port": 1080,
"password": "xxxxxxxx",
"timeout": 600,
"method": "rc4-md5",
"fast_open": false,
"workers": 1
}
[root@k8s ~]# sslocal -c /etc/shadowsocks.json 
</code></pre>

<p></p>

<p>配置防火墙，如果其他主机也需要用这个代理的话</p>

<p><a href="https://havee.me/linux/2015-01/using-firewalls-on-centos-7.html">https://havee.me/linux/2015-01/using-firewalls-on-centos-7.html</a></p>

<pre><code>[root@bigdata-dev ~]# firewall-cmd --zone=public --add-port=1080/tcp --permanent
[root@bigdata-dev ~]# firewall-cmd --reload
</code></pre>

<h2>安装privoxy</h2>

<ul>
<li><a href="https://www.privoxy.org/sf-download-mirror/Win32/3.0.26%20%28stable%29/">windows版本下载地址</a></li>
<li><a href="http://www.ttlsa.com/linux/privoxy-convert-socks-proxy-to-http/">http://www.ttlsa.com/linux/privoxy-convert-socks-proxy-to-http/</a></li>
<li><a href="https://blog.phpgao.com/privoxy-shadowsocks.html">https://blog.phpgao.com/privoxy-shadowsocks.html</a></li>
</ul>


<pre><code>[root@k8s ~]# yum install privoxy -y

查找listen-address行注释掉，在最后添加如下两行
[root@k8s docker.service.d]# vi /etc/privoxy/config 
...
forward-socks5 / 127.0.0.1:1080 .
listen-address k8s:8118

# 启动
[root@k8s ~]# systemctl start privoxy
# 查看状态
[root@k8s ~]# systemctl status privoxy

[root@k8s ~]# systemctl enable privoxy
Created symlink from /etc/systemd/system/multi-user.target.wants/privoxy.service to /usr/lib/systemd/system/privoxy.service.

如果其他机器需要用到代理的话，需要配置防火墙开放端口
[root@k8s ~]# firewall-cmd --zone=public --add-port=8118/tcp --permanent
[root@k8s ~]# firewall-cmd --reload 
</code></pre>

<p>在本机调试会方便点，安装桌面环境</p>

<p><a href="http://unix.stackexchange.com/questions/181503/how-to-install-desktop-environments-on-centos-7">http://unix.stackexchange.com/questions/181503/how-to-install-desktop-environments-on-centos-7</a></p>

<pre><code>yum -y groups install "GNOME Desktop" 
</code></pre>

<p>然后firefox安装autoproxy，配置http代理。（firefox自带的代理有点抽风，不太好用）</p>

<p>或者通过curl加代理参数：</p>

<p>```
[root@k8s ~]# curl google.com
curl: (7) Failed to connect to 2404:6800:4008:802::200e: Network is unreachable
[root@k8s ~]#
[root@k8s ~]# curl -x localhost:8118 google.com
<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY></p>

<H1>301 Moved</H1>


<p>The document has moved
<A HREF="http://www.google.com/">here</A>.
</BODY></HTML>
```</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Centos7上安装VNC Server]]></title>
    <link href="http://winseliu.com/blog/2017/01/27/vnc-server-on-centos7/"/>
    <updated>2017-01-27T08:43:51+00:00</updated>
    <id>http://winseliu.com/blog/2017/01/27/vnc-server-on-centos7</id>
    <content type="html"><![CDATA[<h2>安装</h2>

<pre><code>[root@bigdata-dev ~]# yum install -y tigervnc-server

首先查看原来的默认配置
[root@bigdata-dev ~]# cat /lib/systemd/system/vncserver@.service 

[Service]
Type=forking
# Clean any existing files in /tmp/.X11-unix environment
ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'
ExecStart=/usr/sbin/runuser -l &lt;USER&gt; -c "/usr/bin/vncserver %i"
PIDFile=/home/&lt;USER&gt;/.vnc/%H%i.pid
ExecStop=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'

复制一份修改，已root用户为例。其他用户类推
[root@bigdata-dev system]# cp vncserver@.service vncserver@:1.service 
[root@bigdata-dev system]# vi vncserver@\:1.service 

[Service]
Type=forking
# Clean any existing files in /tmp/.X11-unix environment
ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'
ExecStart=/usr/sbin/runuser -l root -c "/usr/bin/vncserver %i"
PIDFile=/root/.vnc/%H%i.pid
ExecStop=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'

[root@bigdata-dev system]# systemctl daemon-reload
[root@bigdata-dev system]# systemctl enable vncserver@:1.service
Created symlink from /etc/systemd/system/multi-user.target.wants/vncserver@:1.service to /etc/systemd/system/vncserver@:1.service.
[root@bigdata-dev system]# systemctl start vncserver@:1.service
[root@bigdata-dev system]# systemctl status vncserver@:1.service
● vncserver@:1.service - Remote desktop service (VNC)
   Loaded: loaded (/etc/systemd/system/vncserver@:1.service; enabled; vendor preset: disabled)
   Active: active (running) since Wed 2017-01-25 14:28:04 CST; 27s ago

[root@bigdata-dev system]# vncpasswd 
Password:
Verify:
[root@bigdata-dev system]# 
[root@bigdata-dev system]# 
[root@bigdata-dev system]# systemctl restart vncserver@:1.service
http://www.aboutyun.com/thread-17535-1-1.html
[root@bigdata-dev system]# systemctl status firewalld.service
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
</code></pre>

<h2>下载客户端并访问</h2>

<p><a href="https://www.realvnc.com/download/viewer/">https://www.realvnc.com/download/viewer/</a> 访问VNC服务的地址 HOST:5901</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[整理] 环境准备工具集]]></title>
    <link href="http://winseliu.com/blog/2017/01/25/develop-environment-prepare/"/>
    <updated>2017-01-25T02:57:18+00:00</updated>
    <id>http://winseliu.com/blog/2017/01/25/develop-environment-prepare</id>
    <content type="html"><![CDATA[<p>工具其实很重要，不仅仅是帮你把东西管理起来，而是工具是一整套的解决方案，是前辈多年总结实践的成果。</p>

<p>初出茅庐的时刻，总觉得工具麻烦，写个java程序还得写个pom，直接把jar放到lib下然后加入classpath就好了。殊不知，后面还有打包，进阶后还要看源码等等问题接踵而来。慢慢把maven用起来，又觉得apache的访问太慢（忍了），项目组内部分功能，开始全部放一个parent下面（也还行）。但后面编译打包太麻烦，尝试在项目组自己建立maven私有仓库。</p>

<p>这里把这几年使用的工具罗列下：</p>

<p>私有仓库：</p>

<ul>
<li>Nexus 如：项目组私有仓库</li>
<li>YUM repo: createrepo <a href="/blog/2016/06/17/ganglia-install-on-centos-with-puppet/">使用Puppet安装配置Ganglia</a> 如：生产环境YUM仓库</li>
<li><a href="/blog/2016/04/04/rpm-build-your-package/">RPM打包</a></li>
<li>Docker register [TODO]</li>
<li><a href="/blog/2016/03/11/install-and-config-openvpn/">OpenVPN</a> 如：访问只能内网访问的服务组（OA、SSH）</li>
</ul>


<p>软件使用：</p>

<ul>
<li><a href="/images/blogs/linux-101-hacks-review-securecrt-config.png">SecureCRT</a> 如：访问只能内网访问的单服务（无依赖）</li>
<li><a href="/blog/2015/11/22/gfw-ladder/">翻墙</a> google值得拥有</li>
<li><a href="/blog/2015/04/12/optimize-system-ramdisk/">内存盘</a></li>
<li><a href="/blog/2012/10/08/eclipse-remote-debugging-java-applications/">远程调试</a> <a href="/blog/2014/04/22/remote-debug-hadoop2/">远程调试hadoop2以及错误处理方法</a></li>
<li><a href="/blog/2014/02/23/quickly-open-program-in-windows/">WIN + R 快速打开程序</a></li>
<li><a href="/blog/2013/09/19/let-shell-command-efficient/">Shell</a></li>
<li><a href="/blog/2014/10/18/docker-dnsmasq-handler-hosts-build-hadoop-cluster/">Dnsmasq</a></li>
<li><a href="/blog/2015/09/06/squid-http-proxy-server-install/">squid</a></li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
</feed>
