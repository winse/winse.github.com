<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Winse Blog]]></title>
  <link href="http://winseliu.com/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://winseliu.com/"/>
  <updated>2018-06-21T13:19:03+08:00</updated>
  <id>http://winseliu.com/</id>
  <author>
    <name><![CDATA[Winse Liu]]></name>
    <email><![CDATA[winseliu@foxmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[斐讯K2刷机记录]]></title>
    <link href="http://winseliu.com/blog/2018/06/20/k2-reburn/"/>
    <updated>2018-06-20T23:08:28+08:00</updated>
    <id>http://winseliu.com/blog/2018/06/20/k2-reburn</id>
    <content type="html"><![CDATA[<p>很久以前就在JD弄了一个K2，当时没有啥需求，所以也没有折腾 。最近尝试DDNS域名绑定到动态的IP，想在家有一个能提供SSH访问的机器。原来的树莓派被弄坏了，就想着折腾折腾刷刷K2，在上面安装一个SSH。</p>

<p>同时也把官网提供的系统净化净化。</p>

<h2>原K2的详细信息</h2>

<p><a href="https://item.jd.com/2615810.html">斐讯K2 1200M智能双频无线路由器 WIFI穿墙 PSG1218</a></p>

<h2>了解刷机流程</h2>

<ul>
<li>官方版本可能存在的问题：</li>
</ul>


<p><a href="http://www.right.com.cn/forum/thread-208302-1-1.html">http://www.right.com.cn/forum/thread-208302-1-1.html</a></p>

<ul>
<li>刷机直接参考</li>
</ul>


<p><a href="http://www.right.com.cn/forum/thread-208753-1-1.html">【2017-12-01】斐讯K2 V22.5.9.163官方固件定制版,集成breed,支持官版直刷【V1.8】</a></p>

<h2>详细步骤</h2>

<ol>
<li><p>更新版本到 V22.5.9.163</p>

<p>查看官网提供的<a href="http://www.phicomm.com/cn/support.php/Soho/software_support/t/sm.html">软件</a>， 下载<a href="http://www.phicomm.com/cn/support.php/Soho/search_support/col/6/keys/k2.html">对应的版本</a></p>

<ul>
<li>K2_A2_V21.4.6.12.bin</li>
<li>K2_V22.5.9.163.bin</li>
</ul>
</li>
<li><p>刷净化版（带Bread）k2_163_v18_breed.rar</p>

<ul>
<li><p><a href="http://woo.iytc.net/?dir=uploads/K2">下载地址</a></p></li>
<li><p><a href="http://www.qqgzs.com/archives/k2-shuaji.html">breed刷入第三方固件</a></p>

<p> 进入Bread方法，这个了解下就行，这里不刷第三方的。</p>

<p> 拔除K2上Wan口的网线，路由器断电，持续按住路由器上的reset按钮，接通路由器电源，3秒后松开reset按钮。
 在浏览器地址栏输入 <a href="http://192.168.1.1">http://192.168.1.1</a> 访问Breed Web。</p></li>
</ul>
</li>
<li><p>启动telnet/手动安装SSH</p>

<ul>
<li><a href="http://iytc.net/wordpress/?p=1624">http://iytc.net/wordpress/?p=1624</a></li>
</ul>
</li>
</ol>


<p>3.1. 启动telnet</p>

<p>用 高级设置 - 系统设置 - WebShell 执行命令</p>

<pre><code>/www/cgi-bin# /usr/sbin/telnetd -l /bin/login.sh
</code></pre>

<p>直接连，不用密码！！</p>

<pre><code>winse@DESKTOP-ADH7K1Q:~$ telnet 192.168.2.1
</code></pre>

<p>同时修改下密码：</p>

<pre><code># 更改root密码为 admin
echo -e 'admin\nadmin' | passwd root
</code></pre>

<p></p>

<p>3.2. 安装SSH</p>

<p>这个版本没有带opkg，需要首先把opkg安装好。</p>

<ul>
<li><a href="https://www.ywlib.com/archives/102.html">小米路由3安装opkg</a></li>
<li><a href="https://www.ywlib.com/archives/101.html">解压OpenWRT固件bin文档提取文件</a></li>
</ul>


<p>直接下载 <a href="http://www.ywlib.com/usr/uploads/2017/05/387250260.zip">opkg.zip</a> 然后本地起一个 httpserver 提供一个下载的服务。</p>

<pre><code>winse@DESKTOP-ADH7K1Q:/mnt/e/SOFTWARE/k2$ python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...
</code></pre>

<p>在telnet窗口执行：</p>

<pre><code>root@K2:/www/cgi-bin# cd /bin
root@K2:/bin# wget http://192.168.2.160:8000/opkg
--2018-06-20 22:50:18--  http://192.168.2.160:8000/opkg
Connecting to 192.168.2.160:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 130247 (127K) [application/octet-stream]
Saving to: 'opkg'

opkg                                  100%[=========================================================================&gt;] 127.19K   176KB/s   in 0.7s

2018-06-20 22:50:18 (176 KB/s) - 'opkg' saved [130247/130247]

root@K2:/bin# chmod +x opkg


rm -rf /bin/opkg
</code></pre>

<p>注意：用完后就删掉吧，空间不够！！查看<a href="https://unix.stackexchange.com/questions/157097/how-to-know-disk-space-occupied-by-packages-in-openwrt">安装了那些软件</a></p>

<p></p>

<p>然后安装ssh：</p>

<pre><code>opkg install http://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/dropbear_2014.63-2_ramips_24kec.ipk
# 开机自启
/etc/init.d/dropbear enable

# https://openwrt.org/docs/guide-user/base-system/ssh_configuration
# https://wiki.openwrt.org/doc/uci/dropbear
vi /etc/config/dropbear
        option GatewayPorts '1'

# 启动
/etc/init.d/dropbear start

uci show dropbear

# 如果需要放开防火墙
iptables -I INPUT 1 -p tcp -m tcp --dport 22 -j ACCEPT


vi /etc/firewall.user
# 删除无用文件
rm -rf /etc/dropbear/dropbear_dss_host_key
</code></pre>

<p>注意：需要持久化的话，把这句开放22端口的指令写到 /etc/firewall.user 。</p>

<p></p>

<p>客户端登录：</p>

<pre><code>winse@DESKTOP-ADH7K1Q:~$ ssh root@192.168.2.1
The authenticity of host '192.168.2.1 (192.168.2.1)' can't be established.
RSA key fingerprint is SHA256:vuAY65qk3Us4MyjYT8KPT8lYsTSTqru6W4e7My6CRkk.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.2.1' (RSA) to the list of known hosts.
root@192.168.2.1's password:


BusyBox v1.22.1 (2017-02-15 13:52:46 CST) built-in shell (ash)
Enter 'help' for a list of built-in commands.

    ___  __ _______________  __  _____  ___  ________  ___
   / _ \/ // /  _/ ___/ __ \/  |/  /  |/  / / __/ __ \/ _ \
  / ___/ _  // // /__/ /_/ / /|_/ / /|_/ / _\ \/ /_/ / ___/
 /_/  /_//_/___/\___/\____/_/  /_/_/  /_/ /___/\____/_/
 ----------------------------------------------------------
 Barrier Breaker, unknown
 ----------------------------------------------------------
 PID=K2
 BUILD_TYPE=release
 BUILD_NUMBER=163
 BUILD_TIME=20170215-134532
 ----------------------------------------------------------
 MTK OpenWrt SDK V3.4
 revision : adab2180
 benchmark : APSoC SDK 5.0.1.0
 kernel : 144992
 ----------------------------------------------------------
root@K2:~#
</code></pre>

<p>不推荐用密码，最好使用公钥的方式来处理。<del>但公钥访问有点问题，.ssh的目录权限是个麻烦事</del> （其实文件的位置不对！！）。</p>

<p>参考： <a href="https://wiki.openwrt.org/doc/howto/dropbear.public-key.auth">Dropbear public-key authentication HowTo</a></p>

<blockquote><p>ssh <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x72;&#111;&#111;&#x74;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#x31;&#46;&#49;">&#x72;&#x6f;&#x6f;&#116;&#64;&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#x38;&#x2e;&#49;&#x2e;&#49;</a> &ldquo;tee -a /etc/dropbear/authorized_keys&rdquo; &lt; ~/.ssh/id_rsa.pub</p></blockquote>

<p>把 authorized_keys 文件移到 /etc/dropbear 下面就可以了！</p>

<pre><code>root@K2:~/.ssh# ls -la
drwx------    2 root     root             0 Jun 21 10:35 .
drwx------    1 root     root             0 Jun 21 08:57 ..
-rw-------    1 root     root           397 Jun 21 10:35 authorized_keys
root@K2:~/.ssh# mv authorized_keys /etc/dropbear/
</code></pre>

<p></p>

<h2>其他拓展</h2>

<h3>增加空间，挂载windows共享目录</h3>

<p><a href="https://blog.vircloud.net/linux/openwrt-psg1218.html">https://blog.vircloud.net/linux/openwrt-psg1218.html</a></p>

<p>K2 官方版式不带 USB，因此就限制了很多可玩的东西，但是我们可以通过 SMB 挂载的方式来增加存储空间，需要注意的是老毛子挂载 SMB 的方式与其他 OpenWRT 不同，使用 mount 命令是挂载不成功的，正确的方法是：</p>

<p>位置：高级设置 - 自定义设置 - 脚本 - 在路由器启动后执行
配置如下：</p>

<pre><code>### SMB资源挂载(局域网共享映射，无USB也能挂载储存空间)
### 说明：共享路径填写时，【\】要写成【\\】。
sleep 10
modprobe des_generic
modprobe cifs CIFSMaxBufSize=64512
#mkdir -p /media/cifs
#mount -t cifs \\\\{host}\\{share} /media/cifs -o username={user},password={pass}
mount -t cifs \\\\192.168.31.100\\移动磁盘-C /mnt -o username=guest,password=guest

sleep 10
mdev -s
sleep 5
stop_ftpsamba
sleep 2
run_ftpsamba
sleep 5
</code></pre>

<h3>Breed进入方式</h3>

<ol>
<li>将要刷的第三方固件准备好。</li>
<li>断电按着reset键不松手，然后通电5秒后再松开reset键。</li>
<li>打开浏览器输入<a href="http://192.168.1.1%E5%8D%B3%E5%8F%AFBreed">http://192.168.1.1%E5%8D%B3%E5%8F%AFBreed</a> Web恢复控制台（记得先在Breed Web恢复控制台中的固件备份里备份下EEPROM和编程器固件，以后可能用得着）。</li>
<li>恢复固件之前最好在Breed Web恢复控制台恢复一下出厂设置，固件类型：Config区（公版）</li>
</ol>


<p>参考：</p>

<ul>
<li><a href="https://github.com/moonjoin/k2-firmware">https://github.com/moonjoin/k2-firmware</a></li>
<li><a href="http://www.right.com.cn/forum/thread-161324-1-1.html">http://www.right.com.cn/forum/thread-161324-1-1.html</a></li>
<li><a href="https://www.c7cc.com/shuaji-chaiji/k1-k2-v21-4-6-10-telnet-ssh.html">https://www.c7cc.com/shuaji-chaiji/k1-k2-v21-4-6-10-telnet-ssh.html</a></li>
<li><a href="http://www.mm126.cc/319.html">http://www.mm126.cc/319.html</a></li>
<li><a href="http://www.qqgzs.com/archives/k2-22-6-503.html">http://www.qqgzs.com/archives/k2-22-6-503.html</a></li>
</ul>


<h2>其他参考</h2>

<ul>
<li><a href="https://www.jianshu.com/p/6be3639ff9e3">https://www.jianshu.com/p/6be3639ff9e3</a></li>
<li><a href="http://www.right.com.cn/forum/thread-184338-1-1.html">http://www.right.com.cn/forum/thread-184338-1-1.html</a></li>
<li><a href="http://www.cnblogs.com/lanye/p/6149242.html">http://www.cnblogs.com/lanye/p/6149242.html</a> 刷入 breed 和 ssh</li>
<li><a href="http://www.right.com.cn/forum/thread-189593-1-2.html">http://www.right.com.cn/forum/thread-189593-1-2.html</a> 安装SSH也是有多种方法</li>
<li><a href="https://www.cnblogs.com/xuliangxing/p/6486560.html">https://www.cnblogs.com/xuliangxing/p/6486560.html</a></li>
<li><a href="https://www.jianshu.com/p/275217976492">https://www.jianshu.com/p/275217976492</a> LEDE 是一个从 OpenWrt 中衍生出来的产品</li>
<li><a href="https://downloads.lede-project.org/releases/17.01.4/targets/ramips/mt7620/">https://downloads.lede-project.org/releases/17.01.4/targets/ramips/mt7620/</a></li>
<li><a href="https://bitbucket.org/stevengan/padavan/downloads/">https://bitbucket.org/stevengan/padavan/downloads/</a></li>
<li><a href="https://blog.aofall.com/archives/14.html">https://blog.aofall.com/archives/14.html</a></li>
<li><a href="http://www.hopol.cn/2017/05/853/">http://www.hopol.cn/2017/05/853/</a> 斐讯K2 163版配置文件加密破解过程。学学c++是怎么反编译的！！！！</li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用VMWare安装Mac OS X]]></title>
    <link href="http://winseliu.com/blog/2018/06/19/install-macosx-on-vmware/"/>
    <updated>2018-06-19T23:05:55+08:00</updated>
    <id>http://winseliu.com/blog/2018/06/19/install-macosx-on-vmware</id>
    <content type="html"><![CDATA[<p>参考：</p>

<ul>
<li><a href="http://www.yhy0.com/ios_20160413_269.html">VMware Workstation 12 Pro如何安装Mac OS X 10.11.1</a></li>
<li><a href="https://blog.csdn.net/yongh701/article/details/70597982">【iOS】VMWare中MAC OS X的安装，VMWare tools的配置与iOS的Helloworld</a></li>
</ul>


<p>实际操作：</p>

<ul>
<li>安装 VMware-workstation-full-12.5.7-5813279 。</li>
<li>下载 unlocker208.zip 并使用管理员权限安装 win-install.cmd 。</li>
<li>添加虚拟机，选择 Apple Mac OS X(M) - OS X 10.9；然后修改vmx配置，在 <code>smc.present = "TRUE"</code> 后面添加 <code>smc.version = "0"</code></li>
<li>然后光盘选择 Mavericks_Install_13A603.cdr 安装系统。磁盘格式化：<code>实用工具 - 磁盘工具</code> 。</li>
<li>安装VMWare Tools。光盘选择 darwiniso.zip 压缩包里面的 darwin6.0.3.iso 。</li>
<li>配置共享文件夹。进入系统后，<code>Finder - 偏好设置 -  已连接的服务器</code> 。</li>
</ul>


<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[科学上网（续）]]></title>
    <link href="http://winseliu.com/blog/2018/06/09/reasonable-way-to-access-the-internet/"/>
    <updated>2018-06-09T14:03:11+08:00</updated>
    <id>http://winseliu.com/blog/2018/06/09/reasonable-way-to-access-the-internet</id>
    <content type="html"><![CDATA[<p>到新的环境就会遇到新的问题，需要不断的学习更新来适应新的环境。上网也是一样，工作地点和家里存在了一道鸿沟。过去断断续续的有一些解决的方式，但是总是有点间接。</p>

<ul>
<li><a href="http://www.winseliu.com/blog/2017/11/04/teamviewer-vpn-on-windows/">使用TeamviewerVPN访问公司内网</a></li>
<li><a href="http://www.winseliu.com/blog/2017/02/04/privoxy-http-proxy-for-shadowsocks/">使用Privoxy把shadowsocks转换为Http代理</a></li>
<li><a href="http://www.winseliu.com/blog/2016/03/11/install-and-config-openvpn/">安装配置OpenVPN</a></li>
<li><a href="http://www.winseliu.com/blog/2015/11/22/gfw-ladder/">搭梯笔记</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">SSH原理与运用（二）：远程操作与端口转发</a></li>
<li><a href="http://www.winseliu.com/blog/2015/09/06/squid-http-proxy-server-install/">安装http代理服务器squid</a></li>
<li><a href="http://www.winseliu.com/blog/2017/10/30/windows-run-ubuntu/">Windows Run Ubuntu</a></li>
</ul>


<p>上周和同事讨论到在家访问公司服务器的方式时，可以通过花生壳的DDNS来实现域名动态绑定，相当于了把家里的宽带看做一个公网IP，花生壳实时的把域名解析更新为最新的IP。</p>

<p>有了公网IP后，就可以在公司访问自己的域名（绑定到了家里的IP），然后 反向代理 就可以在家访问公司环境了。</p>

<p>但是查了下对于花生壳的口碑都不咋的，其实只要能自动的更新绑定域名和宽带的IP，和花生壳的效果是一样。然后在 github 查到了 <a href="https://github.com/yyqian/aliyun-ddns">aliyun-ddns</a> 定时检测和更新阿里云上的域名解析。</p>

<h2>配置公网域名</h2>

<p>我在此基础上调整了一个<a href="https://github.com/winse/aliyun-ddns">本地命令行版本</a> ，直接运行一个脚本就可以更新域名解析了：</p>

<pre><code>./client.sh myhome.winseliu.com
</code></pre>

<p><img src="/images/blogs/aliyun-dns.png" alt="" /></p>

<p>注：默认电信宽带给你分配的内网IP的，你可以打10000号要他们给你分配改成外网IP。</p>

<h2>本地环境配置</h2>

<ul>
<li>本机SSHD配置</li>
</ul>


<pre><code>winse@DESKTOP-ADH7K1Q:~$ sudo dpkg-reconfigure openssh-server
winse@DESKTOP-ADH7K1Q:~$ sudo service ssh start
</code></pre>

<p>注：启动后，wsl shell窗口不能关！！窗口关闭后，wsl的所有服务都会停掉！</p>

<ul>
<li>无秘钥登录</li>
</ul>


<p>为了安全，最好通过秘钥登录，把使用SSH的密码登录关掉。</p>

<pre><code>winse@DESKTOP-ADH7K1Q:~/.ssh$ cat /business/server/id_rsa.pub &gt;&gt;authorized_keys
</code></pre>

<p></p>

<ul>
<li>路由器配置</li>
</ul>


<p><img src="/images/blogs/ddns-route-portforwarding.png" alt="" /></p>

<ul>
<li>本机防火墙</li>
</ul>


<p>参考 <a href="https://blog.csdn.net/zzq900503/article/details/11936379">开放windows服务器端口&mdash;&ndash;以打开端口8080为例</a></p>

<p><img src="/images/blogs/ddns-local-firewall.png" alt="" /></p>

<h2>配置反向代理</h2>

<p>服务端访问自己域名，使用 -R 参数在本地创建一个10022的端口，数据转发到服务器的22端口。当你连本地的 127.0.0.1:10022 就相当于连接服务器的 22 端口。</p>

<pre><code>/usr/bin/autossh -M 0 -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -o StrictHostKeyChecking=no -NR 10022:localhost:22 autossh@myhome.winseliu.com -i ~/.ssh/id_rsa
</code></pre>

<p></p>

<p>当连接太慢、SSH提示信息一直不出来，你完全有理由怀疑本地端口被占用了！！查看本地端口状态：</p>

<pre><code>C:\Users\winse&gt;netstat /?

C:\Users\winse&gt;netstat -ano |findstr 10022
</code></pre>

<p>如果端口被占用了，需要去任务管理器中关掉对应的PID的程序。</p>

<p></p>

<h2>小结</h2>

<p>速度比 teamviewer vpn 的方式快狠多狠多！！这个10000号值得打，这个ddns值得一试。</p>

<h2>后记</h2>

<h3>说说 VS Code调试</h3>

<p>使用Ubuntu中安装的Node：</p>

<ul>
<li><a href="https://blogs.msdn.microsoft.com/commandline/2017/10/27/running-node-js-on-wsl-from-visual-studio-code/">Running Node.js on WSL from Visual Studio Code</a></li>
<li><a href="https://stackoverflow.com/a/47495710/5697508">Using Visual Studio Code on Windows with Ubuntu-Bash and NodeJS</a></li>
</ul>


<pre><code>"useWSL": true
</code></pre>

<p><a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging">https://code.visualstudio.com/docs/nodejs/nodejs-debugging</a></p>

<p>注意：这种外部启动的方式，会通过bash.sh运行node，所以就算停止调试后，Node进程还是一直存在的！！！需要通过任务管理器关闭。</p>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中使用代理-基于Shandowsocks]]></title>
    <link href="http://winseliu.com/blog/2018/01/26/proxy-on-java-via-shandowsocks/"/>
    <updated>2018-01-26T20:50:05+08:00</updated>
    <id>http://winseliu.com/blog/2018/01/26/proxy-on-java-via-shandowsocks</id>
    <content type="html"><![CDATA[<p>在开发过程中，时不时需要要代理一下，来访问我们需要的资源，比方说：DEBUG生产<strong>集群</strong>的应用、还有在Java中翻墙等等。解决了全局的代理能完成我们访问到资源的时刻，又有新的要求，比方说：只有特定的资源走代理等等。</p>

<p>下面把要点简单罗列下，以供参考：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/1432961/how-do-i-make-httpurlconnection-use-a-proxy">https://stackoverflow.com/questions/1432961/how-do-i-make-httpurlconnection-use-a-proxy</a></li>
<li><a href="http://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html">http://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html</a></li>
<li><a href="https://stackoverflow.com/questions/120797/how-do-i-set-the-proxy-to-be-used-by-the-jvm">https://stackoverflow.com/questions/120797/how-do-i-set-the-proxy-to-be-used-by-the-jvm</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html">https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html</a></li>
</ul>


<p>JDK官网的都全部包括了，其他的辅助，看看人家的具体需求。</p>

<h2>Java全应用代理（全局）</h2>

<ul>
<li>走HTTP</li>
</ul>


<p>Shandowsocks转HTTP，前面Docker翻墙安装Kubernate有弄过，参考：<a href="/blog/2017/02/04/privoxy-http-proxy-for-shadowsocks/">Privoxy</a> 。</p>

<p>也可以直接用Shandowsocks提供的 <code>启用系统代理 -&gt; 系统代理模式 -&gt; 全局模式</code> 来转换，启用HTTP代理功能。（开全局模式，本地会把socks代理转成为一个http的代理）</p>

<pre><code>-Dhttp.proxyHost=127.0.0.1
-Dhttp.proxyPort=7070
-Dhttps.proxyHost=127.0.0.1
-Dhttps.proxyPort=7070
-Dhttp.nonProxyHosts="localhost|127.0.0.1|192.168.*"
</code></pre>

<blockquote><ul>
<li>http.proxyHost: the host name of the proxy server</li>
<li>http.proxyPort: the port number, the default value being 80.</li>
<li>http.nonProxyHosts:a list of hosts that should be reached directly, bypassing the proxy. This is a list of patterns separated by &lsquo;|&rsquo;. The patterns may start or end with a &lsquo;*&rsquo; for wildcards. Any host matching one of these patterns will be reached through a direct connection instead of through a proxy.</li>
</ul>
</blockquote>

<p></p>

<ul>
<li>走Socks</li>
</ul>


<pre><code>-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=7070
</code></pre>

<ul>
<li>使用系统代理</li>
</ul>


<pre><code>-Djava.net.useSystemProxies=true
</code></pre>

<h2>部分（自动切换）</h2>

<ul>
<li>应用内通过 setProperty <strong>临时</strong> 设置</li>
</ul>


<pre><code>System.setProperty("http.proxyHost", proxyHost);
System.setProperty("http.proxyPort", proxyPort);
System.setProperty("https.proxyHost", proxyHost);
System.setProperty("https.proxyPort", proxyPort);
</code></pre>

<p>用完之后，取消设置：</p>

<pre><code>System.clearProperty("http.proxyHost");
...
</code></pre>

<ul>
<li>请求时指定代理：</li>
</ul>


<pre><code>SocketAddress addr = new InetSocketAddress("webcache.example.com", 8080);
Proxy proxy = new Proxy(Proxy.Type.HTTP, addr);

URL url = new URL("http://java.example.org/");
URLConnection conn = url.openConnection(proxy);
</code></pre>

<ul>
<li>（选择性的）配置哪些访问走代理：ProxySelector</li>
</ul>


<p>任何请求访问网络之前，会被ProxySelector拦截。根据规则获取一个符合的Proxy（或者Proxy.NO_PROXY），然后通过这个代理去访问网络。</p>

<blockquote><p>As you can see, with Java SE 5.0, the developer gains quite a bit of control and flexibility when it comes to proxies. Still, there are situations where one would like to decide which proxy to use dynamically, for instance to do some load balancing between proxies, or depending on the destination, in which case the API described so far would be quite cumbersome. That&rsquo;s where the ProxySelector comes into play.</p>

<p>The best thing about the ProxySelector is that it is plugable! Which means that if you have needs that are not covered by the default one, you can write a replacement for it and plug it in!</p></blockquote>

<p>基本上看JDK官网的内容就好了，也参考下 <a href="http://archive.oreilly.com/pub/a/onjava/excerpt/jvntwkprg_3e/index.html?page=3#javanp3-CHP-7-SECT-4">URLs and URIs, Proxies and Passwords</a></p>

<p>注册自定义的Selector：</p>

<pre><code>public static void main(String[] args) {
    MyProxySelector ps = new MyProxySelector(ProxySelector.getDefault());
    ProxySelector.setDefault(ps);
    // rest of the application
}
</code></pre>

<p>Selector实现：</p>

<pre><code>public class MyProxySelector extends ProxySelector {
    // Keep a reference on the previous default
    ProxySelector defsel = null;

    /*
     * Inner class representing a Proxy and a few extra data
     */
    class InnerProxy {
        Proxy proxy;
        SocketAddress addr;
        // How many times did we fail to reach this proxy?
        int failedCount = 0;

        InnerProxy(InetSocketAddress a) {
            this(a, Proxy.Type.HTTP);
        }

        InnerProxy(InetSocketAddress a, Proxy.Type type) {
            addr = a;
            proxy = new Proxy(type, a);
        }

        SocketAddress address() {
            return addr;
        }

        Proxy toProxy() {
            return proxy;
        }

        int failed() {
            return ++failedCount;
        }
    }

    /*
     * A list of proxies, indexed by their address.
     */
    HashMap&lt;SocketAddress, InnerProxy&gt; proxies = new HashMap&lt;SocketAddress, InnerProxy&gt;();

    MyProxySelector(ProxySelector def) {
        // Save the previous default
        defsel = def;

        // Populate the HashMap (List of proxies)
        InnerProxy i = new InnerProxy(new InetSocketAddress("webcache1.example.com", 8080));
        proxies.put(i.address(), i);
        i = new InnerProxy(new InetSocketAddress("webcache2.example.com", 8080));
        proxies.put(i.address(), i);
        i = new InnerProxy(new InetSocketAddress("webcache3.example.com", 8080));
        proxies.put(i.address(), i);
    }

    /*
     * This is the method that the handlers will call.
     * Returns a List of proxy.
     */
    public java.util.List&lt;Proxy&gt; select(URI uri) {
        // Let's stick to the specs. 
        if (uri == null) {
            throw new IllegalArgumentException("URI can't be null.");
        }

        /* 这里可以指定你自己的规则/配置
         * If it's a http (or https) URL, then we use our own list.
         */
        String protocol = uri.getScheme();
        if ("http".equalsIgnoreCase(protocol) ||
                "https".equalsIgnoreCase(protocol)) {
            ArrayList&lt;Proxy&gt; l = new ArrayList&lt;Proxy&gt;();
            for (InnerProxy p : proxies.values()) {
                l.add(p.toProxy());
            }
            return l;
        }

        /*
         * Not HTTP or HTTPS (could be SOCKS or FTP)
         * defer to the default selector.
         */
        if (defsel != null) {
            return defsel.select(uri);
        } else {
            ArrayList&lt;Proxy&gt; l = new ArrayList&lt;Proxy&gt;();
            l.add(Proxy.NO_PROXY);
            return l;
        }
    }

    /*
     * Method called by the handlers when it failed to connect
     * to one of the proxies returned by select().
     */
    public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
        // Let's stick to the specs again.
        if (uri == null || sa == null || ioe == null) {
            throw new IllegalArgumentException("Arguments can't be null.");
        }

        /*
         * Let's lookup for the proxy 
         */
        InnerProxy p = proxies.get(sa); 
        if (p != null) {
            /*
             * It's one of ours, if it failed more than 3 times
             * let's remove it from the list.
             */
            if (p.failed() &gt;= 3)
                    proxies.remove(sa);
        } else {
            /*
             * Not one of ours, let's delegate to the default.
             */
            if (defsel != null)
              defsel.connectFailed(uri, sa, ioe);
        }
    }
}
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed Debug: Sedsed]]></title>
    <link href="http://winseliu.com/blog/2017/11/20/sed-debug-sedsed/"/>
    <updated>2017-11-20T23:54:11+08:00</updated>
    <id>http://winseliu.com/blog/2017/11/20/sed-debug-sedsed</id>
    <content type="html"><![CDATA[<p>上一篇把html转成rst，但是页面之间的链接都断了。需要在标题前加上一个TAG，最终效果如下：</p>

<pre><code>
.. _Creating Objects in New Mappings:

Creating Objects in New Mappings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+ :ref:`Creating Objects in New Mappings`
</code></pre>

<p>想使用sed来实现这个功能，需要利用一些sed的高级功能，但默认sed是不能调试。这里使用sedsed来查看每一个操作的模式空间和缓冲空间，有点类似print调试。对于理解 sed 很有帮助，特别是对理解缓冲区和模式区数据的处理。</p>

<h4>安装 sedsed</h4>

<ul>
<li><a href="http://aurelio.net/projects/sedsed/#usage">官网文档</a></li>
</ul>


<pre><code>cd /opt/
git clone https://github.com/aureliojargas/sedsed
</code></pre>

<p>看看实际的调试输出：</p>

<pre><code>[root@ansible sedsed]# echo -e "one\ntwo\nthree\nfour" | ./sedsed.py -d -f test/scripts/sort.gnu.sed 
PATT:one$
HOLD:$
COMM:H
PATT:one$
HOLD:\none$
COMM:$ !d
PATT:two$
HOLD:\none$
COMM:H
PATT:two$
HOLD:\none\ntwo$
COMM:$ !d
PATT:three$
HOLD:\none\ntwo$
COMM:H
PATT:three$
HOLD:\none\ntwo\nthree$
COMM:$ !d
PATT:four$
HOLD:\none\ntwo\nthree$
COMM:H
PATT:four$
HOLD:\none\ntwo\nthree\nfour$
COMM:$ !d
PATT:four$
HOLD:\none\ntwo\nthree\nfour$
COMM:g
PATT:\none\ntwo\nthree\nfour$
HOLD:\none\ntwo\nthree\nfour$
COMM:s/.//
PATT:one\ntwo\nthree\nfour$
HOLD:\none\ntwo\nthree\nfour$
COMM:s/\n/&amp;L&amp;l/g
PATT:one\nL\nltwo\nL\nlthree\nL\nlfour$
HOLD:\none\ntwo\nthree\nfour$
COMM:s/^/\\Na/
PATT:\naone\nL\nltwo\nL\nlthree\nL\nlfour$
HOLD:\none\ntwo\nthree\nfour$
COMM:s/\nL/\\NA/
PATT:\naone\nA\nltwo\nL\nlthree\nL\nlfour$
HOLD:\none\ntwo\nthree\nfour$
COMM:s/$/\\NL/
PATT:\naone\nA\nltwo\nL\nlthree\nL\nlfour\nL$
HOLD:\none\ntwo\nthree\nfour$
COMM:b start
COMM:/\nA$/ b exit
COMM:s/\nb/\\Nl/
PATT:\naone\nA\nltwo\nL\nlthree\nL\nlfour\nL$
HOLD:\none\ntwo\nthree\nfour$
COMM:s/\nB/\\NL/
PATT:\naone\nA\nltwo\nL\nlthree\nL\nlfour\nL$
HOLD:\none\ntwo\nthree\nfour$
COMM:s/\(\na.*\nA\)\nl\([^\n]*\)\nL/\1\\Nb\2\\NB/
PATT:\naone\nA\nbtwo\nB\nlthree\nL\nlfour\nL$
HOLD:\none\ntwo\nthree\nfour$
COMM::sort
COMM:h
......

[root@ansible sedsed]# (date +'%w %d' ; date +'%-m %Y') | ./sedsed.py -d -f test/scripts/cal.sed
......
</code></pre>

<h4>网上的一案例</h4>

<p>看到一个<a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;tid=3775201&amp;page=1#pid22315115">论坛帖子</a>上用sed实现 <strong>删除匹配的前两行和后三行</strong> ，看的不是很明白，帖子仅注意介绍流程，至于数据到底是怎么样的没有讲。如果知道 sedsed 这工具的话，运行一遍就全部清楚了：</p>

<p>sedsed.py 处理 <code>+</code> 加号有点问题，所以这里就处理匹配的前两行，看看具体的数据是怎么流转的：</p>

<pre><code>[root@ansible sedsed]# echo -e "1\n2\n3\n4\n5\n6\n7\n8\n9\n10" | ./sedsed.py -d '/5/d;:go;1,2!{P;N;D};N;bgo' 
PATT:1$
HOLD:$
COMM:/5/ d
PATT:1$
HOLD:$
COMM::go
COMM:1,2 !{
COMM:N
PATT:1\n2$
HOLD:$
COMM:b go
COMM:1,2 !{
COMM:N
PATT:1\n2\n3$
HOLD:$
COMM:b go
COMM:1,2 !{
COMM:P
1
PATT:1\n2\n3$
HOLD:$
COMM:N
PATT:1\n2\n3\n4$
HOLD:$
COMM:D
PATT:2\n3\n4$
HOLD:$
COMM:/5/ d
PATT:2\n3\n4$
HOLD:$
COMM::go
COMM:1,2 !{
COMM:P
2
PATT:2\n3\n4$
HOLD:$
COMM:N
PATT:2\n3\n4\n5$
HOLD:$
COMM:D
PATT:3\n4\n5$
HOLD:$
COMM:/5/ d
PATT:6$
HOLD:$
COMM:/5/ d
PATT:6$
HOLD:$
COMM::go
COMM:1,2 !{
COMM:P
6
PATT:6$
HOLD:$
COMM:N
PATT:6\n7$
HOLD:$
COMM:D
PATT:7$
HOLD:$
COMM:/5/ d
PATT:7$
HOLD:$
COMM::go
COMM:1,2 !{
COMM:P
7
PATT:7$
HOLD:$
COMM:N
PATT:7\n8$
HOLD:$
COMM:D
PATT:8$
HOLD:$
COMM:/5/ d
PATT:8$
HOLD:$
COMM::go
COMM:1,2 !{
COMM:P
8
PATT:8$
HOLD:$
COMM:N
PATT:8\n9$
HOLD:$
COMM:D
PATT:9$
HOLD:$
COMM:/5/ d
PATT:9$
HOLD:$
COMM::go
COMM:1,2 !{
COMM:P
9
PATT:9$
HOLD:$
COMM:N
PATT:9\n10$
HOLD:$
COMM:D
PATT:10$
HOLD:$
COMM:/5/ d
PATT:10$
HOLD:$
COMM::go
COMM:1,2 !{
COMM:P
10
PATT:10$
HOLD:$
COMM:N
10
</code></pre>

<p>可以看到 <strong>PATT</strong> 模式空间把前面两行连到一起了，匹配到 <strong>5</strong> 的时刻其实模式空间的内容为 <strong>3\n4\n5</strong>，然后执行 <strong>d</strong> 这就相当于删除前两行了。</p>

<p>该命令会多输出最后一行：由于到最后一行，N 又读取了一次下一行（读到结束符），直接就返回没有执行 D 了。sed 文档中的描述如下：</p>

<pre><code>  `D'
      If pattern space contains no newline, start a normal new cycle as
      if the `d' command was issued.  Otherwise, delete text in the
      pattern space up to the first newline, and restart cycle with the
      resultant pattern space, without reading a new line of input.

  `N'
      Add a newline to the pattern space, then append the next line of
      input to the pattern space.  If there is no more input then `sed'
      exits without processing any more commands.
</code></pre>

<p>修复就是：读到最后一行的时刻就不读下一行了：</p>

<pre><code>[root@ansible sedsed]# echo -e "1\n2\n3\n4\n5\n6\n7\n8\n9\n10" | sed '/5/,+3d;:go;1,2!{P;$!N;D};N;bgo' 
</code></pre>

<p></p>

<h4>加标签</h4>

<p>Sphinx可以通过 <strong>ref</strong> 来访问整个文档中定义的标签。所以只需要在每个标题前加上TAG，然后把链接引用修改成 <strong>ref</strong> 的方式即可。</p>

<pre><code># 文档加TAG：
sed -i ' h;N; /\n=\+$/{ x;s/.*/.. _&amp;:\n/;p; x };  P;D ' $(find . -name '*.rst')
sed -i ' h;N; /\n-\+$/{ x;s/.*/.. _&amp;:\n/;p; x };  P;D ' $(find . -name '*.rst')


# 修改链接引用：
sed 's/\(`[[:alnum:] ]*`\)_/:ref:\1/ ' $(find . -name '*.rst')
</code></pre>

<p>&ndash;END</p>
]]></content>
  </entry>
  
</feed>
