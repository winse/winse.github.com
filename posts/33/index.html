
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Winse Blog</title>
  <meta name="author" content="Winse Liu">

  
  <meta name="description" content="Scala借鉴了python、ruby等函数式语言。从java转过来还是需要一个适应阶段，与groovy比似乎困难多了不少。一年前好奇接触过，看了一些官网的入门教程，觉得这就是一个异类，后面就放下了。 直到再次弄hadoop，接触spark。经过一个时间的过渡期后， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://winse.github.io/posts/33">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="/atom.xml" rel="alternate" title="Winse Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/libs/jquery.toc.min.js" type="text/javascript"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

<script src="/javascripts/generate-toc.js" type="text/javascript"></script>


  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43198550-1', 'auto');
  ga('send', 'pageview');

</script>



</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Winse Blog</a></h1>
  
    <h2>走走停停, 熙熙攘攘, 忙忙碌碌, 不知何畏.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:winse.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="站内搜索"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/archives/updated.html">Updated</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/08/note-beginning-scala-part1/">【笔记】Beginning Scala（1）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-08T07:36:57+08:00" pubdate data-updated="true">Mon 2014-09-08 07:36</time>
		
        
		
      </p>
    
  </header>


  <div class="entry-content"><p>Scala借鉴了python、ruby等函数式语言。从java转过来还是需要一个适应阶段，与groovy比似乎困难多了不少。一年前好奇接触过，看了一些官网的入门教程，觉得这就是一个异类，后面就放下了。</p>

<p>直到再次弄hadoop，接触spark。经过一个时间的过渡期后，发现Scala确实能处理java的一些繁琐问题，为我们的双手减负，写出更简洁更优雅的代码，或者说更”易懂“。</p>

<p><strong>这篇是第一章（About Scala and How to Install It）和第二章（Scala Syntax, Scripts, and Your First Scala Programs）的笔记。</strong></p>

<p>作者寄语：</p>

<blockquote><p>My Path was hard, and I hope yours will be easier.</p></blockquote>

<h2>历史与安装</h2>

<p>随着HotSpot对JVM的改进，JDK1.3的程序与C++写的程序一样快。Java程序可以运行几个星期、几个月、甚至一年都不用重启。</p>

<p>好的Java代码与C/C++的代码一样快，甚至更快。在同样功能下，经过深度调优的C/C++程序会比Java程序更高效，与C/C++相比Java程序需要更多的内存，但对于一个适度复杂的项目（非系统内核级别），JVM程序将比C/C++表现的更优异。</p>

<p>这么多年来，Java在语言级别还不成熟。Java语法停滞不前，Java上的web框架越来越笨重。处理XML，或者其他一些简单概念的实现，如字段生成前台的HTML表单，需要越来越多的代码。对Java越来越失望。
Java5增加了枚举和泛型，对语言而言这是一个可喜的消息，但编码方面我们不得不使用IDE来完成Java代码编写。</p>

<p>“写Scala”的Martin Odersky曾编写了java编译器和泛型功能。Scala(2001, first version in 2003)，语法表达能力如ruby，但同时有Java的强类型和高性能。</p>

<p>Scala即快又简洁，同时类型安全。Scala运行效率也很高，最终编译成Java字节码跑在JVM上，又能与Java代码互相调用。</p>

<blockquote><p>But most importantly, Scala taught me  to program and reason about programming differently. I stopped thinking in terms of allocating buffers, structs, and objects, and of changing those pieces of memory. Instead, I learned to think about most of my programs as transforming input to output. This change in thinking has lead to lower defect rates, more modular code, and more testable code. Scala has also given me the tools to write smaller, more modular units of code and asse mble them together into a whole that is maintainable, yet far more complex than anything that I could write in Java or Ruby for that matter.</p></blockquote>

<p>下载安装JDK6+配置PATH, <a href="http://scala-lang.org/download/2.10.4.html">Scala 2.10+</a>下载zip版本的，然后解压就行了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>winse@Lenovo-PC /cygdrive/d/scala/bin
</span><span class='line'>$ ls -1
</span><span class='line'>fsc
</span><span class='line'>fsc.bat
</span><span class='line'>scala
</span><span class='line'>scala.bat
</span><span class='line'>scalac
</span><span class='line'>scalac.bat
</span><span class='line'>scaladoc
</span><span class='line'>scaladoc.bat
</span><span class='line'>scalap
</span><span class='line'>scalap.bat
</span><span class='line'>
</span><span class='line'>winse@Lenovo-PC /cygdrive/d/scala/bin
</span><span class='line'>$ scala
</span><span class='line'>Welcome to Scala version 2.10.4 (Java HotSpot(TM) Client VM, Java 1.7.0_02).
</span><span class='line'>Type in expressions to have them evaluated.
</span><span class='line'>Type :help for more information.
</span><span class='line'>
</span><span class='line'>scala&gt; def fact(n:Int)=1 to n reduceLeft(_*_) // n!
</span><span class='line'>fact: (n: Int)Int
</span><span class='line'>
</span><span class='line'>scala&gt; fact(5)
</span><span class='line'>res0: Int = 120</span></code></pre></td></tr></table></div></figure>


<h2>语法结构，第一个Scala程序</h2>

<p>运行程序的三种方式：</p>

<ul>
<li>命令行交互式的REPL（read-eval-print loop)</li>
<li>shell/cmd脚本</li>
<li>编译打包成jar后运行，跟Java一样</li>
</ul>


<h3>REPL</h3>

<p>进入到Scala的bin目录下，双击scala.bat打开。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; 1+1
</span><span class='line'>res0: Int = 2
</span><span class='line'>
</span><span class='line'>scala&gt; res0*8
</span><span class='line'>res1: Int = 16
</span><span class='line'>
</span><span class='line'>scala&gt; val x="hello world"
</span><span class='line'>x: String = hello world
</span><span class='line'>
</span><span class='line'>scala&gt; var xl=x.length
</span><span class='line'>xl: Int = 11
</span><span class='line'>
</span><span class='line'>scala&gt; import java.util._
</span><span class='line'>import java.util._
</span><span class='line'>
</span><span class='line'>scala&gt; val d = new Date
</span><span class='line'>d: java.util.Date = Mon Sep 08 09:17:08 CST 2014</span></code></pre></td></tr></table></div></figure>


<h3>脚本</h3>

<p>脚本中无需显示的定义main方法，当你运行脚本时，Scala把整个文件的内容添加到类的main方法中，编译代码，然后运行生成的main方法。你只需在脚本文件中编写scala代码即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>winse@Lenovo-PC ~
</span><span class='line'>$ scala hello.scala
</span><span class='line'>hello world
</span><span class='line'>
</span><span class='line'>winse@Lenovo-PC ~
</span><span class='line'>$ cat hello.scala
</span><span class='line'>println("hello world")</span></code></pre></td></tr></table></div></figure>


<h3>编译后运行</h3>

<p>运行方式和javac类似，会生成对应类的字节码class文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>winse@Lenovo-PC ~/scala-hello
</span><span class='line'>$ scalac hello.scala
</span><span class='line'>
</span><span class='line'>winse@Lenovo-PC ~/scala-hello
</span><span class='line'>$ ll
</span><span class='line'>total 13
</span><span class='line'>-rwxr-xr-x  1 winse None 2067 Sep  8 09:27 hello$.class
</span><span class='line'>-rwxr-xr-x  1 winse None  704 Sep  8 09:27 hello$delayedInit$body.class
</span><span class='line'>-rwxr-xr-x  1 winse None  921 Sep  8 09:27 hello.class
</span><span class='line'>-rw-r--r--+ 1 winse None   58 Sep  8 09:26 hello.scala
</span><span class='line'>
</span><span class='line'>winse@Lenovo-PC ~/scala-hello
</span><span class='line'>$ cat hello.scala
</span><span class='line'>object hello extends App {
</span><span class='line'>
</span><span class='line'>  println("hello world")
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>winse@Lenovo-PC ~/scala-hello
</span><span class='line'>$ scala hello
</span><span class='line'>hello world
</span></code></pre></td></tr></table></div></figure>


<p>编译器的启动是很耗时的操作，你可以使用fsc（fast Scala Compiler），fsc是单独运行在后台的编译进程。</p>

<p>如果你原有的项目中使用Ant或Maven，scala有对应的插件，可以很容易把Scala集成到项目中。</p>

<h3>First Scala Programs</h3>

<p>在Scala，你可以编写像ruby和python脚本语言代码。如输出“hello world”的println方法，封装了System.out.println()。因为太常用了，println被定义在Scala的Predef（预定义成员）中，每个程序都会自动加载，就像java.lang会自动引入到每个java程序一样。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("hello world")
</span><span class='line'>
</span><span class='line'>for {i&lt;- 1 to 10}
</span><span class='line'>  println(i)
</span><span class='line'>
</span><span class='line'>for {i&lt;- 1 to 10
</span><span class='line'>     j&lt;- 1 to 10}
</span><span class='line'>  println(i*j)
</span></code></pre></td></tr></table></div></figure>


<p>99乘法表：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; for(i&lt;- 1 to 9){
</span><span class='line'>     | for(j&lt;- 1 to i)
</span><span class='line'>     | printf("%s*%s=%2s\t",j,i,i*j);
</span><span class='line'>     |
</span><span class='line'>     | println()
</span><span class='line'>     | }
</span><span class='line'>1*1= 1
</span><span class='line'>1*2= 2  2*2= 4
</span><span class='line'>1*3= 3  2*3= 6  3*3= 9
</span><span class='line'>1*4= 4  2*4= 8  3*4=12  4*4=16
</span><span class='line'>1*5= 5  2*5=10  3*5=15  4*5=20  5*5=25
</span><span class='line'>1*6= 6  2*6=12  3*6=18  4*6=24  5*6=30  6*6=36
</span><span class='line'>1*7= 7  2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49
</span><span class='line'>1*8= 8  2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64
</span><span class='line'>1*9= 9  2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81</span></code></pre></td></tr></table></div></figure>


<p>编写复杂点的程序，可以使用<a href="http://scala-ide.org/">Scala-IDE</a>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import scala.io._   // like java import scala.io.*
</span><span class='line'>
</span><span class='line'>def toInt(in: String): Option[Int] =
</span><span class='line'>  try {
</span><span class='line'>    Some(Integer.parseInt(in.trim))
</span><span class='line'>  } catch {
</span><span class='line'>    case e: NumberFormatException =&gt; None
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>def sum(in: Seq[String]) = {
</span><span class='line'>  val ints = in.flatMap(s =&gt; toInt(s))
</span><span class='line'>  ints.foldLeft(0)((a, b) =&gt; a + b)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println("Enter some numbers and press CTRL+C")
</span><span class='line'>
</span><span class='line'>val input = Source.fromInputStream(System.in)
</span><span class='line'>val lines = input.getLines.toSeq
</span><span class='line'>
</span><span class='line'>println("Sum " + sum(lines))
</span></code></pre></td></tr></table></div></figure>


<p>Option是包含一个或零个对象的容器。如果不包含元素，返回的是单例的None。如果包括一个元素，就是新的Some(theElement)的实例。Option是Scala中避免空指针异常（null pointer）和显示进行null检查的处理一种方式。如果是None，一个业务逻辑将应用到0个元素，是Some就应用到一个元素上。</p>

<p>方法没有显示的return语句，默认就是方法“最后”（逻辑上最后执行的）一个语句的返回值。</p>

<p>sum方法的参数Seq是一个trait（类似java interface），是Array，List以机构其他顺序集合的父trait。trait拥有java interface的所有特性，同时traits可以包括方法的实现。你可以混合很多的traits成一个类。Traits除了不能定义有参构造函数外，其他和类一样。trait使得“多重继承”简单化，无需担忧<strong> the diamond problem</strong>（有点类似近亲结婚 ^ v ^）。</p>

<p>如：当BC都实现了M方法，D不知道用谁的M，会有歧义！！</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Diamond_inheritance.svg/220px-Diamond_inheritance.svg.png" alt="" /></p>

<p>在Scala中，定义参数分为val和var，val类似于java final，var类似于java的变量定义。对于不变化的变量，定义为val可以减少代码错误几率，进行防御性的编程。</p>

<p>接下来运行程序， 输入一些数字后按CTRL+C结束，就会输出计算的和。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:\local\home\Administrator\scala-hello&gt;scala Sum.scala
</span><span class='line'>Enter some numbers and press CTRL+C
</span><span class='line'>12
</span><span class='line'>23
</span><span class='line'>34
</span><span class='line'>45
</span><span class='line'>Sum 114
</span><span class='line'>终止批处理操作吗(Y/N)?</span></code></pre></td></tr></table></div></figure>


<h3>基本的语法Basic Syntax</h3>

<p>Scala的全部语法和语言的定义可以查看<a href="http://www.scala-lang.org/docu/files/ScalaReference.pdf">Scala Language Specification</a></p>

<h4>数字、字符串和XML常量</h4>

<ul>
<li><p>; 行结束符可以忽略</p></li>
<li><p>和Java一样的常量定义</p>

<blockquote><p>Integer: 1882, -1
Boolean: true, false
Double: 1.0, 1d, 1e3
Long: 42L
Float: 78.9f
Characters: &lsquo;4&rsquo;, &lsquo;?&rsquo;, &lsquo;z&rsquo;
Strings: &ldquo;Hello World&rdquo;</p></blockquote></li>
<li><p>Scala支持多行的字符串</p>

<blockquote><p>&ldquo;&rdquo;&ldquo;Hello
Multiline
World&rdquo;&ldquo;&rdquo;</p></blockquote></li>
<li><p>Scala支持XML常量，包括内嵌的Scala代码</p>

<blockquote><p><b>Foll</b>
<ul>{(1 to 3).map(i => <li>{i}</li>)}</ul></p></blockquote></li>
</ul>


<h4>包package和import</h4>

<p>package定义在源代码非注释的第一行。和java一样。</p>

<p>import则比java的更加灵活。基本的用法使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import scala.xml._</span></code></pre></td></tr></table></div></figure>


<p>scala中的import可以基于前面的imports语句。如再导入<code>scala.xml.transform</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import transform._</span></code></pre></td></tr></table></div></figure>


<p>也可以导入一个具体的class和object：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import scala.collection.mutable.HashMap</span></code></pre></td></tr></table></div></figure>


<p>一次性倒入一个package下的几个class或object：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import scala.collection.immutable.{TreeMap, TreeSet}</span></code></pre></td></tr></table></div></figure>


<p>甚至可以给原有的class或object定义一个别名。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import scala.util.parsing.json.{JSON =&gt; JsonParser}</span></code></pre></td></tr></table></div></figure>


<p>import可以定义在任何代码块中，并且只会在当前作用域内有效。还可以引入objects的method，相当于java的import static。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Frog {
</span><span class='line'>  import scala.xml._
</span><span class='line'>  def n: NodeSeq = NodeSeq.Empty
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>object Moose {
</span><span class='line'>  def bark = "woof"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>import Moose._
</span><span class='line'>bark</span></code></pre></td></tr></table></div></figure>


<h4>Class, Trait和Object</h4>

<p>Scala的对象语法和规则比Java的更加复杂。</p>

<p>Scala去掉了一个文件中只能定义一个public类的限制。你想在一个文件里面放n个类都可以，同时文件的名称也没有限制（Java文件名需要和public的类同名）。</p>

<p>Scala中默认访问级别是public的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// scala
</span><span class='line'>class Foo
</span><span class='line'>
</span><span class='line'>// java
</span><span class='line'>public class Foo {
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果构造函数、方法没有参数，可以省略参数列表（即不需要输入括号）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new Foo
</span><span class='line'>
</span><span class='line'>new Foo()
</span><span class='line'>
</span><span class='line'>class Bar(name: String)
</span><span class='line'>
</span><span class='line'>new Bar("Working...")
</span><span class='line'>
</span><span class='line'>class Baz(name: String) {
</span><span class='line'>  // constructor code is inline
</span><span class='line'>  if(name == null) throw new Exception("Name is null")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Scala的trait，和java中的interface类似。同时trait可以包括具体实现的方法，这是一个非常方便的特性，你不必在定义复杂的类继承关系来实现代码的重用，在Scala中，把代码写在trait中即可。Scala traits类似于Ruby mixins</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>trait Dog
</span><span class='line'>
</span><span class='line'>class Fizz2(name: String) extends Bar(name) with Dog
</span><span class='line'>
</span><span class='line'>trait Cat {
</span><span class='line'>  def meow(): String
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>trait FuzzyCat extends Cat {
</span><span class='line'>  override def meow(): String = "Meeeeeeeeeow"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>trait OtherThing {
</span><span class='line'>  def hello() = 4
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Yep extends FuzzyCat with OtherThing
</span><span class='line'>
</span><span class='line'>(new Yep).meow()
</span><span class='line'>(new Yep).hello()</span></code></pre></td></tr></table></div></figure>


<p>Scala中不支持static关键字，可以使用<code>object</code>单例对象来实现类似的功能。当object对象第一次访问才会被初始化，在对应的访问域内仅有一个该实例。Scala object还有一个优势，由于是类的实例，所以可以作为方法参数进行传递。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>object Simple
</span><span class='line'>
</span><span class='line'>object OneMethod {
</span><span class='line'>  def myMethod() = "Only One"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>object Dude extends Yep
</span><span class='line'>
</span><span class='line'>object Dude2 extends Yep {
</span><span class='line'>  override def meow() = "Dude looks like a cat"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>object OtherDude extends Yep {
</span><span class='line'>  def twoMeows(otherparam: Yep) = meow + ", " + otherparam.meow
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>OtherDude.meow // Meeeeeeeeeow
</span><span class='line'>OtherDude.twoMeows(Dude) // Meeeeeeeeeow, Meeeeeeeeeow
</span><span class='line'>OtherDude.twoMeows(Dude2) // Meeeeeeeeeow, Dude looks like a cat
</span></code></pre></td></tr></table></div></figure>


<p>如果object嵌套定义在class, trait, object内部的时刻，在其作用域下每个<strong>实例</strong>会创建一个object的单例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HasYep {
</span><span class='line'>  object myYep extends Yep {
</span><span class='line'>    override def meow = "Moof"
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>(new HasYep).myYep.meow // 每个HasYep实例会有一个单独的myYep</span></code></pre></td></tr></table></div></figure>


<p>同样Classes，Objects，traits也可以嵌套在classes，objects，traits。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HasClass {
</span><span class='line'>  private class MyDude extends FuzzyCat
</span><span class='line'>  def makeOne(): FuzzyCat = new MyDude
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>类继承Class Hierarchy</h4>

<p>除了方法（method），其他一切都是对象(an instance of a class)。Java的primitives类型在Scala也被当做对象，如int(Int)。当两个Ints相加时，Scala编译器会对字节码进行优化最终和java的两个ints相加时一样的。如果使用了Int的方法hashCode和toString，当primitive类型被用于需要引用类型时(expects an Any)，Scala编译器会对其进行装箱，如把Int值加入到HashMap。</p>

<p>为了保持命名的规范化，即所有类的第一个单词都是大写的。在Scala中的原始类型对应为Int,Long,Double,Float,Boolean,Char,Short,Byte，他们都是AnyVal的子类。java的void对应Unit， 同样是AnyVal的子类。你也可以使用<code>()</code>来显示的返回Unit类型实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val v = ()
</span><span class='line'>
</span><span class='line'>List(v) // List[Unit] = List(())</span></code></pre></td></tr></table></div></figure>


<p><code>Nothing</code>是很酷，任何方法返回Nothing，表示它不是正常返回，肯定是抛出了异常。<code>None</code>是一个<code>Option[Nothing]</code>的实例，它的get方法会返回<code>Nothing</code>，也就是说get方法会抛出异常，而不是返回底层的值类型null。</p>

<p>Any是Scala中所有类的基类，想Object在Java中的地位。但是，Nothing/primitives等等，所以需要在Object下面定义Scala的根基类。</p>

<p>AnyVal是Scala中primitives对象的包装类的基类。
AnyRef与Java中的Object类似。<code>eq</code>,<code>ne</code>,<code>==</code>,<code>!=</code>这些方法的含义不同。<code>==</code>编译后最终调用java的equals方法，如果需要进行对象引用的比较，使用<code>eq</code>进行处理。</p>

<h4>方法声明</h4>

<p>类型推测很强大也很有用，但是需要小心使用，当类型返回类型不明确时，需要显示进行声明。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def myMethod(): String = "Moof"
</span><span class='line'>
</span><span class='line'>def myOtherMethod() = "Moof" // not have to explicity declare the return type
</span><span class='line'>
</span><span class='line'>def foo(a: Int): String = a.toString
</span><span class='line'>
</span><span class='line'>def f2(a: Int, b: Boolean): String = if(b) b.toString else "false"
</span><span class='line'>
</span><span class='line'>def list[T](p: T): List[T] = p :: Nil
</span><span class='line'>
</span><span class='line'>list(1)
</span><span class='line'>list("Hello")
</span><span class='line'>
</span><span class='line'>// 可变参数， Seq[Int]
</span><span class='line'>def largest(as: Int*): Int = as.reduceLeft((a,b) =&gt; a max b)
</span><span class='line'>
</span><span class='line'>largest(1)
</span><span class='line'>largest(2, 3, 99)
</span><span class='line'>largest(33, 22, 33, 22)
</span><span class='line'>
</span><span class='line'>def mkString[T](as: T*): String = as.foldLeft("")(_ + _.toString)
</span><span class='line'>
</span><span class='line'>def sum[T &lt;: Number](as: T*): Double = as.foldLeft(0d)(_ + _.doubleValue)
</span></code></pre></td></tr></table></div></figure>


<p>方法可以定义在<strong>任何方法块</strong>中，除了最外层即classes，traits，objects定义的地方。方法中可以使用当前作用域类的所有的成员。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def readLines(br: BufferedReader) = {
</span><span class='line'>  var ret: List[String] = Nil
</span><span class='line'>
</span><span class='line'>  def readAll(): Unit = br.readLine match { 
</span><span class='line'>      case null =&gt;
</span><span class='line'>      case s =&gt; ret ::= s; readAll()
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  readAll()
</span><span class='line'>  ret.reverse
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>方法重写和java的不一样，被重写的方法必须带上override的修饰符。重写抽象的方法可以不带override的修饰符。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>abstract class Base {
</span><span class='line'>  def thing: String
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class One extends Base {
</span><span class='line'>  def thing = "Moof"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>不带参数的方法和变量可以使用<strong>相同的方式访问</strong>，重写父类方法时可以使用val代替def。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Two extends One {
</span><span class='line'>  override val thing = (new java.util.Date).toString
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Three extends One {
</span><span class='line'>  override lazy val thing = super.thing + (new java.util.Date).toString
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>变量声明</h4>

<p>和声明方法类似，不过关键字使用val, var, lazy val。var
可以在设置值以后再次进行修改，类似于java中的变量。val在运行到该作用域时就初始化。lazy val仅在访问的时刻进行计算一次。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var y: String = "Moof"
</span><span class='line'>val x: String = "Moof"
</span><span class='line'>lazy val lz: String = someLongQuery()</span></code></pre></td></tr></table></div></figure>


<p>在编程时，不推荐使用var变量除非一定要用变量。Given that mutability leads to unexpected defects, minimizing mutability in code minimizes mutability-related defects.</p>

<p>Scala类型推测对变量一样有效，在参数类型明确的情况下，定义参数时可以不用指定类型。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var y2 = "Moof"
</span><span class='line'>val x2 = "Moof"</span></code></pre></td></tr></table></div></figure>


<p>Scala支持同时接受多个参数值。 If a code block or method returns a Tuple, the Tuple can be assigned to a val variable.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val (i1: Int, s1: String) = Pair(33, "Moof")
</span><span class='line'>val (i2, s2) = Pair(43, "Moof")</span></code></pre></td></tr></table></div></figure>


<p>运行的效果如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; val (i2,s2)=Pair(43,"W")
</span><span class='line'>i2: Int = 43
</span><span class='line'>s2: String = W
</span><span class='line'>
</span><span class='line'>scala&gt; i2
</span><span class='line'>res0: Int = 43</span></code></pre></td></tr></table></div></figure>


<h4>代码块</h4>

<p>方法和参数定义都可以定义在单行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def meth9 = "hello world"</span></code></pre></td></tr></table></div></figure>


<p>或者定义在大括号包围的代码块中。代码块可以去嵌套。代码块的返回值是最后一个行的运行结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def meth3(): String = {"Moof"}
</span><span class='line'>def meth4(): String = {
</span><span class='line'>  val d = new java.util.Date()
</span><span class='line'>  d.toString()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>参数定义同样可以使用代码块，适合于有少量计算的赋值操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val x3: String = {
</span><span class='line'>  val d = new java.util.Date()
</span><span class='line'>  d.toString()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Call-by-Name</h4>

<p>在java中，所有方法是按call-by-reference或者call-by-value（原始类型）调用。也就是说，在调用栈中的参数的值或者引用（AnyRef）会传递给调用者。</p>

<p>Scala提供另一种传递参数给方法（函数）的方式：call-by-name，可以把方法块传给调用者。 Each time the callee accesses the parameter, the code block is executed and the value is calculated.</p>

<p>Call-by-name容许我们把耗时的操作（但可能不会用到的）当做参数。For example, in a call to the logger you can use call-by-name, and the express to print is only calculated if it’s going to be logged。Call-by-name同样容许我们创建（如while/doWhile）自定义的控制结构。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def nano() ={
</span><span class='line'>  println("Getting nano")
</span><span class='line'>  System.nanoTime
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>def delayed(t: =&gt; Long) = {
</span><span class='line'>  println("In delayed method")
</span><span class='line'>  println("Param: " + t)
</span><span class='line'>  t
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>scala&gt; delayed(nano())
</span><span class='line'>In delayed method
</span><span class='line'>Getting nano
</span><span class='line'>Param: 198642874346225
</span><span class='line'>Getting nano
</span><span class='line'>res1: Long = 198642875202814
</span><span class='line'>
</span><span class='line'>def notDelayed(t: Long) = {
</span><span class='line'>  println("In not delayed method")
</span><span class='line'>  println("Param: " + t)
</span><span class='line'>  t
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>scala&gt; notDelayed(nano)
</span><span class='line'>Getting nano
</span><span class='line'>In not delayed method
</span><span class='line'>Param: 199944029171474
</span><span class='line'>res5: Long = 199944029171474</span></code></pre></td></tr></table></div></figure>


<p>注意println输出的位置和次数。</p>

<h4>方法调用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>instance.method()
</span><span class='line'>instance.method
</span><span class='line'>
</span><span class='line'>instance.method(param)
</span><span class='line'>instance method param</span></code></pre></td></tr></table></div></figure>


<p>方法没有参数时可以省略括号。当只有可以参数时，可以省去点和括号。</p>

<p>实际运行效果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; "abc" toUpperCase
</span><span class='line'>warning: there were 1 feature warning(s); re-run with -feature for details
</span><span class='line'>res0: String = ABC
</span><span class='line'>
</span><span class='line'>scala&gt; "abc".toUpperCase
</span><span class='line'>res1: String = ABC
</span><span class='line'>
</span><span class='line'>scala&gt; "abc".charAt 1
</span><span class='line'>&lt;console&gt;:1: error: ';' expected but integer literal found.
</span><span class='line'>       "abc".charAt 1
</span><span class='line'>                    ^
</span><span class='line'>
</span><span class='line'>scala&gt; "abc" charAt 1
</span><span class='line'>res2: Char = b
</span><span class='line'>
</span><span class='line'>scala&gt; "abc" concat "efg"
</span><span class='line'>res3: String = abcefg
</span></code></pre></td></tr></table></div></figure>


<p>Scala允许方法名中包括+/-/*/?， Scala’s dotless method notation creates a syntactically neutral way of invoking methods that are hard-coded operators in Java.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; 2.1.*(4.3)
</span><span class='line'>res4: Double = 9.03
</span><span class='line'>
</span><span class='line'>scala&gt; 2.1 * 4.3
</span><span class='line'>res5: Double = 9.03</span></code></pre></td></tr></table></div></figure>


<p>多参数的方法调用和java一样。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>instance.method(p1, p2)</span></code></pre></td></tr></table></div></figure>


<p>Scala中的泛型方法，编译器可以进行类型推断。当然你也可以显示的指定类型。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>instance.method[TypeParam](p1, p2)</span></code></pre></td></tr></table></div></figure>


<h4>Functions, apply, update, and Compiler Magic</h4>

<p>Scala是一门函数语言，也意味着你可以传递函数，可以把函数作为返回值在函数和方法中返回。</p>

<p>函数是一个带有参数和返回值的代码块。
在JVM中是不容许传递代码块的。Scala中使用特定接口的匿名内部类作为函数内部实现。当传递一个函数时，其实就是传递一个特定接口(trait)的对象。</p>

<p>定义函数的trait使用一个参数和一个返回值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Function1[A, B]</span></code></pre></td></tr></table></div></figure>


<p>其中A是参数类型，B是返回值类型。</p>

<p>所有的函数接口都有一个apply的方法，用于函数的调用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Function1.apply(p: A): B</span></code></pre></td></tr></table></div></figure>


<p>Thus, you can define a method that takes a function and invokes the function with the parameter 42:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def answer(f: Function1[Int, String]) = f.apply(42)</span></code></pre></td></tr></table></div></figure>


<p>如果（只要）对象包括apply方法，可以省略apply，直接把参数跟在函数名后面。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def answer(f: Function1[Int, String]) = f(42)</span></code></pre></td></tr></table></div></figure>


<p>Scala提供的语法糖，在编译时f(42)会编译成f.apply(42)。这样使用可以让代码更简洁漂亮，同时看起来更像函数调用的写法。</p>

<p>更多的语法糖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Function1[Int, String]
</span><span class='line'>Int =&gt; String
</span><span class='line'>
</span><span class='line'>def answer(f: Int =&gt; String) = f(42)</span></code></pre></td></tr></table></div></figure>


<p>这种语法糖适用于所有包括apply方法对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; class Ap {
</span><span class='line'>     | def apply(in: Int) = in.toString
</span><span class='line'>     | }
</span><span class='line'>defined class Ap
</span><span class='line'>
</span><span class='line'>scala&gt; new Ap()(44)
</span><span class='line'>res0: String = 44
</span><span class='line'>
</span><span class='line'>scala&gt; new Ap(44)
</span><span class='line'>&lt;console&gt;:9: error: too many arguments for constructor Ap: ()Ap
</span><span class='line'>              new Ap(44)
</span><span class='line'>              ^
</span><span class='line'>
</span><span class='line'>scala&gt; val a = new Ap
</span><span class='line'>a: Ap = Ap@18258b2
</span><span class='line'>
</span><span class='line'>scala&gt; a(44)
</span><span class='line'>res2: String = 44</span></code></pre></td></tr></table></div></figure>


<p>如果类包括update方法，编译解析赋值操作时，会调用两个参数的update方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; class Up {
</span><span class='line'>     | def update(k: Int, v: String) = println("Hey: " + k + " " + v)
</span><span class='line'>     | }
</span><span class='line'>defined class Up
</span><span class='line'>
</span><span class='line'>scala&gt; val u = new Up
</span><span class='line'>u: Up = Up@7bfd80
</span><span class='line'>
</span><span class='line'>scala&gt; u(33) = "hello"
</span><span class='line'>Hey: 33 hello
</span><span class='line'>
</span><span class='line'>scala&gt; class Update {
</span><span class='line'>     | def update(what: String) = println("Singler: " + what)
</span><span class='line'>     | def update(a: Int, b: Int, what: String) = println("2d update")
</span><span class='line'>     | }
</span><span class='line'>defined class Update
</span><span class='line'>
</span><span class='line'>scala&gt; val u = new Update
</span><span class='line'>u: Update = Update@4bd4d2
</span><span class='line'>
</span><span class='line'>scala&gt; u() = "Foo"
</span><span class='line'>Singler: Foo
</span><span class='line'>
</span><span class='line'>scala&gt; u(3,4) = "Howdy"
</span><span class='line'>2d update
</span></code></pre></td></tr></table></div></figure>


<p>Scala中Array和HashMap使用update的方式进行设值。使用这种方式我们可以编写和Scala类似特性的库。</p>

<p>Scala的这些特性可以让我们编写更易理解的代码。同时理解Scala的这些语法糖，能更好的与java类库一起协作。</p>

<h4>Case Classes</h4>

<p>Scala has a mechanism for creating classes that have the common stuff filled in. Most of the time, when I define a class, I have to write the toString, hashCode, and equals methods.  These methods are boilerplate. Scala provides the case class mechanism for filling in these blanks as well as support for pattern matching.</p>

<p>A case class provides the same facilities as a normal class, but the compiler generates toString,  hashCode, and  equals methods (which you can override).</p>

<p>Case classes can be instantiated without the use of the  new statement. By default, all the parameters in the case class’s constructor become properties on the case class. Here’s how to create a case class:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala&gt; case class Stuff(name: String, age: Int)
</span><span class='line'>defined class Stuff
</span><span class='line'>
</span><span class='line'>scala&gt; val s = Stuff("David", 45)
</span><span class='line'>s: Stuff = Stuff(David,45)
</span><span class='line'>
</span><span class='line'>scala&gt; s.toString
</span><span class='line'>res0: String = Stuff(David,45)
</span><span class='line'>
</span><span class='line'>scala&gt; s == Stuff("David", 45) // == 相当于java中的equals
</span><span class='line'>res1: Boolean = true
</span><span class='line'>
</span><span class='line'>scala&gt; s == Stuff("David", 42)
</span><span class='line'>res2: Boolean = false
</span><span class='line'>
</span><span class='line'>scala&gt; s.name
</span><span class='line'>res4: String = David
</span><span class='line'>
</span><span class='line'>scala&gt; s.age
</span><span class='line'>res5: Int = 45</span></code></pre></td></tr></table></div></figure>


<p>手写case class功能的类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Stuff(val name: String, val age: Int) {
</span><span class='line'>  override def toString = "Stuff(" + name + "," + age + ")"
</span><span class='line'>  override def hashCode = name.hashCode + age
</span><span class='line'>  override def equals(other: AnyRef) = other match {
</span><span class='line'>      case s: Stuff =&gt; this.name == s.name && this.age = s.age
</span><span class='line'>      case _ =&gt; false
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>object Stuff {
</span><span class='line'>  def apply(name: String, age: Int) = new Stuff(name, age)
</span><span class='line'>  def unapply(s: Stuff) = Some((s.name, s.age))
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Basic Pattern Matching</h4>

<p>模式匹配（Pattern matching）可以使用很少的代码编写非常复杂的判断。Scala Pattern matching和Java switch语句类似， but you can test against almost anything, and you can even assign pieces of the matched value to variables. Like everything in Scala, pattern matching is an expression, so it result s in a value that may be assigned or returned. The most basic pattern matching is like Java’s switch, except there is no  break in each case as the cases do not fall through to each other.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>44 match {
</span><span class='line'>  case 44 =&gt; true
</span><span class='line'>  case _ =&gt; false
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以对String进行match操作，类似于C#。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"David" match {
</span><span class='line'>  case "David" =&gt; 45
</span><span class='line'>  case "Elwood" =&gt; 77
</span><span class='line'>  case _ =&gt; 0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以多case classes进行模式匹配（pattern match）操作。Case classes提供了非常适合与pattern-matching的语法。下面的例子，用于匹配Stuff的name==David以及age==45的对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stuff("David", 45) match {
</span><span class='line'>  case Stuff("David", 45) =&gt; true
</span><span class='line'>  case _ =&gt; false
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>仅匹配名字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stuff("David", 45) match {
</span><span class='line'>  case Stuff("David", _) =&gt; "David"
</span><span class='line'>  case _ =&gt; "Other"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>还可以把值提取出来，如把age的值赋给howOld变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stuff("David", 45) match {
</span><span class='line'>  case Stuff("David", howOld) =&gt; "David, age: " + howOld
</span><span class='line'>  case _ =&gt; "Other"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>还可以在pattern和=>之间添加条件。如年龄小于30的返回young David，其他的结果为old David。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stuff("David", 45) match {
</span><span class='line'>  case Stuff("David", age) if age &lt; 30 =&gt; "young David"
</span><span class='line'>  case Stuff("David", _) =&gt; "old David"
</span><span class='line'>  case _ =&gt; "Other"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Pattern matching还可以根据类型进行匹配：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x match {
</span><span class='line'>  case d: java.util.Date =&gt; "The date in milliseconds is " + d.getTime
</span><span class='line'>  case u: java.net.URL =&gt; "The URL path: " + u.getPath
</span><span class='line'>  case s: String =&gt; "String: " + s
</span><span class='line'>  case _ =&gt; "Something else"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果使用Java代码的话，需要多很多的转换！！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(x instanceof Date) return "The date in milliseconds is " + ((Date)x).getTime();
</span><span class='line'>if(x instanceof URL) return "The URL path: " + ((URL)x).getPath();
</span><span class='line'>if(x instanceof String) return "String: " + ((String)x);
</span><span class='line'>return "Something else"</span></code></pre></td></tr></table></div></figure>


<h4>if/else and while</h4>

<p>while在Scala中比较少用。if/else使用频率高一些，比java的三目赋值操作符（?:）使用频率更高。if和while表达式总是返回Unit（相当于Java的Void）。if/else的返回值更具各个部分表单时类型确定。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(exp) println("yes")
</span><span class='line'>
</span><span class='line'>// multiline
</span><span class='line'>if(exp) {
</span><span class='line'>  println("Line one")
</span><span class='line'>  println("Line two")
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>val i: Int = if(exp) 1 else 3
</span><span class='line'>
</span><span class='line'>val i: Int = if(exp) 1 
</span><span class='line'>else {
</span><span class='line'>  val j = System.currentTimeMillis
</span><span class='line'>  (j % 100L).toInt
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>while executes its code block as long  as its expression evaluates to  true, just like Java. In practice, using recursion, a method calling itself, provides more readab le code and enforces the concept of transforming input to output rather than changing, mutating, variables. Recursive methods can be as efficient as a while loop.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while (exp) println("Working...")
</span><span class='line'>while (exp) {
</span><span class='line'>  println("Working...")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>for</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for { i &lt;- 1 to 3} println(i)
</span><span class='line'>
</span><span class='line'>for { i &lt;- 1 to 3
</span><span class='line'>      j &lt;- 1 to 3
</span><span class='line'>  } println(i*j)
</span><span class='line'>
</span><span class='line'>def isOdd(in: Int) = in % 2 == 1
</span><span class='line'>for {i &lt;- 1 to 5 if ifOdd(i)} println(i)
</span><span class='line'>
</span><span class='line'>for {i &lt;- 1 to 5
</span><span class='line'>      j &lt;- 1 to 5 if isOdd(i*j)} println(i*j)
</span><span class='line'>
</span><span class='line'>val lst = (1 to 18 by 3).toList
</span><span class='line'>for {i &lt;- lst if isOdd(i)} yield i
</span><span class='line'>
</span><span class='line'>for {i &lt;- lst; j &lt;- lst if isOdd(i*j)} yield i*j</span></code></pre></td></tr></table></div></figure>


<p>将在第三章-集合中更详细的讲解for使用方法。</p>

<h4>throw, try/catch/finally, and synchronized</h4>

<p>try/finally的写法和java类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>throw new Exception("Working...")
</span><span class='line'>
</span><span class='line'>try{
</span><span class='line'>  throw new Exception("Working...")
</span><span class='line'>} finally {
</span><span class='line'>  println("This will always be printed")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>try/catch的语法不大一样，catch对异常进行了封装，首先它是一个表达式其返回值是一个值；使用case（pattern matched）来匹配异常类型。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try {
</span><span class='line'>  file.write(stuff)
</span><span class='line'>} catch {
</span><span class='line'>  case e: java.io.IOException =&gt; // handle IO Exception
</span><span class='line'>  case n: NullPointerException =&gt; // handle null Exception
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>try { Integer.parseInt("dog") } catch { case _ =&gt; 0 } //0
</span><span class='line'>try { Integer.parseInt("44") } catch { case _ =&gt; 0 } //44</span></code></pre></td></tr></table></div></figure>


<p>基于对象的同步操作，每个类都自带了synchronized方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj.synchronized {
</span><span class='line'>  // do something that needs to be serialized
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>不像java有synchronized方法修饰符。在Scala中同步方法定义使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def foo(): Int = synchronized {
</span><span class='line'>  42
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Comments</h4>

<p>注释基本上类C的语言都一样，单行<code>//</code>、多上<code>/* ... */</code>。</p>

<p>在Scala中还可以嵌套的注释。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'>  This is an outer comment
</span><span class='line'>  /* And this comment
</span><span class='line'>     is nested
</span><span class='line'>  */
</span><span class='line'>  Outer comment
</span><span class='line'>*/</span></code></pre></td></tr></table></div></figure>


<h4>Scala vs Java vs Ruby</h4>

<p><strong>类和实例</strong></p>

<p>java有原始类型。Scala中操作都是方法调用，所有东西都是对象，无需为了原始类型而进行额外的判断/处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.hashCode
</span><span class='line'>2.toString</span></code></pre></td></tr></table></div></figure>


<p>我们可以定义一个方法，传递函数（从一个Int到另一个Int转换操作）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def with42(in: Int =&gt; Int) = in(42)
</span><span class='line'>with42( 33 + )</span></code></pre></td></tr></table></div></figure>


<p>在语言级别，如果所有东西都是统一的，在进行编程设计时就会很方便和简单。同时Scala编译时会针对JVM原始类型进行优化，使得scala的代码在效率上非常接近Java。</p>

<p><strong>Traits, Interfaces, and Mixins</strong></p>

<p>在java中除了Object对象，其他对象都有一个唯一的父类。Java类可以实现一个或者多个接口（定义实现类必须实现方法的约定）。这是依赖注入和测试mocks，以及其他抽象模式的基础。</p>

<p>Scala使用traits， Traits提供了Java接口拥有的所有特性。同时Traits可以包括方法的实现以及参数的定义。方法实现一次，把所有继承traits的方法混入子类中。</p>

<p><strong>Object, Static, and Singletons</strong></p>

<p>在Java中，可以定义类的（静态）方法和属性，提供了访问方法的唯一入口，同时不需要实例化对象。类（静态）属性提供了在JVM中全局共享数据的方式。
Scala提供了类似的机制：Objects。Objects是单例模式的实现。在类加载的时刻实例化该对象。这种方式同样可以共享全局状态。而且，objects也是Scala完全的面向对象的一种体现，objects是一个类的实例，而不是某种类级别的常量（some class-level constant）。可以把objects作为参数来进行传递。</p>

<p><strong>Functions, Anonymous Inner Class, and  Lambdas/Procs</strong></p>

<p>The Java construct to pass units of computation as parameters to methods is anonymous inner class. 匿名内部类在Swing UI库非常的常见。在Swing中，许多UI事件处理的接口定义1-2个方法，在编写程序时，实现事件接口的内部类能访问外部类的私有成员数据。</p>

<p>Scala functions对应的就是匿名内部类。Scala functions实现了统一的接口，调用函数时执行接口的apply方法。和Java匿名内部类相比，Scala创建函数的语法更加简洁和优雅。同时，访问本地参数的规则也更加灵活。在Java匿名内部类只能访问final的参数，而Scala functions能访问和修改vars参数。</p>

<p>Scala和Ruby的面向对象模型和函数式编程很相似。同时Scala在访问类库和静态类型方面和Java很类似。Scala博采众长，把Java和Ruby的优点都囊括了。</p>

<h3>总结</h3>

<p>这一章首相讲了安装和运行Scala程序，然后围绕Scala编程的语法结构来展开。下一章讲解Scala的数据类型，使用很少的代码编写功能健壮的程序，同时编码量的减少也能有效的控制bugs的数量。</p>

<p>&ndash;END</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/07/expect-automate-and-batch-config-ssh/">Expect-批量实现SSH无密钥登录</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-07T16:11:18+08:00" pubdate data-updated="true">Sun 2014-09-07 16:11</time>
		
        
		
      </p>
    
  </header>


  <div class="entry-content"><p>在安装部署Hadoop集群的首要步骤就是配置SSH的无密钥登陆。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa
</span><span class='line'>cp ~/.ssh/id_rsa.pub ~/.ssh/authorized_keys
</span><span class='line'>
</span><span class='line'>ssh-copy-id -i ~/.ssh/id_rsa.pub root@$ip</span></code></pre></td></tr></table></div></figure>


<p>然后，可以通过ssh命令来进行批量的操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh root@$ip 'cp ~/.ssh/id_rsa.pub ~/.ssh/authorized_keys'
</span><span class='line'>scp -o StrictHostKeyChecking=no /etc/hosts root@${ip}:/etc/</span></code></pre></td></tr></table></div></figure>


<p>但是，一些需要密码的dialogue形式的输入时，部署N台datanode就需要输入N遍！同时新建用户也是需要输入用户密码的操作！！</p>

<p>Linux Expect就是用来自动化处理这些需求的。Except能根据提示来实现相应的输入。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[hadoop@master1 hadoop-deploy-0.0.1]$ ssh-copy-id localhost
</span><span class='line'>The authenticity of host 'localhost (::1)' can't be established.
</span><span class='line'>RSA key fingerprint is 4e:fe:7a:0a:98:6e:9a:ab:af:e4:65:51:9b:3d:e0:99.
</span><span class='line'>Are you sure you want to continue connecting (yes/no)? yes
</span><span class='line'>Warning: Permanently added 'localhost' (RSA) to the list of known hosts.
</span><span class='line'>hadoop@localhost's password: 
</span><span class='line'>Now try logging into the machine, with "ssh 'localhost'", and check in:
</span><span class='line'>
</span><span class='line'>  .ssh/authorized_keys
</span><span class='line'>
</span><span class='line'>to make sure we haven't added extra keys that you weren't expecting.</span></code></pre></td></tr></table></div></figure>


<p>根据需要<strong>提示信息</strong>，以及需要<strong>输入的信息</strong>，可以编写对应expect脚本来进行自动化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[hadoop@master1 hadoop-deploy-0.0.1]$ cat bin/ssh-copy-id.expect 
</span><span class='line'>#!/usr/bin/expect  
</span><span class='line'>
</span><span class='line'>## Usage $0 [user@]host password
</span><span class='line'>
</span><span class='line'>set host [lrange $argv 0 0];
</span><span class='line'>set password [lrange $argv 1 1] ;
</span><span class='line'>
</span><span class='line'>set timeout 30;
</span><span class='line'>
</span><span class='line'>spawn ssh-copy-id $host ;
</span><span class='line'>
</span><span class='line'>expect {
</span><span class='line'>  "(yes/no)?" { send yes\n; exp_continue; }
</span><span class='line'>  "password:" { send $password\n; exp_continue; }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>exec sleep 1;</span></code></pre></td></tr></table></div></figure>


<p>同样新建用户初始化密码的操作一样可以使用expect来使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[hadoop@master1 hadoop-deploy-0.0.1]$ cat bin/passwd.expect
</span><span class='line'>#!/usr/bin/expect  
</span><span class='line'>
</span><span class='line'>## Usage $0 host username password
</span><span class='line'>
</span><span class='line'>set host [lrange $argv 0 0];
</span><span class='line'>set username [lrange $argv 1 1];
</span><span class='line'>set password [lrange $argv 2 2] ;
</span><span class='line'>
</span><span class='line'>set timeout 30;
</span><span class='line'>
</span><span class='line'>##
</span><span class='line'>
</span><span class='line'>spawn ssh $host useradd $username ;
</span><span class='line'>
</span><span class='line'>exec sleep 1;
</span><span class='line'>
</span><span class='line'>##
</span><span class='line'>
</span><span class='line'>spawn ssh $host passwd $username ;
</span><span class='line'>
</span><span class='line'>## password and repasswd all use this
</span><span class='line'>expect {
</span><span class='line'>  "password:" { send $password\n; exp_continue; }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>exec sleep 1;</span></code></pre></td></tr></table></div></figure>


<p>有了上面的脚本，预定义每台机器的root密码，使用ssh-copy-id.expect建立到各台datanode机器的无密钥登录；然后passwd.expect脚本分发给各台机器，然后使用ssh进行运行脚本建立用户初始化密码。</p>

<p>Expect仅在master机器上安装就可以。安装程序的如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yum install expect</span></code></pre></td></tr></table></div></figure>


<p>or</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpm -ivh tcl-8.5.7-6.el6.x86_64.rpm
</span><span class='line'>rpm -ivh expect-5.44.1.15-5.el6_4.x86_64.rpm</span></code></pre></td></tr></table></div></figure>


<p>&ndash;END</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/05/read-hadoop-balancer-source-part3/">[读码] Hadoop2 Balancer磁盘空间平衡（下）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-05T16:31:15+08:00" pubdate data-updated="true">Fri 2014-09-05 16:31</time>
		
        
		
      </p>
    
  </header>


  <div class="entry-content"><p>前面讲到了节点的初始化，根据节点使用率与集群dfs使用率比较分为
<code>overUtilizedDatanodes</code>，<code>aboveAvgUtilizedDatanodes</code>，<code>belowAvgUtilizedDatanodes</code>，<code>underUtilizedDatanodes</code>，同时进行了节点数据量从Source到Target的配对。</p>

<p>接下来就是最后的数据移动部分了。</p>

<p>5.3 移动数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private ReturnStatus run(int iteration, Formatter formatter,
</span><span class='line'>      Configuration conf) {
</span><span class='line'>      ...
</span><span class='line'>      if (!this.nnc.shouldContinue(dispatchBlockMoves())) {
</span><span class='line'>        return ReturnStatus.NO_MOVE_PROGRESS;
</span><span class='line'>      }
</span><span class='line'>      ...
</span><span class='line'>  }    </span></code></pre></td></tr></table></div></figure>


<p>针对一个namenode如果连续5次没有移动数据，就会退出平衡操作，是在<code>NameNodeConnector#shouldContinue(long)</code>中处理的。</p>

<p>由于这里需要进行大量计算，以及耗时的文件传输等操作，这里使用了executorservice，分别为moverExecutor和dispatcherExecutor，有两个配置<code>dfs.balancer.moverThreads</code>（1000）和<code>dfs.balancer.dispatcherThreads</code>（200）来设置线程池的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Balancer(NameNodeConnector theblockpool, Parameters p, Configuration conf) {
</span><span class='line'>      ...
</span><span class='line'>    this.moverExecutor = Executors.newFixedThreadPool(
</span><span class='line'>            conf.getInt(DFSConfigKeys.DFS_BALANCER_MOVERTHREADS_KEY,
</span><span class='line'>                        DFSConfigKeys.DFS_BALANCER_MOVERTHREADS_DEFAULT));
</span><span class='line'>    this.dispatcherExecutor = Executors.newFixedThreadPool(
</span><span class='line'>            conf.getInt(DFSConfigKeys.DFS_BALANCER_DISPATCHERTHREADS_KEY,
</span><span class='line'>                        DFSConfigKeys.DFS_BALANCER_DISPATCHERTHREADS_DEFAULT));
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>其中<code>dispatchBlockMoves()</code>包装了数据移动的操作，把source的块移动到target节点中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private long dispatchBlockMoves() throws InterruptedException {
</span><span class='line'>    long bytesLastMoved = bytesMoved.get();
</span><span class='line'>    Future&lt;?&gt;[] futures = new Future&lt;?&gt;[sources.size()];
</span><span class='line'>    int i=0;
</span><span class='line'>    for (Source source : sources) {
</span><span class='line'>       // / 新线程来执行块的分发
</span><span class='line'>      futures[i++] = dispatcherExecutor.submit(source.new BlockMoveDispatcher());
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // wait for all dispatcher threads to finish
</span><span class='line'>    // / 等待分发操作完成
</span><span class='line'>    for (Future&lt;?&gt; future : futures) { 
</span><span class='line'>        future.get(); 
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // wait for all block moving to be done
</span><span class='line'>    // / 等待块的数据移动完成，相当于等待moverExecutor的Future完成
</span><span class='line'>    waitForMoveCompletion(); 
</span><span class='line'>    
</span><span class='line'>    return bytesMoved.get()-bytesLastMoved;
</span><span class='line'>  }
</span><span class='line'>  private void waitForMoveCompletion() {
</span><span class='line'>    boolean shouldWait;
</span><span class='line'>    do {
</span><span class='line'>      shouldWait = false;
</span><span class='line'>      for (BalancerDatanode target : targets) {
</span><span class='line'>          // / 块从source移动到target完成后,会从Pending的列表中移除 @see PendingBlockMove#dispatch()
</span><span class='line'>        if (!target.isPendingQEmpty()) { 
</span><span class='line'>          shouldWait = true;
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>      if (shouldWait) {
</span><span class='line'>        try {
</span><span class='line'>          Thread.sleep(blockMoveWaitTime);
</span><span class='line'>        } catch (InterruptedException ignored) {
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    } while (shouldWait);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>上面是分发功能主程序执行的代码，调用分发线程和等待执行结果的代码。主要业务逻辑在线程中调用执行。</p>

<p>分发线程dispatcher先获取Source上指定大小的block块，对应到<code>getBlockList()</code>方法。除了用于<strong>块同步</strong>的globalBlockList变量、以及记录当前Source获取的srcBlockList、最重要的当属用于判断获取的块是否符合条件的方法<code>isGoodBlockCandidate(block)</code>。在移动块的选择也会用到该方法，单独拿出来在后面讲。</p>

<p>然后选择Source下哪些块将移动到Targets目标节点。在<code>chooseNodes</code>步骤中把移动和接收<strong>数据</strong>的流向确定了，相关信息存储在Source的nodeTasks列表对象中。这里<code>PendingBlockMove.chooseBlockAndProxy()</code>把Sources需要移动的<strong>块</strong>确定下来，把从Source获取到的srcBlockList分配给Target。然后交给moverExecutor去执行。</p>

<p>其中通过<code>isGoodBlockCandidate</code>和<code>chooseProxySource</code>（选择从那个目标获取block的真实数据，不一定是Source节点哦！）方法筛选合适的符合条件的块，并加入到movedBlocks对象。</p>

<p><img src="http://file.bmob.cn/M00/0C/FA/wKhkA1QLCqqASDGHAAMJbC1ZgZQ339.png" alt="" /></p>

<p>调用的dispatchBlocks方法第一次循环是不会有数据移动的，此时Source对象中srcBlockList可移动块为空，从Source中获取块后再进行块的移动操作<code>chooseNextBlockToMove()</code>。</p>

<p>先讲下Source类属性blocksToReceive，初始值为2*scheduledSize，有三个地方：dispatchBlocks初始化大小，getBlockList从Source节点获取block的量同时减去获取到的block的字节数，还有就是shouldFetchMoreBlocks用于判断是否还有数据需要获取或者移动dispatchBlocks。这个属性其实也就是<strong>设置一个阀</strong>，不管block是否为最终移动的block，获取到块的信息后就会从blocksToReceive减去相应的字节数。</p>

<p><img src="http://file.bmob.cn/M00/0C/D7/wKhkA1QJjnGAT2T-AACHmpdgZc0077.png" alt="" /></p>

<p>前面获取Source block和分配到Target block都使用了isGoodBlockCandidate方法，这里涉及到怎么去评估<strong>块</strong>获取和分配是否合理的问题。需同时满足下面三个条件：</p>

<ul>
<li>当前选中的移动的块，不在已移动块的名单中<code>movedBlocks.contains</code></li>
<li>移动的块在目的机器上没有备份</li>
<li>移动的块不减少含有该数据的机架数量

<ul>
<li>多机架的情况下<code>cluster.isNodeGroupAware()</code>，移动的块在目的机器的机架上没有备份</li>
<li>YES source和target在同一个机架上。</li>
<li>YES source和target不在同一机架上，且该块没有一个备份在target的机架上</li>
<li>YES source和target不在同一机架上，且该块有另一个备份和source在同一机架上</li>
</ul>
</li>
</ul>


<h2>疑问</h2>

<p>一个Datanode只能同时移动/接收5个Block（即MAX_NUM_CONCURRENT_MOVES值），结合<code>chooseProxySource</code>的代码的addTo调用，看的很是辛苦！如block-A所有块都在A机架上，在选择proxySource时，会把该块的<strong>两个</strong>datanode都加上一个pendingBlock，显然这不大合理！！</p>

<p>如果备用的proxySource节点恰好还是target的话，waitForMoveCompletion方法永远不能结束！！应该把没有找到同机架的源情况移到for循环外面进行处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private boolean chooseProxySource() {
</span><span class='line'>  final DatanodeInfo targetDN = target.getDatanode();
</span><span class='line'>  boolean find = false;
</span><span class='line'>  for (BalancerDatanode loc : block.getLocations()) {
</span><span class='line'>    // check if there is replica which is on the same rack with the target
</span><span class='line'>    if (cluster.isOnSameRack(loc.getDatanode(), targetDN) && addTo(loc)) {
</span><span class='line'>      find = true;
</span><span class='line'>      // if cluster is not nodegroup aware or the proxy is on the same 
</span><span class='line'>      // nodegroup with target, then we already find the nearest proxy
</span><span class='line'>      if (!cluster.isNodeGroupAware() 
</span><span class='line'>          || cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN)) {
</span><span class='line'>        return true;
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    if (!find) {
</span><span class='line'>    // 这里的non-busy指的是，pendingBlock小于5份节点
</span><span class='line'>      // find out a non-busy replica out of rack of target
</span><span class='line'>      find = addTo(loc);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  return find;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://file.bmob.cn/M00/0D/06/wKhkA1QLuziAKEZdAAA8zGjPMGQ901.png" alt="" /></p>

<p>不过无需庸人自扰，一般都在一个rack上，这种问题就不存在了！同时这个也不是能一步到位，加了很多限制（一次迭代一个datanode最多处理10G，获取一次srcBlockList仅2G还限制就一次迭代就5个block），会执行很多次。</p>

<h2>总结</h2>

<p>总体的代码大致就是这样子了。根据集群使用率和阀值，计算需要进行数据接收和移动的节点（初始化），然后进行配对（选择），再进行块的选取和接收节点进行配对（分发），最后就是数据的移动（理解为socket数据传递就好了，调用了HDFS的协议代码。表示看不明），并等待该轮操作结束。</p>

<h2>举例</h2>

<p>除了指定threshold为5，其他是默认参数。由于仅单namenode和单rack，所以直接分析第五部分的namenode平衡处理。</p>

<p>根据所给的数据，（initNodes）第一步计算使用率，得出需要移动的数据量，把datanodes对号入座到over/above/below/under四个分类中。</p>

<p><img src="http://file.bmob.cn/M00/0D/08/wKhkA1QLwxiAOEV3AAAu5v9zggc374.png" alt="" /></p>

<p>（chooseNodes）第二步进行Source到Target节点的计划移动数据量计算。</p>

<p>在初始化BalancerDatanode的时刻，就计算出了节点的maxSize2Move。从给出的数据，只有一个节点超过阀值，另外两个是都在阀值内，一个高于平均值一个低于平均值。</p>

<p>这里就是把A1超出部分的数据（小于10G）移到A2，计算Source和Target的scheduledSize的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chooseDatanodes(overUtilizedDatanodes, belowAvgUtilizedDatanodes, matcher);
</span><span class='line'>chooseForOneDatanode(datanode, candidates, matcher)
</span><span class='line'>chooseCandidate(dn, i, matcher)
</span><span class='line'>// 把所有A1超出部分全部移到A2，并NodeTask(A2, 8428571.429)存储到Source：A1的nodeTaskList对象中
</span><span class='line'>matchSourceWithTargetToMove((Source)dn, chosen);</span></code></pre></td></tr></table></div></figure>


<p>（dispatchBlockMoves）第三步就是分发进行块的转移。</p>

<p>先设置blocksToReceive（2*scheduledSize=16857142.86）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chooseNextBlockToMove
</span><span class='line'>chooseBlockAndProxy
</span><span class='line'>markMovedIfGoodBlock
</span><span class='line'>isGoodBlockCandidate
</span><span class='line'>chooseProxySource
</span><span class='line'>
</span><span class='line'>scheduleBlockMove
</span><span class='line'>
</span><span class='line'>getBlockList</span></code></pre></td></tr></table></div></figure>


<p>从Source获取块时，可能在A2上已经有了，会通过isGoodBlockCandidate来进行过滤。然后就是把它交给moverExecutor执行数据块的移动，完成后修改处理的数据量byteMoved，把移动的块从target和proxySource的pendingBlockList中删除。</p>

<p>重复进行以上步骤，直到全部所有节点的使用率都在阀值内，顺利结束本次平衡处理。</p>

<p>&ndash;END</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/05/read-hadoop-balancer-source-part2/">[读码] Hadoop2 Balancer磁盘空间平衡（中）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-05T14:57:25+08:00" pubdate data-updated="true">Fri 2014-09-05 14:57</time>
		
        
		
      </p>
    
  </header>


  <div class="entry-content"><h2>code</h2>

<p>执行<code>hadoop-2.2.0/bin/hadoop balancer -h</code>查看可以设置的参数（和sbin/start-balancer.sh一样）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Usage: java Balancer
</span><span class='line'>  [-policy &lt;policy&gt;]    the balancing policy: datanode or blockpool
</span><span class='line'>  [-threshold &lt;threshold&gt;]  Percentage of disk capacity</span></code></pre></td></tr></table></div></figure>


<p>main方法入口，可以接受threshold（大于等于1小于等于100， 默认值10）和policy（可取datanode[dfsused]/blockpool[
blockpoolused]， 默认值datanode），具体的含义可以查看（上）篇中的javadoc的描述。</p>

<h3>获取初始化参数</h3>

<p>然后通过ToolRunner解析参数，并运行Cli工具类来执行HDFS的平衡。</p>

<p>1 设置检查</p>

<p><code>WIN_WIDTH</code>(默认1.5h) 已移动的数据会记录movedBlocks（list）变量中，在移动成功的数据<code>CUR_WIN</code>的值经过该时间后会被移动到<code>OLD_WIN</code>&mdash;现在感觉作用不大，为了减少map的大小？</p>

<p><code>checkReplicationPolicyCompatibility()</code>检查配置<code>dfs.block.replicator.classname</code>是否为BlockPlacementPolicyDefault子类，即是否满足3份备份的策略（1st本地，2nd另一个rack，3rd和第二份拷贝不同rack的节点）？</p>

<p>2 获取nameserviceuris</p>

<p>通过<code>DFSUtil#getNsServiceRpcUris()</code>来获取namenodes，调用<code>getNameServiceUris()</code>来得到一个URI的结果集：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ nsId &lt;- dfs.nameservices
</span><span class='line'>  ? ha  &lt;- dfs.namenode.rpc-address + [dfs.nameservices] + [dfs.ha.namenodes]
</span><span class='line'>    Y+ =&gt; hdfs://nsId
</span><span class='line'>    N+ =&gt; hdfs://[dfs.namenode.servicerpc-address.[nsId]] 或 hdfs://[dfs.namenode.rpc-address.[nsId]] 第二个满足条件的加入到nonPreferredUris
</span><span class='line'>+ hdfs://[dfs.namenode.servicerpc-address] 或 hdfs://[dfs.namenode.rpc-address]  第二个满足条件的加入到nonPreferredUris
</span><span class='line'>? [fs.defaultFs] 以hfds开头，且不在nonPreferredUris集合中是加入结果集</span></code></pre></td></tr></table></div></figure>


<p>HA情况下的地址相关配置项可以查看<a href="http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/HDFSHighAvailabilityWithQJM.html">官网的文档</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dfs.nameservices
</span><span class='line'>dfs.ha.namenodes.[nameservice ID]
</span><span class='line'>dfs.namenode.rpc-address.[nameservice ID].[name node ID] </span></code></pre></td></tr></table></div></figure>


<p>3 解析threshold和policy参数</p>

<p>默认值: <strong>BalancingPolicy.Node.INSTANCE, 10.0</strong>。运行打印的日志如下，INFO日志中包括了初始化的参数信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2014-09-05 10:55:12,183 INFO Balancer: Using a threshold of 1.0
</span><span class='line'>2014-09-05 10:55:12,186 INFO Balancer: namenodes = [hdfs://umcc97-44:9000]
</span><span class='line'>2014-09-05 10:55:12,186 INFO Balancer: p         = Balancer.Parameters[BalancingPolicy.Node, threshold=1.0]
</span><span class='line'>2014-09-05 10:55:13,744 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
</span><span class='line'>2014-09-05 10:55:18,154 INFO net.NetworkTopology: Adding a new node: /default-rack/10.18.97.142:50010
</span><span class='line'>2014-09-05 10:55:18,249 INFO net.NetworkTopology: Adding a new node: /default-rack/10.18.97.144:50010
</span><span class='line'>2014-09-05 10:55:18,311 INFO net.NetworkTopology: Adding a new node: /default-rack/10.18.97.143:50010
</span><span class='line'>2014-09-05 10:55:18,319 INFO Balancer: 2 over-utilized: [Source[10.18.97.144:50010, utilization=8.288283273062705], Source[10.18.97.143:50010, utilization=8.302032354001554]]
</span><span class='line'>2014-09-05 10:55:18,320 INFO Balancer: 1 underutilized: [BalancerDatanode[10.18.97.142:50010, utilization=4.716543864576553]]
</span><span class='line'>2014-09-05 10:55:33,918 INFO Balancer: Need to move 3.86 GB to make the cluster balanced.
</span><span class='line'>2014-09-05 11:21:16,875 INFO Balancer: Decided to move 2.43 GB bytes from 10.18.97.144:50010 to 10.18.97.142:50010
</span><span class='line'>2014-09-05 11:24:16,712 INFO Balancer: Decided to move 1.84 GB bytes from 10.18.97.143:50010 to 10.18.97.142:50010
</span><span class='line'>2014-09-05 11:25:55,726 INFO Balancer: Will move 4.27 GB in this iteration</span></code></pre></td></tr></table></div></figure>


<h3>执行Balancer</h3>

<p>4 调用Balancer#run执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> # 调试命令
</span><span class='line'> export HADOOP_OPTS=" -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8087 "
</span><span class='line'> sbin/start-balancer.sh </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Balancer的静态方法run，循环处理所有namenodes。在实例化namenode的NameNodeConnector对象时，会把当前运行balancer程序的hostname写入到HDFS的<code>/system/balancer.id</code>文件中，可以用来控制同时只有一个balancer运行。</p>

<p><img src="http://file.bmob.cn/M00/0C/96/wKhkA1QJJNqAXxeaAAAho0g2bEU520.png" alt="" /></p>

<p>在循环处理的时刻使用<code>Collections.shuffle(connectors)</code>打乱了namenodes的顺序。</p>

<p>Balancer的静态方法run中是一个双层循环，实例化Balancer并调用实例方法run来处理每个namenode的平衡。运行后要么<strong>出错</strong>要么就是平衡<strong>顺利完成</strong>才算结束。平衡的返回状态值及其含义可以查看javadoc（上）篇。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  static int run(Collection&lt;URI&gt; namenodes, final Parameters p,
</span><span class='line'>      Configuration conf) throws IOException, InterruptedException {
</span><span class='line'>    ...
</span><span class='line'>      for (URI uri : namenodes) {
</span><span class='line'>        connectors.add(new NameNodeConnector(uri, conf));
</span><span class='line'>      }
</span><span class='line'>    
</span><span class='line'>      boolean done = false;
</span><span class='line'>      for(int iteration = 0; !done; iteration++) {
</span><span class='line'>        done = true;
</span><span class='line'>        Collections.shuffle(connectors);
</span><span class='line'>        for(NameNodeConnector nnc : connectors) {
</span><span class='line'>          final Balancer b = new Balancer(nnc, p, conf);
</span><span class='line'>          final ReturnStatus r = b.run(iteration, formatter, conf);
</span><span class='line'>          // clean all lists
</span><span class='line'>          b.resetData(conf);
</span><span class='line'>          if (r == ReturnStatus.IN_PROGRESS) {
</span><span class='line'>            done = false;
</span><span class='line'>          } else if (r != ReturnStatus.SUCCESS) {
</span><span class='line'>            //must be an error statue, return.
</span><span class='line'>            return r.code;
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (!done) {
</span><span class='line'>          Thread.sleep(sleeptime);
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    ...
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>5 <strong>针对每个namenode的平衡处理</strong></p>

<p>针对每个namenode的每次迭代，又可以分出初始化节点、选择移动节点、移动数据三个部分。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private ReturnStatus run(int iteration, Formatter formatter, Configuration conf) {
</span><span class='line'>      ...
</span><span class='line'>      final long bytesLeftToMove = initNodes(nnc.client.getDatanodeReport(DatanodeReportType.LIVE));
</span><span class='line'>      if (bytesLeftToMove == 0) {
</span><span class='line'>        System.out.println("The cluster is balanced. Exiting...");
</span><span class='line'>        return ReturnStatus.SUCCESS;
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      final long bytesToMove = chooseNodes();
</span><span class='line'>      if (bytesToMove == 0) {
</span><span class='line'>        System.out.println("No block can be moved. Exiting...");
</span><span class='line'>        return ReturnStatus.NO_MOVE_BLOCK;
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      if (!this.nnc.shouldContinue(dispatchBlockMoves())) {
</span><span class='line'>        return ReturnStatus.NO_MOVE_PROGRESS;
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      return ReturnStatus.IN_PROGRESS;
</span><span class='line'>      ...
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>获取集群Live Datanode节点的信息，和通过50070查看的信息差不多，然后调用initNode()方法。</p>

<p><img src="http://file.bmob.cn/M00/0C/8F/wKhkA1QJFgaAAsSNAAD4HDo1RfA678.png" alt="" /></p>

<p>5.1 初始化节点</p>

<p><code>initNodes()</code>中获取每个Datanode的capacity和dfsUsed数据，计算整个集群dfs的平均使用率avgUtilization。
然后根据每个节点的使用率与集群使用率，以及阀值进行比较划分为4种情况：
<code>overUtilizedDatanodes</code>，<code>aboveAvgUtilizedDatanodes</code>，<code>belowAvgUtilizedDatanodes</code>，<code>underUtilizedDatanodes</code>。</p>

<p><img src="http://file.bmob.cn/M00/0C/95/wKhkA1QJH2uAa8UEAABq7RCSLQ0452.png" alt="" /></p>

<p>同时取超出<strong>平均+阀值</strong>和<strong>低于平均-阀值</strong>的字节数最大值，即集群达到平衡需要移动的字节数。</p>

<p>为了测试，如果集群已经平衡，可以搞点数据让集群不平衡，方便查看调试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/hadoop fs -D dfs.replication=1 -put XXXXX /abc
</span><span class='line'>
</span><span class='line'>sbin/start-balancer.sh -threshold 1</span></code></pre></td></tr></table></div></figure>


<p>5.2 选择节点</p>

<p>初始化节点后，计算出了需要移动的数据量。接下来就是选择移动数据的节点<code>chooseNodes</code>，以及接收对应数据的节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private long chooseNodes() {
</span><span class='line'>    // First, match nodes on the same node group if cluster is node group aware
</span><span class='line'>    if (cluster.isNodeGroupAware()) {
</span><span class='line'>      chooseNodes(SAME_NODE_GROUP);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    chooseNodes(SAME_RACK);
</span><span class='line'>    chooseNodes(ANY_OTHER);
</span><span class='line'>
</span><span class='line'>    long bytesToMove = 0L;
</span><span class='line'>    for (Source src : sources) {
</span><span class='line'>      bytesToMove += src.scheduledSize;
</span><span class='line'>    }
</span><span class='line'>    return bytesToMove;
</span><span class='line'>  }
</span><span class='line'>  private void chooseNodes(final Matcher matcher) {
</span><span class='line'>    chooseDatanodes(overUtilizedDatanodes, underUtilizedDatanodes, matcher);
</span><span class='line'>    chooseDatanodes(overUtilizedDatanodes, belowAvgUtilizedDatanodes, matcher);
</span><span class='line'>    chooseDatanodes(underUtilizedDatanodes, aboveAvgUtilizedDatanodes, matcher);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  private &lt;D extends BalancerDatanode, C extends BalancerDatanode&gt; void 
</span><span class='line'>      chooseDatanodes(Collection&lt;D&gt; datanodes, Collection&lt;C&gt; candidates,
</span><span class='line'>          Matcher matcher) {
</span><span class='line'>    for (Iterator&lt;D&gt; i = datanodes.iterator(); i.hasNext();) {
</span><span class='line'>      final D datanode = i.next();
</span><span class='line'>      for(; chooseForOneDatanode(datanode, candidates, matcher); );
</span><span class='line'>      if (!datanode.hasSpaceForScheduling()) {
</span><span class='line'>        i.remove(); // “超出”部分全部有去处了
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  private &lt;C extends BalancerDatanode&gt; boolean chooseForOneDatanode(
</span><span class='line'>      BalancerDatanode dn, Collection&lt;C&gt; candidates, Matcher matcher) {
</span><span class='line'>    final Iterator&lt;C&gt; i = candidates.iterator();
</span><span class='line'>    final C chosen = chooseCandidate(dn, i, matcher);
</span><span class='line'>
</span><span class='line'>    if (chosen == null) {
</span><span class='line'>      return false;
</span><span class='line'>    }
</span><span class='line'>    if (dn instanceof Source) {
</span><span class='line'>      matchSourceWithTargetToMove((Source)dn, chosen);
</span><span class='line'>    } else {
</span><span class='line'>      matchSourceWithTargetToMove((Source)chosen, dn);
</span><span class='line'>    }
</span><span class='line'>    if (!chosen.hasSpaceForScheduling()) {
</span><span class='line'>      i.remove(); // 可用的空间已经全部分配出去了
</span><span class='line'>    }
</span><span class='line'>    return true;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  private &lt;D extends BalancerDatanode, C extends BalancerDatanode&gt;
</span><span class='line'>      C chooseCandidate(D dn, Iterator&lt;C&gt; candidates, Matcher matcher) {
</span><span class='line'>    if (dn.hasSpaceForScheduling()) {
</span><span class='line'>      for(; candidates.hasNext(); ) {
</span><span class='line'>        final C c = candidates.next();
</span><span class='line'>        if (!c.hasSpaceForScheduling()) {
</span><span class='line'>          candidates.remove();
</span><span class='line'>        } else if (matcher.match(cluster, dn.getDatanode(), c.getDatanode())) {
</span><span class='line'>          return c;
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    return null;
</span><span class='line'>  }  </span></code></pre></td></tr></table></div></figure>


<p>选择到<strong>接收节点</strong>后，接下来计算可以移动的数据量（取双方的available的最大值），然后把<strong>接收节点</strong>和<strong>数据量</strong>的信息NodeTask存储到Source的NodeTasks对象中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private void matchSourceWithTargetToMove(
</span><span class='line'>      Source source, BalancerDatanode target) {
</span><span class='line'>    long size = Math.min(source.availableSizeToMove(), target.availableSizeToMove());
</span><span class='line'>    NodeTask nodeTask = new NodeTask(target, size);
</span><span class='line'>    source.addNodeTask(nodeTask);
</span><span class='line'>    target.incScheduledSize(nodeTask.getSize());
</span><span class='line'>    sources.add(source);
</span><span class='line'>    targets.add(target);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>5.3 移动数据</p>

<p>（待）</p>

<p>&ndash;END</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/04/scala-quadratic-sum-of-odd-num-in-100/">计算出从1到100之间所有奇数的平方之和</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-04T14:15:40+08:00" pubdate data-updated="true">Thu 2014-09-04 14:15</time>
		
        
		
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://freewind.github.io/posts/scala-group-entry-problem/">计算出从1到100之间所有奇数的平方之和，代码50字符内（QQ群的验证框长度限制为50）</a>。</p>

<p>如题，题目没啥难度，这50字符的条件莫名的增添压迫感。其实java写也不用50个字符就能搞定的 ！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// (1 to 50) foreach {x =&gt; print("0")}
</span><span class='line'>00000000000000000000000000000000000000000000000000
</span><span class='line'>
</span><span class='line'>// java
</span><span class='line'>int sum=0;for(int i=0;i&lt;100;i+=2)sum+=i*i;
</span><span class='line'>
</span><span class='line'>// scala
</span><span class='line'>(1 to 100).map(a=&gt;if(a%2==1)a*a else 0).foldLeft(0)(_+_)
</span><span class='line'>(0 to 100).foldLeft(0)(_+((a:Int)=&gt;if(a%2==1)a*a else 0)(_))
</span><span class='line'>var sum=0;for(i&lt;- 1 to 100)if(i%2==1)sum+=i*i
</span><span class='line'>var sum=0;for(i&lt;- 1 to 100; if i%2==1)sum+=i*i
</span><span class='line'>
</span><span class='line'>(1 to 100 by 2).foldLeft(0)(_+((a:Int)=&gt;a*a)(_))
</span><span class='line'>(1 to 100 by 2).map(a=&gt;a*a).foldLeft(0)(_+_)
</span><span class='line'>var sum=0;for(i&lt;- 1 to 100 by 2)sum+=i*i
</span><span class='line'>(1 to 100 by 2).map(a=&gt;a*a).reduce(_+_)</span></code></pre></td></tr></table></div></figure>


<p><code>(1 to 100 by 2).map(a=&gt;a*a).reduce(_+_)</code>是里面最短的应该也是最好的了，既没有定义变量同时意义清晰一看就懂。</p>

<p>&ndash;END</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/34">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/32">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>佛爷</h1>
  <p>来之不易, 且等且珍惜. <br>得之我幸; 不得<span style="display:none">-争-复争-且不得</span>, 命也, 乐享天命, 福也. </p>
  <p><a href="https://github.com/winse"><i class="fa fa-github-alt">winse</i></a>&nbsp;&nbsp;<a href="http://weibo.com/winseliu"><i class="fa fa-weibo">winseliu</i></a></p>
</section>
<section>
  <h1><a class='category' href='/blog/categories/recommend/'>Recommend</a></h1>
	<ul role="list">
		
			<li class="post">
				<a href="/blog/2019/04/10/try-k8s/">Try K8s</a>
			</li>
		
			<li class="post">
				<a href="/blog/2018/08/25/video-auto-translate/">视频自动翻译</a>
			</li>
		
			<li class="post">
				<a href="/blog/2018/06/09/reasonable-way-to-access-the-internet/">科学上网（续）</a>
			</li>
		
			<li class="post">
				<a href="/blog/2018/01/20/gitalk-on-octopress/">Gitalk on Octopress</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/11/16/sphinx-generate-docs/">使用Sphinx生成/管理文档</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/10/30/windows-run-ubuntu/">Windows Run Ubuntu</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/07/30/kubeadm-install-kubenetes-on-centos7/">Kubeadm部署kubernetes</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/07/08/casperjs-crawler/">爬虫之CasperJS</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/05/23/spark-on-hive-speculation-shit-bug/">Hive on Spark预测性执行BUG一枚</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/01/27/vnc-server-on-centos7/">在Centos7上安装VNC Server</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/01/25/develop-environment-prepare/">[整理] 环境准备工具集</a>
			</li>
		
			<li class="post">
				<a href="/blog/2017/01/19/nginx-https/">Nginx配置https</a>
			</li>
		
			<li class="post">
				<a href="/blog/2016/09/19/163-open-movies-download/">批量下载163-open的视频</a>
			</li>
		
			<li class="post">
				<a href="/blog/2016/04/23/hadoop-guide-catalog/">[整理] Hadoop入门</a>
			</li>
		
			<li class="post">
				<a href="/blog/2016/04/04/rpm-build-your-package/">RPM打包</a>
			</li>
		
			<li class="post">
				<a href="/blog/2016/03/28/hive-on-spark/">Hive on Spark</a>
			</li>
		
			<li class="post">
				<a href="/blog/2015/11/22/gfw-ladder/">搭梯笔记</a>
			</li>
		
			<li class="post">
				<a href="/blog/2015/08/24/manual-install-supervisor/">Supervisor安装配置</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/10/16/spark-build-and-configuration/">编译/搭建Spark环境</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/08/25/step-by-step-found-java-oom-error/">查找逐步定位Java程序OOM的异常实践</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/07/30/hadoop2-snappy-compress/">Hadoop2 Snappy Compress</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/07/27/start-redis/">[读读书]Redis入门指南</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/04/21/hadoop2-windows-startguide/">Windows下部署/配置/调试hadoop2</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/03/30/git-cheatsheet/">GIT操作记录手册</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/03/18/jekyll-edit-link-in-web-page/">Jekyll页面添加编辑按钮</a>
			</li>
		
			<li class="post">
				<a href="/blog/2014/02/23/quickly-open-program-in-windows/">[Windows运行]快速打开程序</a>
			</li>
		
			<li class="post">
				<a href="/blog/2013/09/19/let-shell-command-efficient/">让敲Shell命令高效起来</a>
			</li>
		
	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/12/08/octopress-generate-toc/">octopress生成TOC</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/12/08/recommand-blogs/">认真的博客</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/09/15/k2-again/">斐讯K2刷机padavan</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/05/11/redmine-on-arm-pi/">在树莓派上部署redmine</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/04/12/appium-android-auto-test/">appium-Android自动化测试</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/07/26/android-linux-via-termux/">Android Linux via Termux</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/04/10/try-bk-dot-tencent-dot-com/">Try bk.tencent.com</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/04/10/try-k8s/">Try K8s</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>

	 
	<ul role="list">
		
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/0/'>0</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/alluxio/'>alluxio</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/android/'>android</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/bigdata/'>bigdata</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/blabla/'>blabla</a> (7) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/books/'>books</a> (6) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/debug/'>debug</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/deprecated/'>deprecated</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/devops/'>devops</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/docker/'>docker</a> (15) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/elasticsearch/'>elasticsearch</a> (3) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/es/'>es</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/flume/'>flume</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/ganglia/'>ganglia</a> (5) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/git/'>git</a> (3) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/hadoop/'>hadoop</a> (44) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/hbase/'>hbase</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/hive/'>hive</a> (8) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/hole/'>hole</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/java/'>java</a> (13) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/jekyll/'>jekyll</a> (8) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/jenkins/'>jenkins</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/jeykll/'>jeykll</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/k2/'>k2</a> (2) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/k8s/'>k8s</a> (9) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/kafka/'>kafka</a> (3) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/kubeadm/'>kubeadm</a> (2) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/logstash/'>logstash</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/map/'>map</a> (2) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/nginx/'>nginx</a> (3) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/puppet/'>puppet</a> (11) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/recommend/'>recommend</a> (27) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/redis/'>redis</a> (7) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/scala/'>scala</a> (4) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/shell/'>shell</a> (4) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/spark/'>spark</a> (12) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/staf/'>staf</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/tachyon/'>tachyon</a> (3) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/tez/'>tez</a> (2) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/tools/'>tools</a> (69) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/topics/'>topics</a> (2) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/vagrant/'>vagrant</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/wsl/'>wsl</a> (1) 
		</li>
		 
		<li style="float:left; width:120px"> 
			<a class='category' href='/blog/categories/zookeeper/'>zookeeper</a> (1) 
		</li>
		
		
		<li style="clear:both; width: 1px; margin: 0; padding: 0;"></li>
		<li class="category"><a href="/blog/archives">All categories</a> (219)</li>
	</ul>
	
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/winse">@winse</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'winse',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
<!--
  <h1>Softs, I&#8217;m using</h1>
  <ul>
    <li class="post">
		<a href="http://hadoop.apache.org/releases.html">hadoop-2.6.3</a>
	</li>
	<li class="post">
		<a href="https://issues.apache.org/jira/browse/HBASE/?selectedTab=com.atlassian.jira.jira-projects-plugin:changelog-panel">hbase-0.96.0</a>
	</li>
	<li class="post">
		<a href="https://hive.apache.org/downloads.html">hive-1.2.1</a>
	</li>
	<li class="post">
		<a href="https://issues.apache.org/jira/browse/TEZ/?selectedTab=com.atlassian.jira.jira-projects-plugin:summary-panel">tez-0.7.0</a>
    </li>
  </ul>
&#8211;>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - Winse Liu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1253103971'%3E%3C/span%3E%3Cscript src='https://s19.cnzz.com/z_stat.php%3Fid%3D1253103971%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

<script>

var time=location.pathname.substring(6).substring(0,11);
var eName=location.pathname.substring(17);
var gitalk = new Gitalk({
  clientID: 'c14f68eac6330d15d984',
  clientSecret: '73b7c1fffa98e299ff0cdd332821201933858e6e',
  repo: 'winse.github.com',
  owner: 'winse',
  admin: ['winse'],
  id: eName,
  labels: ['Gitalk', time],
  body: "http://winse.github.io" + location.pathname,
  createIssueManually: true,
  
  // facebook-like distraction free mode
  distractionFreeMode: false
})

gitalk.render('gitalk-container')

</script>



<script>
/*
$.ajax({
  type: "POST",
  url: "http://log.winseliu.com:20000",
  data: JSON.stringify({
    title: document.title,
    location: JSON.stringify(location),
    referrer: document.referrer,
    userAgent: navigator.userAgent
  }),
  contentType: "application/json; charset=utf-8",
  dataType: "json"
});
*/
</script>











</body>
</html>
